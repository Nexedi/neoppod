// Code generated by lab.nexedi.com/kirr/go123/tracing/cmd/gotrace; DO NOT EDIT.

package weak
// code generated for tracepoints

import (
	"lab.nexedi.com/kirr/go123/tracing"
	"unsafe"
)

// traceevent: traceGotPre(w *Ref)

type _t_traceGotPre struct {
	tracing.Probe
	probefunc     func(w *Ref)
}

var _traceGotPre *_t_traceGotPre

func traceGotPre(w *Ref) {
	if _traceGotPre != nil {
		_traceGotPre_run(w)
	}
}

func _traceGotPre_run(w *Ref) {
	for p := _traceGotPre; p != nil; p = (*_t_traceGotPre)(unsafe.Pointer(p.Next())) {
		p.probefunc(w)
	}
}

func traceGotPre_Attach(pg *tracing.ProbeGroup, probe func(w *Ref)) *tracing.Probe {
	p := _t_traceGotPre{probefunc: probe}
	tracing.AttachProbe(pg, (**tracing.Probe)(unsafe.Pointer(&_traceGotPre)), &p.Probe)
	return &p.Probe
}

// traceevent: traceRelease(w *Ref, released bool)

type _t_traceRelease struct {
	tracing.Probe
	probefunc     func(w *Ref, released bool)
}

var _traceRelease *_t_traceRelease

func traceRelease(w *Ref, released bool) {
	if _traceRelease != nil {
		_traceRelease_run(w, released)
	}
}

func _traceRelease_run(w *Ref, released bool) {
	for p := _traceRelease; p != nil; p = (*_t_traceRelease)(unsafe.Pointer(p.Next())) {
		p.probefunc(w, released)
	}
}

func traceRelease_Attach(pg *tracing.ProbeGroup, probe func(w *Ref, released bool)) *tracing.Probe {
	p := _t_traceRelease{probefunc: probe}
	tracing.AttachProbe(pg, (**tracing.Probe)(unsafe.Pointer(&_traceRelease)), &p.Probe)
	return &p.Probe
}

// trace export signature
func _trace_exporthash_c65df3d81975319429a288a09095370dace6a87b() {}
