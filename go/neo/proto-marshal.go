// DO NOT EDIT - AUTOGENERATED (by protogen.go)

package neo

import (
	"encoding/binary"
	"reflect"
	"sort"

	"../zodb"
)

// packets marshalling

// 0. Address

func (_ *Address) NEOPktMsgCode() uint16 {
	return 0
}

func (p *Address) NEOPktEncodedLen() int {
	return 6 + len(p.Host)
}

func (p *Address) NEOPktEncode(data []byte) {
	{
		l := uint32(len(p.Host))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Port)
}

func (p *Address) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 2+l {
			goto overflow
		}
		nread += 2 + l
		p.Host = string(data[:l])
		data = data[l:]
	}
	p.Port = binary.BigEndian.Uint16(data[0:])
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 1. NodeInfo

func (_ *NodeInfo) NEOPktMsgCode() uint16 {
	return 1
}

func (p *NodeInfo) NEOPktEncodedLen() int {
	return 26 + len(p.Address.Host)
}

func (p *NodeInfo) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
	{
		l := uint32(len(p.Address.Host))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Address.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Address.Port)
	binary.BigEndian.PutUint32(data[2:], uint32(int32(p.NodeUUID)))
	binary.BigEndian.PutUint32(data[6:], uint32(int32(p.NodeState)))
	float64_NEOEncode(data[10:], p.IdTimestamp)
}

func (p *NodeInfo) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < 18+l {
			goto overflow
		}
		nread += 18 + l
		p.Address.Host = string(data[:l])
		data = data[l:]
	}
	p.Address.Port = binary.BigEndian.Uint16(data[0:])
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[2:])))
	p.NodeState = NodeState(int32(binary.BigEndian.Uint32(data[6:])))
	p.IdTimestamp = float64_NEODecode(data[10:])
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 2. CellInfo

func (_ *CellInfo) NEOPktMsgCode() uint16 {
	return 2
}

func (p *CellInfo) NEOPktEncodedLen() int {
	return 8
}

func (p *CellInfo) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeUUID)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.CellState)))
}

func (p *CellInfo) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
	p.CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 3. RowInfo

func (_ *RowInfo) NEOPktMsgCode() uint16 {
	return 3
}

func (p *RowInfo) NEOPktEncodedLen() int {
	return 8 + len(p.CellList)*8
}

func (p *RowInfo) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Offset)
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeUUID)))
			binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
			data = data[8:]
		}
	}
}

func (p *RowInfo) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Offset = binary.BigEndian.Uint32(data[0:])
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.CellList = make([]CellInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a).NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
			data = data[8:]
		}
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 4. Error

func (_ *Error) NEOPktMsgCode() uint16 {
	return 4
}

func (p *Error) NEOPktEncodedLen() int {
	return 8 + len(p.Message)
}

func (p *Error) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(p.Code))
	{
		l := uint32(len(p.Message))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Message)
		data = data[l:]
	}
}

func (p *Error) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Code = ErrorCode(binary.BigEndian.Uint32(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < l {
			goto overflow
		}
		nread += l
		p.Message = string(data[:l])
		data = data[l:]
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 5. Ping

func (_ *Ping) NEOPktMsgCode() uint16 {
	return 5
}

func (p *Ping) NEOPktEncodedLen() int {
	return 0
}

func (p *Ping) NEOPktEncode(data []byte) {
}

func (p *Ping) NEOPktDecode(data []byte) (int, error) {
	return 0, nil
}

// 6. CloseClient

func (_ *CloseClient) NEOPktMsgCode() uint16 {
	return 6
}

func (p *CloseClient) NEOPktEncodedLen() int {
	return 0
}

func (p *CloseClient) NEOPktEncode(data []byte) {
}

func (p *CloseClient) NEOPktDecode(data []byte) (int, error) {
	return 0, nil
}

// 7. RequestIdentification

func (_ *RequestIdentification) NEOPktMsgCode() uint16 {
	return 7
}

func (p *RequestIdentification) NEOPktEncodedLen() int {
	return 26 + len(p.Address.Host) + len(p.ClusterName)
}

func (p *RequestIdentification) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.NodeUUID)))
	{
		l := uint32(len(p.Address.Host))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.Address.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Address.Port)
	{
		l := uint32(len(p.ClusterName))
		binary.BigEndian.PutUint32(data[2:], l)
		data = data[6:]
		copy(data, p.ClusterName)
		data = data[l:]
	}
	float64_NEOEncode(data[0:], p.IdTimestamp)
}

func (p *RequestIdentification) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 6+l {
			goto overflow
		}
		nread += 6 + l
		p.Address.Host = string(data[:l])
		data = data[l:]
	}
	p.Address.Port = binary.BigEndian.Uint16(data[0:])
	{
		l := binary.BigEndian.Uint32(data[2:])
		data = data[6:]
		if uint32(len(data)) < 8+l {
			goto overflow
		}
		nread += 8 + l
		p.ClusterName = string(data[:l])
		data = data[l:]
	}
	p.IdTimestamp = float64_NEODecode(data[0:])
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 8. AcceptIdentification

func (_ *AcceptIdentification) NEOPktMsgCode() uint16 {
	return 8
}

func (p *AcceptIdentification) NEOPktEncodedLen() int {
	return 20
}

func (p *AcceptIdentification) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.MyNodeUUID)))
	binary.BigEndian.PutUint32(data[8:], p.NumPartitions)
	binary.BigEndian.PutUint32(data[12:], p.NumReplicas)
	binary.BigEndian.PutUint32(data[16:], uint32(int32(p.YourNodeUUID)))
}

func (p *AcceptIdentification) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 20 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	p.MyNodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
	p.NumPartitions = binary.BigEndian.Uint32(data[8:])
	p.NumReplicas = binary.BigEndian.Uint32(data[12:])
	p.YourNodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[16:])))
	return 20, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 9. PrimaryMaster

func (_ *PrimaryMaster) NEOPktMsgCode() uint16 {
	return 9
}

func (p *PrimaryMaster) NEOPktEncodedLen() int {
	return 0
}

func (p *PrimaryMaster) NEOPktEncode(data []byte) {
}

func (p *PrimaryMaster) NEOPktDecode(data []byte) (int, error) {
	return 0, nil
}

// 10. AnswerPrimary

func (_ *AnswerPrimary) NEOPktMsgCode() uint16 {
	return 10
}

func (p *AnswerPrimary) NEOPktEncodedLen() int {
	return 4
}

func (p *AnswerPrimary) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.PrimaryNodeUUID)))
}

func (p *AnswerPrimary) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.PrimaryNodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 11. NotPrimaryMaster

func (_ *NotPrimaryMaster) NEOPktMsgCode() uint16 {
	return 11
}

func (p *NotPrimaryMaster) NEOPktEncodedLen() int {
	var size int
	for i := 0; i < len(p.KnownMasterList); i++ {
		a := &p.KnownMasterList[i]
		size += len((*a).Address.Host)
	}
	return 8 + len(p.KnownMasterList)*6 + size
}

func (p *NotPrimaryMaster) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.Primary)))
	{
		l := uint32(len(p.KnownMasterList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.KnownMasterList[i]
			{
				l := uint32(len((*a).Address.Host))
				binary.BigEndian.PutUint32(data[0:], l)
				data = data[4:]
				copy(data, (*a).Address.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Address.Port)
			data = data[2:]
		}
	}
}

func (p *NotPrimaryMaster) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Primary = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		p.KnownMasterList = make([]struct{ Address }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.KnownMasterList[i]
			if uint32(len(data)) < 4 {
				goto overflow
			}
			{
				l := binary.BigEndian.Uint32(data[0:])
				data = data[4:]
				if uint32(len(data)) < 2+l {
					goto overflow
				}
				nread += 2 + l
				(*a).Address.Host = string(data[:l])
				data = data[l:]
			}
			(*a).Address.Port = binary.BigEndian.Uint16(data[0:])
			data = data[2:]
		}
		nread += l * 4
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 12. Recovery

func (_ *Recovery) NEOPktMsgCode() uint16 {
	return 12
}

func (p *Recovery) NEOPktEncodedLen() int {
	return 0
}

func (p *Recovery) NEOPktEncode(data []byte) {
}

func (p *Recovery) NEOPktDecode(data []byte) (int, error) {
	return 0, nil
}

// 13. AnswerRecovery

func (_ *AnswerRecovery) NEOPktMsgCode() uint16 {
	return 13
}

func (p *AnswerRecovery) NEOPktEncodedLen() int {
	return 24
}

func (p *AnswerRecovery) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.BackupTid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.TruncateTid))
}

func (p *AnswerRecovery) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	p.BackupTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.TruncateTid = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 14. LastIDs

func (_ *LastIDs) NEOPktMsgCode() uint16 {
	return 14
}

func (p *LastIDs) NEOPktEncodedLen() int {
	return 0
}

func (p *LastIDs) NEOPktEncode(data []byte) {
}

func (p *LastIDs) NEOPktDecode(data []byte) (int, error) {
	return 0, nil
}

// 15. AnswerLastIDs

func (_ *AnswerLastIDs) NEOPktMsgCode() uint16 {
	return 15
}

func (p *AnswerLastIDs) NEOPktEncodedLen() int {
	return 16
}

func (p *AnswerLastIDs) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.LastOid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LastTid))
}

func (p *AnswerLastIDs) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.LastOid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.LastTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 16. X_PartitionTable

func (_ *X_PartitionTable) NEOPktMsgCode() uint16 {
	return 16
}

func (p *X_PartitionTable) NEOPktEncodedLen() int {
	return 0
}

func (p *X_PartitionTable) NEOPktEncode(data []byte) {
}

func (p *X_PartitionTable) NEOPktDecode(data []byte) (int, error) {
	return 0, nil
}

// 17. AnswerPartitionTable

func (_ *AnswerPartitionTable) NEOPktMsgCode() uint16 {
	return 17
}

func (p *AnswerPartitionTable) NEOPktEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 12 + len(p.RowList)*8 + size
}

func (p *AnswerPartitionTable) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeUUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerPartitionTable) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < l*8 {
					goto overflow
				}
				nread += l * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 18. NotifyPartitionTable

func (_ *NotifyPartitionTable) NEOPktMsgCode() uint16 {
	return 18
}

func (p *NotifyPartitionTable) NEOPktEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 12 + len(p.RowList)*8 + size
}

func (p *NotifyPartitionTable) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeUUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *NotifyPartitionTable) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < l*8 {
					goto overflow
				}
				nread += l * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 19. PartitionChanges

func (_ *PartitionChanges) NEOPktMsgCode() uint16 {
	return 19
}

func (p *PartitionChanges) NEOPktEncodedLen() int {
	return 12 + len(p.CellList)*12
}

func (p *PartitionChanges) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).NodeUUID)))
			binary.BigEndian.PutUint32(data[8:], uint32(int32((*a).CellState)))
			data = data[12:]
		}
	}
}

func (p *PartitionChanges) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*12 {
			goto overflow
		}
		nread += l * 12
		p.CellList = make([]struct {
			Offset    uint32
			NodeUUID  NodeUUID
			CellState CellState
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			(*a).NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
			(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[8:])))
			data = data[12:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 20. StartOperation

func (_ *StartOperation) NEOPktMsgCode() uint16 {
	return 20
}

func (p *StartOperation) NEOPktEncodedLen() int {
	return 1
}

func (p *StartOperation) NEOPktEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Backup)
}

func (p *StartOperation) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.Backup = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 21. StopOperation

func (_ *StopOperation) NEOPktMsgCode() uint16 {
	return 21
}

func (p *StopOperation) NEOPktEncodedLen() int {
	return 0
}

func (p *StopOperation) NEOPktEncode(data []byte) {
}

func (p *StopOperation) NEOPktDecode(data []byte) (int, error) {
	return 0, nil
}

// 22. UnfinishedTransactions

func (_ *UnfinishedTransactions) NEOPktMsgCode() uint16 {
	return 22
}

func (p *UnfinishedTransactions) NEOPktEncodedLen() int {
	return 4 + len(p.RowList)*4
}

func (p *UnfinishedTransactions) NEOPktEncode(data []byte) {
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			data = data[4:]
		}
	}
}

func (p *UnfinishedTransactions) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.RowList = make([]struct{ Offset uint32 }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 23. AnswerUnfinishedTransactions

func (_ *AnswerUnfinishedTransactions) NEOPktMsgCode() uint16 {
	return 23
}

func (p *AnswerUnfinishedTransactions) NEOPktEncodedLen() int {
	return 12 + len(p.TidList)*8
}

func (p *AnswerUnfinishedTransactions) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.MaxTID))
	{
		l := uint32(len(p.TidList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a).UnfinishedTID))
			data = data[8:]
		}
	}
}

func (p *AnswerUnfinishedTransactions) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.TidList = make([]struct{ UnfinishedTID zodb.Tid }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			(*a).UnfinishedTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 24. LockedTransactions

func (_ *LockedTransactions) NEOPktMsgCode() uint16 {
	return 24
}

func (p *LockedTransactions) NEOPktEncodedLen() int {
	return 0
}

func (p *LockedTransactions) NEOPktEncode(data []byte) {
}

func (p *LockedTransactions) NEOPktDecode(data []byte) (int, error) {
	return 0, nil
}

// 25. AnswerLockedTransactions

func (_ *AnswerLockedTransactions) NEOPktMsgCode() uint16 {
	return 25
}

func (p *AnswerLockedTransactions) NEOPktEncodedLen() int {
	return 4 + len(p.TidDict)*16
}

func (p *AnswerLockedTransactions) NEOPktEncode(data []byte) {
	{
		l := uint32(len(p.TidDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]zodb.Tid, 0, l)
		for key := range p.TidDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			binary.BigEndian.PutUint64(data[8:], uint64(p.TidDict[key]))
			data = data[16:]
		}
	}
}

func (p *AnswerLockedTransactions) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*16 {
			goto overflow
		}
		nread += l * 16
		p.TidDict = make(map[zodb.Tid]zodb.Tid, l)
		m := p.TidDict
		for i := 0; uint32(i) < l; i++ {
			key := zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			m[key] = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
			data = data[16:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 26. FinalTID

func (_ *FinalTID) NEOPktMsgCode() uint16 {
	return 26
}

func (p *FinalTID) NEOPktEncodedLen() int {
	return 8
}

func (p *FinalTID) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
}

func (p *FinalTID) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 27. AnswerFinalTID

func (_ *AnswerFinalTID) NEOPktMsgCode() uint16 {
	return 27
}

func (p *AnswerFinalTID) NEOPktEncodedLen() int {
	return 8
}

func (p *AnswerFinalTID) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerFinalTID) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 28. ValidateTransaction

func (_ *ValidateTransaction) NEOPktMsgCode() uint16 {
	return 28
}

func (p *ValidateTransaction) NEOPktEncodedLen() int {
	return 16
}

func (p *ValidateTransaction) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *ValidateTransaction) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 29. BeginTransaction

func (_ *BeginTransaction) NEOPktMsgCode() uint16 {
	return 29
}

func (p *BeginTransaction) NEOPktEncodedLen() int {
	return 8
}

func (p *BeginTransaction) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *BeginTransaction) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 30. AnswerBeginTransaction

func (_ *AnswerBeginTransaction) NEOPktMsgCode() uint16 {
	return 30
}

func (p *AnswerBeginTransaction) NEOPktEncodedLen() int {
	return 8
}

func (p *AnswerBeginTransaction) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerBeginTransaction) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 31. FailedVote

func (_ *FailedVote) NEOPktMsgCode() uint16 {
	return 31
}

func (p *FailedVote) NEOPktEncodedLen() int {
	return 12 + len(p.NodeList)*4
}

func (p *FailedVote) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *FailedVote) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 32. FinishTransaction

func (_ *FinishTransaction) NEOPktMsgCode() uint16 {
	return 32
}

func (p *FinishTransaction) NEOPktEncodedLen() int {
	return 16 + len(p.OIDList)*8 + len(p.CheckedList)*8
}

func (p *FinishTransaction) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.OIDList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OIDList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
	{
		l := uint32(len(p.CheckedList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CheckedList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *FinishTransaction) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 4+l*8 {
			goto overflow
		}
		nread += 4 + l*8
		p.OIDList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OIDList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.CheckedList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CheckedList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 33. AnswerFinishTransaction

func (_ *AnswerFinishTransaction) NEOPktMsgCode() uint16 {
	return 33
}

func (p *AnswerFinishTransaction) NEOPktEncodedLen() int {
	return 16
}

func (p *AnswerFinishTransaction) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *AnswerFinishTransaction) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 34. NotifyTransactionFinished

func (_ *NotifyTransactionFinished) NEOPktMsgCode() uint16 {
	return 34
}

func (p *NotifyTransactionFinished) NEOPktEncodedLen() int {
	return 16
}

func (p *NotifyTransactionFinished) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *NotifyTransactionFinished) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 35. LockInformation

func (_ *LockInformation) NEOPktMsgCode() uint16 {
	return 35
}

func (p *LockInformation) NEOPktEncodedLen() int {
	return 16
}

func (p *LockInformation) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Ttid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *LockInformation) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.Ttid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 36. AnswerLockInformation

func (_ *AnswerLockInformation) NEOPktMsgCode() uint16 {
	return 36
}

func (p *AnswerLockInformation) NEOPktEncodedLen() int {
	return 8
}

func (p *AnswerLockInformation) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Ttid))
}

func (p *AnswerLockInformation) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Ttid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 37. InvalidateObjects

func (_ *InvalidateObjects) NEOPktMsgCode() uint16 {
	return 37
}

func (p *InvalidateObjects) NEOPktEncodedLen() int {
	return 12 + len(p.OidList)*8
}

func (p *InvalidateObjects) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *InvalidateObjects) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 38. UnlockInformation

func (_ *UnlockInformation) NEOPktMsgCode() uint16 {
	return 38
}

func (p *UnlockInformation) NEOPktEncodedLen() int {
	return 8
}

func (p *UnlockInformation) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
}

func (p *UnlockInformation) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 39. GenerateOIDs

func (_ *GenerateOIDs) NEOPktMsgCode() uint16 {
	return 39
}

func (p *GenerateOIDs) NEOPktEncodedLen() int {
	return 4
}

func (p *GenerateOIDs) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.NumOIDs)
}

func (p *GenerateOIDs) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.NumOIDs = binary.BigEndian.Uint32(data[0:])
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 40. AnswerGenerateOIDs

func (_ *AnswerGenerateOIDs) NEOPktMsgCode() uint16 {
	return 40
}

func (p *AnswerGenerateOIDs) NEOPktEncodedLen() int {
	return 4 + len(p.OidList)*8
}

func (p *AnswerGenerateOIDs) NEOPktEncode(data []byte) {
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerGenerateOIDs) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 41. Deadlock

func (_ *Deadlock) NEOPktMsgCode() uint16 {
	return 41
}

func (p *Deadlock) NEOPktEncodedLen() int {
	return 16
}

func (p *Deadlock) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LockingTid))
}

func (p *Deadlock) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LockingTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 42. RebaseTransaction

func (_ *RebaseTransaction) NEOPktMsgCode() uint16 {
	return 42
}

func (p *RebaseTransaction) NEOPktEncodedLen() int {
	return 16
}

func (p *RebaseTransaction) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LockingTid))
}

func (p *RebaseTransaction) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LockingTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 43. AnswerRebaseTransaction

func (_ *AnswerRebaseTransaction) NEOPktMsgCode() uint16 {
	return 43
}

func (p *AnswerRebaseTransaction) NEOPktEncodedLen() int {
	return 4 + len(p.OidList)*8
}

func (p *AnswerRebaseTransaction) NEOPktEncode(data []byte) {
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerRebaseTransaction) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 44. RebaseObject

func (_ *RebaseObject) NEOPktMsgCode() uint16 {
	return 44
}

func (p *RebaseObject) NEOPktEncodedLen() int {
	return 16
}

func (p *RebaseObject) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Oid))
}

func (p *RebaseObject) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 45. AnswerRebaseObject

func (_ *AnswerRebaseObject) NEOPktMsgCode() uint16 {
	return 45
}

func (p *AnswerRebaseObject) NEOPktEncodedLen() int {
	return 41 + len(p.Data)
}

func (p *AnswerRebaseObject) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[8:], uint64(p.ConflictSerial))
	(data[16:])[0] = bool2byte(p.Compression)
	copy(data[17:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		copy(data, p.Data)
		data = data[l:]
	}
}

func (p *AnswerRebaseObject) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 41 {
		goto overflow
	}
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.ConflictSerial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Compression = byte2bool((data[16:])[0])
	copy(p.Checksum[:], data[17:37])
	{
		l := binary.BigEndian.Uint32(data[37:])
		data = data[41:]
		if uint32(len(data)) < l {
			goto overflow
		}
		nread += l
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	return 41 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 46. StoreObject

func (_ *StoreObject) NEOPktMsgCode() uint16 {
	return 46
}

func (p *StoreObject) NEOPktEncodedLen() int {
	return 57 + len(p.Data)
}

func (p *StoreObject) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	(data[16:])[0] = bool2byte(p.Compression)
	copy(data[17:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		copy(data, p.Data)
		data = data[l:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *StoreObject) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 41 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Compression = byte2bool((data[16:])[0])
	copy(p.Checksum[:], data[17:37])
	{
		l := binary.BigEndian.Uint32(data[37:])
		data = data[41:]
		if uint32(len(data)) < 16+l {
			goto overflow
		}
		nread += 16 + l
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	p.DataSerial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 41 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 47. AnswerStoreObject

func (_ *AnswerStoreObject) NEOPktMsgCode() uint16 {
	return 47
}

func (p *AnswerStoreObject) NEOPktEncodedLen() int {
	return 8
}

func (p *AnswerStoreObject) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Conflict))
}

func (p *AnswerStoreObject) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Conflict = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 48. AbortTransaction

func (_ *AbortTransaction) NEOPktMsgCode() uint16 {
	return 48
}

func (p *AbortTransaction) NEOPktEncodedLen() int {
	return 12 + len(p.NodeList)*4
}

func (p *AbortTransaction) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *AbortTransaction) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 49. StoreTransaction

func (_ *StoreTransaction) NEOPktMsgCode() uint16 {
	return 49
}

func (p *StoreTransaction) NEOPktEncodedLen() int {
	return 24 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *StoreTransaction) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *StoreTransaction) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.User = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Description = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Extension = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 50. VoteTransaction

func (_ *VoteTransaction) NEOPktMsgCode() uint16 {
	return 50
}

func (p *VoteTransaction) NEOPktEncodedLen() int {
	return 8
}

func (p *VoteTransaction) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *VoteTransaction) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 51. GetObject

func (_ *GetObject) NEOPktMsgCode() uint16 {
	return 51
}

func (p *GetObject) NEOPktEncodedLen() int {
	return 24
}

func (p *GetObject) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[16:], uint64(p.Tid))
}

func (p *GetObject) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 52. AnswerGetObject

func (_ *AnswerGetObject) NEOPktMsgCode() uint16 {
	return 52
}

func (p *AnswerGetObject) NEOPktEncodedLen() int {
	return 57 + len(p.Data)
}

func (p *AnswerGetObject) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[16:], uint64(p.NextSerial))
	(data[24:])[0] = bool2byte(p.Compression)
	copy(data[25:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[45:], l)
		data = data[49:]
		copy(data, p.Data)
		data = data[l:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
}

func (p *AnswerGetObject) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 49 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.NextSerial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	p.Compression = byte2bool((data[24:])[0])
	copy(p.Checksum[:], data[25:45])
	{
		l := binary.BigEndian.Uint32(data[45:])
		data = data[49:]
		if uint32(len(data)) < 8+l {
			goto overflow
		}
		nread += 8 + l
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	p.DataSerial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 49 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 53. TIDList

func (_ *TIDList) NEOPktMsgCode() uint16 {
	return 53
}

func (p *TIDList) NEOPktEncodedLen() int {
	return 20
}

func (p *TIDList) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], p.First)
	binary.BigEndian.PutUint64(data[8:], p.Last)
	binary.BigEndian.PutUint32(data[16:], p.Partition)
}

func (p *TIDList) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 20 {
		goto overflow
	}
	p.First = binary.BigEndian.Uint64(data[0:])
	p.Last = binary.BigEndian.Uint64(data[8:])
	p.Partition = binary.BigEndian.Uint32(data[16:])
	return 20, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 54. AnswerTIDList

func (_ *AnswerTIDList) NEOPktMsgCode() uint16 {
	return 54
}

func (p *AnswerTIDList) NEOPktEncodedLen() int {
	return 4 + len(p.TIDList)*8
}

func (p *AnswerTIDList) NEOPktEncode(data []byte) {
	{
		l := uint32(len(p.TIDList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TIDList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTIDList) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.TIDList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TIDList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 55. TIDListFrom

func (_ *TIDListFrom) NEOPktMsgCode() uint16 {
	return 55
}

func (p *TIDListFrom) NEOPktEncodedLen() int {
	return 24
}

func (p *TIDListFrom) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
	binary.BigEndian.PutUint32(data[16:], p.Length)
	binary.BigEndian.PutUint32(data[20:], p.Partition)
}

func (p *TIDListFrom) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Length = binary.BigEndian.Uint32(data[16:])
	p.Partition = binary.BigEndian.Uint32(data[20:])
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 56. AnswerTIDListFrom

func (_ *AnswerTIDListFrom) NEOPktMsgCode() uint16 {
	return 56
}

func (p *AnswerTIDListFrom) NEOPktEncodedLen() int {
	return 4 + len(p.TidList)*8
}

func (p *AnswerTIDListFrom) NEOPktEncode(data []byte) {
	{
		l := uint32(len(p.TidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTIDListFrom) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.TidList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 57. TransactionInformation

func (_ *TransactionInformation) NEOPktMsgCode() uint16 {
	return 57
}

func (p *TransactionInformation) NEOPktEncodedLen() int {
	return 8
}

func (p *TransactionInformation) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *TransactionInformation) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 58. AnswerTransactionInformation

func (_ *AnswerTransactionInformation) NEOPktMsgCode() uint16 {
	return 58
}

func (p *AnswerTransactionInformation) NEOPktEncodedLen() int {
	return 25 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *AnswerTransactionInformation) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	(data[0:])[0] = bool2byte(p.Packed)
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[1:], l)
		data = data[5:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTransactionInformation) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.User = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Description = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 5+l {
			goto overflow
		}
		nread += 5 + l
		p.Extension = string(data[:l])
		data = data[l:]
	}
	p.Packed = byte2bool((data[0:])[0])
	{
		l := binary.BigEndian.Uint32(data[1:])
		data = data[5:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 59. ObjectHistory

func (_ *ObjectHistory) NEOPktMsgCode() uint16 {
	return 59
}

func (p *ObjectHistory) NEOPktEncodedLen() int {
	return 24
}

func (p *ObjectHistory) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], p.First)
	binary.BigEndian.PutUint64(data[16:], p.Last)
}

func (p *ObjectHistory) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.First = binary.BigEndian.Uint64(data[8:])
	p.Last = binary.BigEndian.Uint64(data[16:])
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 60. AnswerObjectHistory

func (_ *AnswerObjectHistory) NEOPktMsgCode() uint16 {
	return 60
}

func (p *AnswerObjectHistory) NEOPktEncodedLen() int {
	return 12 + len(p.HistoryList)*12
}

func (p *AnswerObjectHistory) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	{
		l := uint32(len(p.HistoryList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.HistoryList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a).Serial))
			binary.BigEndian.PutUint32(data[8:], (*a).Size)
			data = data[12:]
		}
	}
}

func (p *AnswerObjectHistory) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*12 {
			goto overflow
		}
		nread += l * 12
		p.HistoryList = make([]struct {
			Serial zodb.Tid
			Size   uint32
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.HistoryList[i]
			(*a).Serial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			(*a).Size = binary.BigEndian.Uint32(data[8:])
			data = data[12:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 61. PartitionList

func (_ *PartitionList) NEOPktMsgCode() uint16 {
	return 61
}

func (p *PartitionList) NEOPktEncodedLen() int {
	return 12
}

func (p *PartitionList) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.MinOffset)
	binary.BigEndian.PutUint32(data[4:], p.MaxOffset)
	binary.BigEndian.PutUint32(data[8:], uint32(int32(p.NodeUUID)))
}

func (p *PartitionList) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.MinOffset = binary.BigEndian.Uint32(data[0:])
	p.MaxOffset = binary.BigEndian.Uint32(data[4:])
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[8:])))
	return 12, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 62. AnswerPartitionList

func (_ *AnswerPartitionList) NEOPktMsgCode() uint16 {
	return 62
}

func (p *AnswerPartitionList) NEOPktEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 12 + len(p.RowList)*8 + size
}

func (p *AnswerPartitionList) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeUUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerPartitionList) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < l*8 {
					goto overflow
				}
				nread += l * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 63. NodeList

func (_ *NodeList) NEOPktMsgCode() uint16 {
	return 63
}

func (p *NodeList) NEOPktEncodedLen() int {
	return 4
}

func (p *NodeList) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
}

func (p *NodeList) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 64. AnswerNodeList

func (_ *AnswerNodeList) NEOPktMsgCode() uint16 {
	return 64
}

func (p *AnswerNodeList) NEOPktEncodedLen() int {
	var size int
	for i := 0; i < len(p.NodeList); i++ {
		a := &p.NodeList[i]
		size += len((*a).Address.Host)
	}
	return 4 + len(p.NodeList)*26 + size
}

func (p *AnswerNodeList) NEOPktEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeType)))
			{
				l := uint32(len((*a).Address.Host))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				copy(data, (*a).Address.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Address.Port)
			binary.BigEndian.PutUint32(data[2:], uint32(int32((*a).NodeUUID)))
			binary.BigEndian.PutUint32(data[6:], uint32(int32((*a).NodeState)))
			float64_NEOEncode(data[10:], (*a).IdTimestamp)
			data = data[18:]
		}
	}
}

func (p *AnswerNodeList) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		p.NodeList = make([]NodeInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < 18+l {
					goto overflow
				}
				nread += 18 + l
				(*a).Address.Host = string(data[:l])
				data = data[l:]
			}
			(*a).Address.Port = binary.BigEndian.Uint16(data[0:])
			(*a).NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[2:])))
			(*a).NodeState = NodeState(int32(binary.BigEndian.Uint32(data[6:])))
			(*a).IdTimestamp = float64_NEODecode(data[10:])
			data = data[18:]
		}
		nread += l * 8
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 65. SetNodeState

func (_ *SetNodeState) NEOPktMsgCode() uint16 {
	return 65
}

func (p *SetNodeState) NEOPktEncodedLen() int {
	return 8
}

func (p *SetNodeState) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeUUID)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.NodeState)))
}

func (p *SetNodeState) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
	p.NodeState = NodeState(int32(binary.BigEndian.Uint32(data[4:])))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 66. AddPendingNodes

func (_ *AddPendingNodes) NEOPktMsgCode() uint16 {
	return 66
}

func (p *AddPendingNodes) NEOPktEncodedLen() int {
	return 4 + len(p.NodeList)*4
}

func (p *AddPendingNodes) NEOPktEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *AddPendingNodes) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 67. TweakPartitionTable

func (_ *TweakPartitionTable) NEOPktMsgCode() uint16 {
	return 67
}

func (p *TweakPartitionTable) NEOPktEncodedLen() int {
	return 4 + len(p.NodeList)*4
}

func (p *TweakPartitionTable) NEOPktEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *TweakPartitionTable) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 68. NotifyNodeInformation

func (_ *NotifyNodeInformation) NEOPktMsgCode() uint16 {
	return 68
}

func (p *NotifyNodeInformation) NEOPktEncodedLen() int {
	var size int
	for i := 0; i < len(p.NodeList); i++ {
		a := &p.NodeList[i]
		size += len((*a).Address.Host)
	}
	return 12 + len(p.NodeList)*26 + size
}

func (p *NotifyNodeInformation) NEOPktEncode(data []byte) {
	float64_NEOEncode(data[0:], p.IdTimestamp)
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeType)))
			{
				l := uint32(len((*a).Address.Host))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				copy(data, (*a).Address.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Address.Port)
			binary.BigEndian.PutUint32(data[2:], uint32(int32((*a).NodeUUID)))
			binary.BigEndian.PutUint32(data[6:], uint32(int32((*a).NodeState)))
			float64_NEOEncode(data[10:], (*a).IdTimestamp)
			data = data[18:]
		}
	}
}

func (p *NotifyNodeInformation) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.IdTimestamp = float64_NEODecode(data[0:])
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.NodeList = make([]NodeInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < 18+l {
					goto overflow
				}
				nread += 18 + l
				(*a).Address.Host = string(data[:l])
				data = data[l:]
			}
			(*a).Address.Port = binary.BigEndian.Uint16(data[0:])
			(*a).NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[2:])))
			(*a).NodeState = NodeState(int32(binary.BigEndian.Uint32(data[6:])))
			(*a).IdTimestamp = float64_NEODecode(data[10:])
			data = data[18:]
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 69. NodeInformation

func (_ *NodeInformation) NEOPktMsgCode() uint16 {
	return 69
}

func (p *NodeInformation) NEOPktEncodedLen() int {
	return 0
}

func (p *NodeInformation) NEOPktEncode(data []byte) {
}

func (p *NodeInformation) NEOPktDecode(data []byte) (int, error) {
	return 0, nil
}

// 70. SetClusterState

func (_ *SetClusterState) NEOPktMsgCode() uint16 {
	return 70
}

func (p *SetClusterState) NEOPktEncodedLen() int {
	return 4
}

func (p *SetClusterState) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *SetClusterState) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 71. repairFlags

func (_ *repairFlags) NEOPktMsgCode() uint16 {
	return 71
}

func (p *repairFlags) NEOPktEncodedLen() int {
	return 1
}

func (p *repairFlags) NEOPktEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.DryRun)
}

func (p *repairFlags) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.DryRun = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 72. Repair

func (_ *Repair) NEOPktMsgCode() uint16 {
	return 72
}

func (p *Repair) NEOPktEncodedLen() int {
	return 5 + len(p.NodeList)*4
}

func (p *Repair) NEOPktEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
	(data[0:])[0] = bool2byte(p.repairFlags.DryRun)
}

func (p *Repair) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 1+l*4 {
			goto overflow
		}
		nread += 1 + l*4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	p.repairFlags.DryRun = byte2bool((data[0:])[0])
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 73. RepairOne

func (_ *RepairOne) NEOPktMsgCode() uint16 {
	return 73
}

func (p *RepairOne) NEOPktEncodedLen() int {
	return 1
}

func (p *RepairOne) NEOPktEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.repairFlags.DryRun)
}

func (p *RepairOne) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.repairFlags.DryRun = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 74. ClusterInformation

func (_ *ClusterInformation) NEOPktMsgCode() uint16 {
	return 74
}

func (p *ClusterInformation) NEOPktEncodedLen() int {
	return 4
}

func (p *ClusterInformation) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *ClusterInformation) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 75. X_ClusterState

func (_ *X_ClusterState) NEOPktMsgCode() uint16 {
	return 75
}

func (p *X_ClusterState) NEOPktEncodedLen() int {
	return 4
}

func (p *X_ClusterState) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *X_ClusterState) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 76. ObjectUndoSerial

func (_ *ObjectUndoSerial) NEOPktMsgCode() uint16 {
	return 76
}

func (p *ObjectUndoSerial) NEOPktEncodedLen() int {
	return 28 + len(p.OidList)*8
}

func (p *ObjectUndoSerial) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.UndoneTID))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[24:], l)
		data = data[28:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *ObjectUndoSerial) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 28 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.UndoneTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	{
		l := binary.BigEndian.Uint32(data[24:])
		data = data[28:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 28 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 77. AnswerObjectUndoSerial

func (_ *AnswerObjectUndoSerial) NEOPktMsgCode() uint16 {
	return 77
}

func (p *AnswerObjectUndoSerial) NEOPktEncodedLen() int {
	return 4 + len(p.ObjectTIDDict)*25
}

func (p *AnswerObjectUndoSerial) NEOPktEncode(data []byte) {
	{
		l := uint32(len(p.ObjectTIDDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]zodb.Oid, 0, l)
		for key := range p.ObjectTIDDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			binary.BigEndian.PutUint64(data[8:], uint64(p.ObjectTIDDict[key].CurrentSerial))
			binary.BigEndian.PutUint64(data[16:], uint64(p.ObjectTIDDict[key].UndoSerial))
			(data[24:])[0] = bool2byte(p.ObjectTIDDict[key].IsCurrent)
			data = data[25:]
		}
	}
}

func (p *AnswerObjectUndoSerial) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*25 {
			goto overflow
		}
		nread += l * 25
		p.ObjectTIDDict = make(map[zodb.Oid]struct {
			CurrentSerial zodb.Tid
			UndoSerial    zodb.Tid
			IsCurrent     bool
		}, l)
		m := p.ObjectTIDDict
		for i := 0; uint32(i) < l; i++ {
			key := zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			var v struct {
				CurrentSerial zodb.Tid
				UndoSerial    zodb.Tid
				IsCurrent     bool
			}
			v.CurrentSerial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
			v.UndoSerial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
			v.IsCurrent = byte2bool((data[24:])[0])
			m[key] = v
			data = data[25:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 78. CheckCurrentSerial

func (_ *CheckCurrentSerial) NEOPktMsgCode() uint16 {
	return 78
}

func (p *CheckCurrentSerial) NEOPktEncodedLen() int {
	return 24
}

func (p *CheckCurrentSerial) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.Serial))
}

func (p *CheckCurrentSerial) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[8:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 79. Pack

func (_ *Pack) NEOPktMsgCode() uint16 {
	return 79
}

func (p *Pack) NEOPktEncodedLen() int {
	return 8
}

func (p *Pack) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *Pack) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 80. AnswerPack

func (_ *AnswerPack) NEOPktMsgCode() uint16 {
	return 80
}

func (p *AnswerPack) NEOPktEncodedLen() int {
	return 1
}

func (p *AnswerPack) NEOPktEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Status)
}

func (p *AnswerPack) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.Status = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 81. CheckReplicas

func (_ *CheckReplicas) NEOPktMsgCode() uint16 {
	return 81
}

func (p *CheckReplicas) NEOPktEncodedLen() int {
	return 20 + len(p.PartitionDict)*8
}

func (p *CheckReplicas) NEOPktEncode(data []byte) {
	{
		l := uint32(len(p.PartitionDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]uint32, 0, l)
		for key := range p.PartitionDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint32(data[0:], key)
			binary.BigEndian.PutUint32(data[4:], uint32(int32(p.PartitionDict[key])))
			data = data[8:]
		}
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *CheckReplicas) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 16+l*8 {
			goto overflow
		}
		nread += 16 + l*8
		p.PartitionDict = make(map[uint32]NodeUUID, l)
		m := p.PartitionDict
		for i := 0; uint32(i) < l; i++ {
			key := binary.BigEndian.Uint32(data[0:])
			m[key] = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
			data = data[8:]
		}
	}
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 82. CheckPartition

func (_ *CheckPartition) NEOPktMsgCode() uint16 {
	return 82
}

func (p *CheckPartition) NEOPktEncodedLen() int {
	return 30 + len(p.Source.UpstreamName) + len(p.Source.Address.Host)
}

func (p *CheckPartition) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	{
		l := uint32(len(p.Source.UpstreamName))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Source.UpstreamName)
		data = data[l:]
	}
	{
		l := uint32(len(p.Source.Address.Host))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Source.Address.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Source.Address.Port)
	binary.BigEndian.PutUint64(data[2:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[10:], uint64(p.MaxTID))
}

func (p *CheckPartition) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Source.UpstreamName = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 18+l {
			goto overflow
		}
		nread += 18 + l
		p.Source.Address.Host = string(data[:l])
		data = data[l:]
	}
	p.Source.Address.Port = binary.BigEndian.Uint16(data[0:])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[2:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[10:]))
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 83. CheckTIDRange

func (_ *CheckTIDRange) NEOPktMsgCode() uint16 {
	return 83
}

func (p *CheckTIDRange) NEOPktEncodedLen() int {
	return 24
}

func (p *CheckTIDRange) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTID))
}

func (p *CheckTIDRange) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	p.Length = binary.BigEndian.Uint32(data[4:])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 84. AnswerCheckTIDRange

func (_ *AnswerCheckTIDRange) NEOPktMsgCode() uint16 {
	return 84
}

func (p *AnswerCheckTIDRange) NEOPktEncodedLen() int {
	return 32
}

func (p *AnswerCheckTIDRange) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Count)
	copy(data[4:], p.Checksum[:])
	binary.BigEndian.PutUint64(data[24:], uint64(p.MaxTID))
}

func (p *AnswerCheckTIDRange) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 32 {
		goto overflow
	}
	p.Count = binary.BigEndian.Uint32(data[0:])
	copy(p.Checksum[:], data[4:24])
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[24:]))
	return 32, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 85. CheckSerialRange

func (_ *CheckSerialRange) NEOPktMsgCode() uint16 {
	return 85
}

func (p *CheckSerialRange) NEOPktEncodedLen() int {
	return 32
}

func (p *CheckSerialRange) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTID))
	binary.BigEndian.PutUint64(data[24:], uint64(p.MinOID))
}

func (p *CheckSerialRange) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 32 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	p.Length = binary.BigEndian.Uint32(data[4:])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	p.MinOID = zodb.Oid(binary.BigEndian.Uint64(data[24:]))
	return 32, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 86. AnswerCheckSerialRange

func (_ *AnswerCheckSerialRange) NEOPktMsgCode() uint16 {
	return 86
}

func (p *AnswerCheckSerialRange) NEOPktEncodedLen() int {
	return 60
}

func (p *AnswerCheckSerialRange) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Count)
	copy(data[4:], p.TidChecksum[:])
	binary.BigEndian.PutUint64(data[24:], uint64(p.MaxTID))
	copy(data[32:], p.OidChecksum[:])
	binary.BigEndian.PutUint64(data[52:], uint64(p.MaxOID))
}

func (p *AnswerCheckSerialRange) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 60 {
		goto overflow
	}
	p.Count = binary.BigEndian.Uint32(data[0:])
	copy(p.TidChecksum[:], data[4:24])
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[24:]))
	copy(p.OidChecksum[:], data[32:52])
	p.MaxOID = zodb.Oid(binary.BigEndian.Uint64(data[52:]))
	return 60, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 87. PartitionCorrupted

func (_ *PartitionCorrupted) NEOPktMsgCode() uint16 {
	return 87
}

func (p *PartitionCorrupted) NEOPktEncodedLen() int {
	return 8 + len(p.CellList)*4
}

func (p *PartitionCorrupted) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *PartitionCorrupted) NEOPktDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.CellList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 88. LastTransaction

func (_ *LastTransaction) NEOPktMsgCode() uint16 {
	return 88
}

func (p *LastTransaction) NEOPktEncodedLen() int {
	return 0
}

func (p *LastTransaction) NEOPktEncode(data []byte) {
}

func (p *LastTransaction) NEOPktDecode(data []byte) (int, error) {
	return 0, nil
}

// 89. AnswerLastTransaction

func (_ *AnswerLastTransaction) NEOPktMsgCode() uint16 {
	return 89
}

func (p *AnswerLastTransaction) NEOPktEncodedLen() int {
	return 8
}

func (p *AnswerLastTransaction) NEOPktEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerLastTransaction) NEOPktDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 90. NotifyReady

func (_ *NotifyReady) NEOPktMsgCode() uint16 {
	return 90
}

func (p *NotifyReady) NEOPktEncodedLen() int {
	return 0
}

func (p *NotifyReady) NEOPktEncode(data []byte) {
}

func (p *NotifyReady) NEOPktDecode(data []byte) (int, error) {
	return 0, nil
}

// registry of packet types
var pktTypeRegistry = map[uint16]reflect.Type{
	0:  reflect.TypeOf(Address{}),
	1:  reflect.TypeOf(NodeInfo{}),
	2:  reflect.TypeOf(CellInfo{}),
	3:  reflect.TypeOf(RowInfo{}),
	4:  reflect.TypeOf(Error{}),
	5:  reflect.TypeOf(Ping{}),
	6:  reflect.TypeOf(CloseClient{}),
	7:  reflect.TypeOf(RequestIdentification{}),
	8:  reflect.TypeOf(AcceptIdentification{}),
	9:  reflect.TypeOf(PrimaryMaster{}),
	10: reflect.TypeOf(AnswerPrimary{}),
	11: reflect.TypeOf(NotPrimaryMaster{}),
	12: reflect.TypeOf(Recovery{}),
	13: reflect.TypeOf(AnswerRecovery{}),
	14: reflect.TypeOf(LastIDs{}),
	15: reflect.TypeOf(AnswerLastIDs{}),
	16: reflect.TypeOf(X_PartitionTable{}),
	17: reflect.TypeOf(AnswerPartitionTable{}),
	18: reflect.TypeOf(NotifyPartitionTable{}),
	19: reflect.TypeOf(PartitionChanges{}),
	20: reflect.TypeOf(StartOperation{}),
	21: reflect.TypeOf(StopOperation{}),
	22: reflect.TypeOf(UnfinishedTransactions{}),
	23: reflect.TypeOf(AnswerUnfinishedTransactions{}),
	24: reflect.TypeOf(LockedTransactions{}),
	25: reflect.TypeOf(AnswerLockedTransactions{}),
	26: reflect.TypeOf(FinalTID{}),
	27: reflect.TypeOf(AnswerFinalTID{}),
	28: reflect.TypeOf(ValidateTransaction{}),
	29: reflect.TypeOf(BeginTransaction{}),
	30: reflect.TypeOf(AnswerBeginTransaction{}),
	31: reflect.TypeOf(FailedVote{}),
	32: reflect.TypeOf(FinishTransaction{}),
	33: reflect.TypeOf(AnswerFinishTransaction{}),
	34: reflect.TypeOf(NotifyTransactionFinished{}),
	35: reflect.TypeOf(LockInformation{}),
	36: reflect.TypeOf(AnswerLockInformation{}),
	37: reflect.TypeOf(InvalidateObjects{}),
	38: reflect.TypeOf(UnlockInformation{}),
	39: reflect.TypeOf(GenerateOIDs{}),
	40: reflect.TypeOf(AnswerGenerateOIDs{}),
	41: reflect.TypeOf(Deadlock{}),
	42: reflect.TypeOf(RebaseTransaction{}),
	43: reflect.TypeOf(AnswerRebaseTransaction{}),
	44: reflect.TypeOf(RebaseObject{}),
	45: reflect.TypeOf(AnswerRebaseObject{}),
	46: reflect.TypeOf(StoreObject{}),
	47: reflect.TypeOf(AnswerStoreObject{}),
	48: reflect.TypeOf(AbortTransaction{}),
	49: reflect.TypeOf(StoreTransaction{}),
	50: reflect.TypeOf(VoteTransaction{}),
	51: reflect.TypeOf(GetObject{}),
	52: reflect.TypeOf(AnswerGetObject{}),
	53: reflect.TypeOf(TIDList{}),
	54: reflect.TypeOf(AnswerTIDList{}),
	55: reflect.TypeOf(TIDListFrom{}),
	56: reflect.TypeOf(AnswerTIDListFrom{}),
	57: reflect.TypeOf(TransactionInformation{}),
	58: reflect.TypeOf(AnswerTransactionInformation{}),
	59: reflect.TypeOf(ObjectHistory{}),
	60: reflect.TypeOf(AnswerObjectHistory{}),
	61: reflect.TypeOf(PartitionList{}),
	62: reflect.TypeOf(AnswerPartitionList{}),
	63: reflect.TypeOf(NodeList{}),
	64: reflect.TypeOf(AnswerNodeList{}),
	65: reflect.TypeOf(SetNodeState{}),
	66: reflect.TypeOf(AddPendingNodes{}),
	67: reflect.TypeOf(TweakPartitionTable{}),
	68: reflect.TypeOf(NotifyNodeInformation{}),
	69: reflect.TypeOf(NodeInformation{}),
	70: reflect.TypeOf(SetClusterState{}),
	71: reflect.TypeOf(repairFlags{}),
	72: reflect.TypeOf(Repair{}),
	73: reflect.TypeOf(RepairOne{}),
	74: reflect.TypeOf(ClusterInformation{}),
	75: reflect.TypeOf(X_ClusterState{}),
	76: reflect.TypeOf(ObjectUndoSerial{}),
	77: reflect.TypeOf(AnswerObjectUndoSerial{}),
	78: reflect.TypeOf(CheckCurrentSerial{}),
	79: reflect.TypeOf(Pack{}),
	80: reflect.TypeOf(AnswerPack{}),
	81: reflect.TypeOf(CheckReplicas{}),
	82: reflect.TypeOf(CheckPartition{}),
	83: reflect.TypeOf(CheckTIDRange{}),
	84: reflect.TypeOf(AnswerCheckTIDRange{}),
	85: reflect.TypeOf(CheckSerialRange{}),
	86: reflect.TypeOf(AnswerCheckSerialRange{}),
	87: reflect.TypeOf(PartitionCorrupted{}),
	88: reflect.TypeOf(LastTransaction{}),
	89: reflect.TypeOf(AnswerLastTransaction{}),
	90: reflect.TypeOf(NotifyReady{}),
}
