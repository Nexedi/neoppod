// DO NOT EDIT - AUTOGENERATED (by protogen.go)

package neo

import (
	"encoding/binary"
	"reflect"
	"sort"

	"../zodb"
)

// packets marshalling

// 0. Address

func (p *Address) NEOEncodedInfo() (uint16, int) {
	return 0, 6 + len(p.Host)
}

func (p *Address) NEOEncode(data []byte) {
	{
		l := uint32(len(p.Host))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Port)
}

func (p *Address) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 2+l {
			goto overflow
		}
		nread += 2 + l
		p.Host = string(data[:l])
		data = data[l:]
	}
	p.Port = binary.BigEndian.Uint16(data[0:])
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 1. NodeInfo

func (p *NodeInfo) NEOEncodedInfo() (uint16, int) {
	return 1, 26 + len(p.Address.Host)
}

func (p *NodeInfo) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
	{
		l := uint32(len(p.Address.Host))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Address.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Address.Port)
	binary.BigEndian.PutUint32(data[2:], uint32(int32(p.NodeID)))
	binary.BigEndian.PutUint32(data[6:], uint32(int32(p.NodeState)))
	float64_NEOEncode(data[10:], p.IdTimestamp)
}

func (p *NodeInfo) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < 18+l {
			goto overflow
		}
		nread += 18 + l
		p.Address.Host = string(data[:l])
		data = data[l:]
	}
	p.Address.Port = binary.BigEndian.Uint16(data[0:])
	p.NodeID = NodeID(int32(binary.BigEndian.Uint32(data[2:])))
	p.NodeState = NodeState(int32(binary.BigEndian.Uint32(data[6:])))
	p.IdTimestamp = float64_NEODecode(data[10:])
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 2. CellInfo

func (p *CellInfo) NEOEncodedInfo() (uint16, int) {
	return 2, 8
}

func (p *CellInfo) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeID)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.CellState)))
}

func (p *CellInfo) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.NodeID = NodeID(int32(binary.BigEndian.Uint32(data[0:])))
	p.CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 3. RowInfo

func (p *RowInfo) NEOEncodedInfo() (uint16, int) {
	return 3, 8 + len(p.CellList)*8
}

func (p *RowInfo) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Offset)
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeID)))
			binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
			data = data[8:]
		}
	}
}

func (p *RowInfo) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Offset = binary.BigEndian.Uint32(data[0:])
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.CellList = make([]CellInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a).NodeID = NodeID(int32(binary.BigEndian.Uint32(data[0:])))
			(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
			data = data[8:]
		}
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 4. Notify

func (p *Notify) NEOEncodedInfo() (uint16, int) {
	return 4, 4 + len(p.Message)
}

func (p *Notify) NEOEncode(data []byte) {
	{
		l := uint32(len(p.Message))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Message)
		data = data[l:]
	}
}

func (p *Notify) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l {
			goto overflow
		}
		nread += l
		p.Message = string(data[:l])
		data = data[l:]
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 5. Error

func (p *Error) NEOEncodedInfo() (uint16, int) {
	return 5, 8 + len(p.Message)
}

func (p *Error) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(p.Code))
	{
		l := uint32(len(p.Message))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Message)
		data = data[l:]
	}
}

func (p *Error) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Code = ErrorCode(binary.BigEndian.Uint32(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < l {
			goto overflow
		}
		nread += l
		p.Message = string(data[:l])
		data = data[l:]
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 6. Ping

func (p *Ping) NEOEncodedInfo() (uint16, int) {
	return 6, 0
}

func (p *Ping) NEOEncode(data []byte) {
}

func (p *Ping) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 7. CloseClient

func (p *CloseClient) NEOEncodedInfo() (uint16, int) {
	return 7, 0
}

func (p *CloseClient) NEOEncode(data []byte) {
}

func (p *CloseClient) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 8. RequestIdentification

func (p *RequestIdentification) NEOEncodedInfo() (uint16, int) {
	return 8, 30 + len(p.Address.Host) + len(p.Name)
}

func (p *RequestIdentification) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.ProtocolVersion)
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.NodeType)))
	binary.BigEndian.PutUint32(data[8:], uint32(int32(p.NodeID)))
	{
		l := uint32(len(p.Address.Host))
		binary.BigEndian.PutUint32(data[12:], l)
		data = data[16:]
		copy(data, p.Address.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Address.Port)
	{
		l := uint32(len(p.Name))
		binary.BigEndian.PutUint32(data[2:], l)
		data = data[6:]
		copy(data, p.Name)
		data = data[l:]
	}
	float64_NEOEncode(data[0:], p.IdTimestamp)
}

func (p *RequestIdentification) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.ProtocolVersion = binary.BigEndian.Uint32(data[0:])
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[4:])))
	p.NodeID = NodeID(int32(binary.BigEndian.Uint32(data[8:])))
	{
		l := binary.BigEndian.Uint32(data[12:])
		data = data[16:]
		if uint32(len(data)) < 6+l {
			goto overflow
		}
		nread += 6 + l
		p.Address.Host = string(data[:l])
		data = data[l:]
	}
	p.Address.Port = binary.BigEndian.Uint16(data[0:])
	{
		l := binary.BigEndian.Uint32(data[2:])
		data = data[6:]
		if uint32(len(data)) < 8+l {
			goto overflow
		}
		nread += 8 + l
		p.Name = string(data[:l])
		data = data[l:]
	}
	p.IdTimestamp = float64_NEODecode(data[0:])
	return 16 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 9. AcceptIdentification

func (p *AcceptIdentification) NEOEncodedInfo() (uint16, int) {
	var size int
	for i := 0; i < len(p.KnownMasterList); i++ {
		a := &p.KnownMasterList[i]
		size += len((*a).Address.Host)
	}
	return 9, 30 + len(p.Primary.Host) + len(p.KnownMasterList)*10 + size
}

func (p *AcceptIdentification) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.MyNodeID)))
	binary.BigEndian.PutUint32(data[8:], p.NumPartitions)
	binary.BigEndian.PutUint32(data[12:], p.NumReplicas)
	binary.BigEndian.PutUint32(data[16:], uint32(int32(p.YourNodeID)))
	{
		l := uint32(len(p.Primary.Host))
		binary.BigEndian.PutUint32(data[20:], l)
		data = data[24:]
		copy(data, p.Primary.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Primary.Port)
	{
		l := uint32(len(p.KnownMasterList))
		binary.BigEndian.PutUint32(data[2:], l)
		data = data[6:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.KnownMasterList[i]
			{
				l := uint32(len((*a).Address.Host))
				binary.BigEndian.PutUint32(data[0:], l)
				data = data[4:]
				copy(data, (*a).Address.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Address.Port)
			binary.BigEndian.PutUint32(data[2:], uint32(int32((*a).NodeID)))
			data = data[6:]
		}
	}
}

func (p *AcceptIdentification) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	p.MyNodeID = NodeID(int32(binary.BigEndian.Uint32(data[4:])))
	p.NumPartitions = binary.BigEndian.Uint32(data[8:])
	p.NumReplicas = binary.BigEndian.Uint32(data[12:])
	p.YourNodeID = NodeID(int32(binary.BigEndian.Uint32(data[16:])))
	{
		l := binary.BigEndian.Uint32(data[20:])
		data = data[24:]
		if uint32(len(data)) < 6+l {
			goto overflow
		}
		nread += 6 + l
		p.Primary.Host = string(data[:l])
		data = data[l:]
	}
	p.Primary.Port = binary.BigEndian.Uint16(data[0:])
	{
		l := binary.BigEndian.Uint32(data[2:])
		data = data[6:]
		p.KnownMasterList = make([]struct {
			Address
			NodeID NodeID
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.KnownMasterList[i]
			if uint32(len(data)) < 4 {
				goto overflow
			}
			{
				l := binary.BigEndian.Uint32(data[0:])
				data = data[4:]
				if uint32(len(data)) < 6+l {
					goto overflow
				}
				nread += 6 + l
				(*a).Address.Host = string(data[:l])
				data = data[l:]
			}
			(*a).Address.Port = binary.BigEndian.Uint16(data[0:])
			(*a).NodeID = NodeID(int32(binary.BigEndian.Uint32(data[2:])))
			data = data[6:]
		}
		nread += l * 4
	}
	return 24 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 10. PrimaryMaster

func (p *PrimaryMaster) NEOEncodedInfo() (uint16, int) {
	return 10, 0
}

func (p *PrimaryMaster) NEOEncode(data []byte) {
}

func (p *PrimaryMaster) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 11. AnswerPrimary

func (p *AnswerPrimary) NEOEncodedInfo() (uint16, int) {
	return 11, 4
}

func (p *AnswerPrimary) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.PrimaryNodeID)))
}

func (p *AnswerPrimary) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.PrimaryNodeID = NodeID(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 12. AnnouncePrimary

func (p *AnnouncePrimary) NEOEncodedInfo() (uint16, int) {
	return 12, 0
}

func (p *AnnouncePrimary) NEOEncode(data []byte) {
}

func (p *AnnouncePrimary) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 13. ReelectPrimary

func (p *ReelectPrimary) NEOEncodedInfo() (uint16, int) {
	return 13, 0
}

func (p *ReelectPrimary) NEOEncode(data []byte) {
}

func (p *ReelectPrimary) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 14. Recovery

func (p *Recovery) NEOEncodedInfo() (uint16, int) {
	return 14, 0
}

func (p *Recovery) NEOEncode(data []byte) {
}

func (p *Recovery) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 15. AnswerRecovery

func (p *AnswerRecovery) NEOEncodedInfo() (uint16, int) {
	return 15, 24
}

func (p *AnswerRecovery) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.BackupTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.TruncateTID))
}

func (p *AnswerRecovery) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	p.BackupTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.TruncateTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 16. LastIDs

func (p *LastIDs) NEOEncodedInfo() (uint16, int) {
	return 16, 0
}

func (p *LastIDs) NEOEncode(data []byte) {
}

func (p *LastIDs) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 17. AnswerLastIDs

func (p *AnswerLastIDs) NEOEncodedInfo() (uint16, int) {
	return 17, 16
}

func (p *AnswerLastIDs) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.LastOID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LastTID))
}

func (p *AnswerLastIDs) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.LastOID = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.LastTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 18. X_PartitionTable

func (p *X_PartitionTable) NEOEncodedInfo() (uint16, int) {
	return 18, 0
}

func (p *X_PartitionTable) NEOEncode(data []byte) {
}

func (p *X_PartitionTable) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 19. AnswerPartitionTable

func (p *AnswerPartitionTable) NEOEncodedInfo() (uint16, int) {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 19, 12 + len(p.RowList)*8 + size
}

func (p *AnswerPartitionTable) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerPartitionTable) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < l*8 {
					goto overflow
				}
				nread += l * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).NodeID = NodeID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 20. NotifyPartitionTable

func (p *NotifyPartitionTable) NEOEncodedInfo() (uint16, int) {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 20, 12 + len(p.RowList)*8 + size
}

func (p *NotifyPartitionTable) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *NotifyPartitionTable) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < l*8 {
					goto overflow
				}
				nread += l * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).NodeID = NodeID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 21. PartitionChanges

func (p *PartitionChanges) NEOEncodedInfo() (uint16, int) {
	return 21, 12 + len(p.CellList)*12
}

func (p *PartitionChanges) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).NodeID)))
			binary.BigEndian.PutUint32(data[8:], uint32(int32((*a).CellState)))
			data = data[12:]
		}
	}
}

func (p *PartitionChanges) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*12 {
			goto overflow
		}
		nread += l * 12
		p.CellList = make([]struct {
			Offset    uint32
			NodeID    NodeID
			CellState CellState
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			(*a).NodeID = NodeID(int32(binary.BigEndian.Uint32(data[4:])))
			(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[8:])))
			data = data[12:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 22. StartOperation

func (p *StartOperation) NEOEncodedInfo() (uint16, int) {
	return 22, 1
}

func (p *StartOperation) NEOEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Backup)
}

func (p *StartOperation) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.Backup = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 23. StopOperation

func (p *StopOperation) NEOEncodedInfo() (uint16, int) {
	return 23, 0
}

func (p *StopOperation) NEOEncode(data []byte) {
}

func (p *StopOperation) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 24. UnfinishedTransactions

func (p *UnfinishedTransactions) NEOEncodedInfo() (uint16, int) {
	return 24, 4 + len(p.RowList)*4
}

func (p *UnfinishedTransactions) NEOEncode(data []byte) {
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			data = data[4:]
		}
	}
}

func (p *UnfinishedTransactions) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.RowList = make([]struct{ Offset uint32 }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 25. AnswerUnfinishedTransactions

func (p *AnswerUnfinishedTransactions) NEOEncodedInfo() (uint16, int) {
	return 25, 12 + len(p.TidList)*8
}

func (p *AnswerUnfinishedTransactions) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.MaxTID))
	{
		l := uint32(len(p.TidList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a).UnfinishedTID))
			data = data[8:]
		}
	}
}

func (p *AnswerUnfinishedTransactions) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.TidList = make([]struct{ UnfinishedTID zodb.Tid }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			(*a).UnfinishedTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 26. LockedTransactions

func (p *LockedTransactions) NEOEncodedInfo() (uint16, int) {
	return 26, 0
}

func (p *LockedTransactions) NEOEncode(data []byte) {
}

func (p *LockedTransactions) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 27. AnswerLockedTransactions

func (p *AnswerLockedTransactions) NEOEncodedInfo() (uint16, int) {
	return 27, 4 + len(p.TidDict)*16
}

func (p *AnswerLockedTransactions) NEOEncode(data []byte) {
	{
		l := uint32(len(p.TidDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]zodb.Tid, 0, l)
		for key := range p.TidDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			binary.BigEndian.PutUint64(data[8:], uint64(p.TidDict[key]))
			data = data[16:]
		}
	}
}

func (p *AnswerLockedTransactions) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*16 {
			goto overflow
		}
		nread += l * 16
		p.TidDict = make(map[zodb.Tid]zodb.Tid, l)
		m := p.TidDict
		for i := 0; uint32(i) < l; i++ {
			key := zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			m[key] = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
			data = data[16:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 28. FinalTID

func (p *FinalTID) NEOEncodedInfo() (uint16, int) {
	return 28, 8
}

func (p *FinalTID) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
}

func (p *FinalTID) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 29. AnswerFinalTID

func (p *AnswerFinalTID) NEOEncodedInfo() (uint16, int) {
	return 29, 8
}

func (p *AnswerFinalTID) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerFinalTID) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 30. ValidateTransaction

func (p *ValidateTransaction) NEOEncodedInfo() (uint16, int) {
	return 30, 16
}

func (p *ValidateTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *ValidateTransaction) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 31. BeginTransaction

func (p *BeginTransaction) NEOEncodedInfo() (uint16, int) {
	return 31, 8
}

func (p *BeginTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *BeginTransaction) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 32. AnswerBeginTransaction

func (p *AnswerBeginTransaction) NEOEncodedInfo() (uint16, int) {
	return 32, 8
}

func (p *AnswerBeginTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerBeginTransaction) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 33. FailedVote

func (p *FailedVote) NEOEncodedInfo() (uint16, int) {
	return 33, 12 + len(p.NodeList)*4
}

func (p *FailedVote) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *FailedVote) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 34. FinishTransaction

func (p *FinishTransaction) NEOEncodedInfo() (uint16, int) {
	return 34, 16 + len(p.OIDList)*8 + len(p.CheckedList)*8
}

func (p *FinishTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.OIDList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OIDList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
	{
		l := uint32(len(p.CheckedList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CheckedList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *FinishTransaction) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 4+l*8 {
			goto overflow
		}
		nread += 4 + l*8
		p.OIDList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OIDList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.CheckedList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CheckedList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 35. AnswerFinishTransaction

func (p *AnswerFinishTransaction) NEOEncodedInfo() (uint16, int) {
	return 35, 16
}

func (p *AnswerFinishTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *AnswerFinishTransaction) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 36. NotifyTransactionFinished

func (p *NotifyTransactionFinished) NEOEncodedInfo() (uint16, int) {
	return 36, 16
}

func (p *NotifyTransactionFinished) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *NotifyTransactionFinished) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 37. LockInformation

func (p *LockInformation) NEOEncodedInfo() (uint16, int) {
	return 37, 16
}

func (p *LockInformation) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Ttid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *LockInformation) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.Ttid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 38. AnswerLockInformation

func (p *AnswerLockInformation) NEOEncodedInfo() (uint16, int) {
	return 38, 8
}

func (p *AnswerLockInformation) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Ttid))
}

func (p *AnswerLockInformation) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Ttid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 39. InvalidateObjects

func (p *InvalidateObjects) NEOEncodedInfo() (uint16, int) {
	return 39, 12 + len(p.OidList)*8
}

func (p *InvalidateObjects) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *InvalidateObjects) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 40. UnlockInformation

func (p *UnlockInformation) NEOEncodedInfo() (uint16, int) {
	return 40, 8
}

func (p *UnlockInformation) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
}

func (p *UnlockInformation) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 41. GenerateOIDs

func (p *GenerateOIDs) NEOEncodedInfo() (uint16, int) {
	return 41, 4
}

func (p *GenerateOIDs) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.NumOIDs)
}

func (p *GenerateOIDs) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.NumOIDs = binary.BigEndian.Uint32(data[0:])
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 42. AnswerGenerateOIDs

func (p *AnswerGenerateOIDs) NEOEncodedInfo() (uint16, int) {
	return 42, 4 + len(p.OidList)*8
}

func (p *AnswerGenerateOIDs) NEOEncode(data []byte) {
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerGenerateOIDs) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 43. Deadlock

func (p *Deadlock) NEOEncodedInfo() (uint16, int) {
	return 43, 16
}

func (p *Deadlock) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LockingTid))
}

func (p *Deadlock) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LockingTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 44. RebaseTransaction

func (p *RebaseTransaction) NEOEncodedInfo() (uint16, int) {
	return 44, 16
}

func (p *RebaseTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LockingTid))
}

func (p *RebaseTransaction) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LockingTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 45. AnswerRebaseTransaction

func (p *AnswerRebaseTransaction) NEOEncodedInfo() (uint16, int) {
	return 45, 4 + len(p.OidList)*8
}

func (p *AnswerRebaseTransaction) NEOEncode(data []byte) {
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerRebaseTransaction) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 46. RebaseObject

func (p *RebaseObject) NEOEncodedInfo() (uint16, int) {
	return 46, 16
}

func (p *RebaseObject) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Oid))
}

func (p *RebaseObject) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 47. AnswerRebaseObject

func (p *AnswerRebaseObject) NEOEncodedInfo() (uint16, int) {
	return 47, 41 + len(p.Data)
}

func (p *AnswerRebaseObject) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[8:], uint64(p.ConflictSerial))
	(data[16:])[0] = bool2byte(p.Compression)
	copy(data[17:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		copy(data, p.Data)
		data = data[l:]
	}
}

func (p *AnswerRebaseObject) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 41 {
		goto overflow
	}
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.ConflictSerial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Compression = byte2bool((data[16:])[0])
	copy(p.Checksum[:], data[17:37])
	{
		l := binary.BigEndian.Uint32(data[37:])
		data = data[41:]
		if uint32(len(data)) < l {
			goto overflow
		}
		nread += l
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	return 41 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 48. StoreObject

func (p *StoreObject) NEOEncodedInfo() (uint16, int) {
	return 48, 57 + len(p.Data)
}

func (p *StoreObject) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	(data[16:])[0] = bool2byte(p.Compression)
	copy(data[17:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		copy(data, p.Data)
		data = data[l:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *StoreObject) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 41 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Compression = byte2bool((data[16:])[0])
	copy(p.Checksum[:], data[17:37])
	{
		l := binary.BigEndian.Uint32(data[37:])
		data = data[41:]
		if uint32(len(data)) < 16+l {
			goto overflow
		}
		nread += 16 + l
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	p.DataSerial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 41 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 49. AnswerStoreObject

func (p *AnswerStoreObject) NEOEncodedInfo() (uint16, int) {
	return 49, 8
}

func (p *AnswerStoreObject) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Conflict))
}

func (p *AnswerStoreObject) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Conflict = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 50. AbortTransaction

func (p *AbortTransaction) NEOEncodedInfo() (uint16, int) {
	return 50, 12 + len(p.NodeList)*4
}

func (p *AbortTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *AbortTransaction) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 51. StoreTransaction

func (p *StoreTransaction) NEOEncodedInfo() (uint16, int) {
	return 51, 24 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *StoreTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *StoreTransaction) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.User = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Description = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Extension = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 52. VoteTransaction

func (p *VoteTransaction) NEOEncodedInfo() (uint16, int) {
	return 52, 8
}

func (p *VoteTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *VoteTransaction) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 53. GetObject

func (p *GetObject) NEOEncodedInfo() (uint16, int) {
	return 53, 24
}

func (p *GetObject) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[16:], uint64(p.Tid))
}

func (p *GetObject) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 54. AnswerGetObject

func (p *AnswerGetObject) NEOEncodedInfo() (uint16, int) {
	return 54, 57 + len(p.Data)
}

func (p *AnswerGetObject) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[16:], uint64(p.NextSerial))
	(data[24:])[0] = bool2byte(p.Compression)
	copy(data[25:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[45:], l)
		data = data[49:]
		copy(data, p.Data)
		data = data[l:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
}

func (p *AnswerGetObject) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 49 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.NextSerial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	p.Compression = byte2bool((data[24:])[0])
	copy(p.Checksum[:], data[25:45])
	{
		l := binary.BigEndian.Uint32(data[45:])
		data = data[49:]
		if uint32(len(data)) < 8+l {
			goto overflow
		}
		nread += 8 + l
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	p.DataSerial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 49 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 55. TIDList

func (p *TIDList) NEOEncodedInfo() (uint16, int) {
	return 55, 20
}

func (p *TIDList) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], p.First)
	binary.BigEndian.PutUint64(data[8:], p.Last)
	binary.BigEndian.PutUint32(data[16:], p.Partition)
}

func (p *TIDList) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 20 {
		goto overflow
	}
	p.First = binary.BigEndian.Uint64(data[0:])
	p.Last = binary.BigEndian.Uint64(data[8:])
	p.Partition = binary.BigEndian.Uint32(data[16:])
	return 20, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 56. AnswerTIDList

func (p *AnswerTIDList) NEOEncodedInfo() (uint16, int) {
	return 56, 4 + len(p.TIDList)*8
}

func (p *AnswerTIDList) NEOEncode(data []byte) {
	{
		l := uint32(len(p.TIDList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TIDList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTIDList) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.TIDList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TIDList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 57. TIDListFrom

func (p *TIDListFrom) NEOEncodedInfo() (uint16, int) {
	return 57, 24
}

func (p *TIDListFrom) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
	binary.BigEndian.PutUint32(data[16:], p.Length)
	binary.BigEndian.PutUint32(data[20:], p.Partition)
}

func (p *TIDListFrom) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Length = binary.BigEndian.Uint32(data[16:])
	p.Partition = binary.BigEndian.Uint32(data[20:])
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 58. AnswerTIDListFrom

func (p *AnswerTIDListFrom) NEOEncodedInfo() (uint16, int) {
	return 58, 4 + len(p.TidList)*8
}

func (p *AnswerTIDListFrom) NEOEncode(data []byte) {
	{
		l := uint32(len(p.TidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTIDListFrom) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.TidList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 59. TransactionInformation

func (p *TransactionInformation) NEOEncodedInfo() (uint16, int) {
	return 59, 8
}

func (p *TransactionInformation) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *TransactionInformation) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 60. AnswerTransactionInformation

func (p *AnswerTransactionInformation) NEOEncodedInfo() (uint16, int) {
	return 60, 25 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *AnswerTransactionInformation) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	(data[0:])[0] = bool2byte(p.Packed)
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[1:], l)
		data = data[5:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTransactionInformation) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.User = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Description = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 5+l {
			goto overflow
		}
		nread += 5 + l
		p.Extension = string(data[:l])
		data = data[l:]
	}
	p.Packed = byte2bool((data[0:])[0])
	{
		l := binary.BigEndian.Uint32(data[1:])
		data = data[5:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 61. ObjectHistory

func (p *ObjectHistory) NEOEncodedInfo() (uint16, int) {
	return 61, 24
}

func (p *ObjectHistory) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], p.First)
	binary.BigEndian.PutUint64(data[16:], p.Last)
}

func (p *ObjectHistory) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.First = binary.BigEndian.Uint64(data[8:])
	p.Last = binary.BigEndian.Uint64(data[16:])
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 62. AnswerObjectHistory

func (p *AnswerObjectHistory) NEOEncodedInfo() (uint16, int) {
	return 62, 12 + len(p.HistoryList)*12
}

func (p *AnswerObjectHistory) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	{
		l := uint32(len(p.HistoryList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.HistoryList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a).Serial))
			binary.BigEndian.PutUint32(data[8:], (*a).Size)
			data = data[12:]
		}
	}
}

func (p *AnswerObjectHistory) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*12 {
			goto overflow
		}
		nread += l * 12
		p.HistoryList = make([]struct {
			Serial zodb.Tid
			Size   uint32
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.HistoryList[i]
			(*a).Serial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			(*a).Size = binary.BigEndian.Uint32(data[8:])
			data = data[12:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 63. PartitionList

func (p *PartitionList) NEOEncodedInfo() (uint16, int) {
	return 63, 12
}

func (p *PartitionList) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.MinOffset)
	binary.BigEndian.PutUint32(data[4:], p.MaxOffset)
	binary.BigEndian.PutUint32(data[8:], uint32(int32(p.NodeID)))
}

func (p *PartitionList) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.MinOffset = binary.BigEndian.Uint32(data[0:])
	p.MaxOffset = binary.BigEndian.Uint32(data[4:])
	p.NodeID = NodeID(int32(binary.BigEndian.Uint32(data[8:])))
	return 12, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 64. AnswerPartitionList

func (p *AnswerPartitionList) NEOEncodedInfo() (uint16, int) {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 64, 12 + len(p.RowList)*8 + size
}

func (p *AnswerPartitionList) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerPartitionList) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < l*8 {
					goto overflow
				}
				nread += l * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).NodeID = NodeID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 65. NodeList

func (p *NodeList) NEOEncodedInfo() (uint16, int) {
	return 65, 4
}

func (p *NodeList) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
}

func (p *NodeList) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 66. AnswerNodeList

func (p *AnswerNodeList) NEOEncodedInfo() (uint16, int) {
	var size int
	for i := 0; i < len(p.NodeList); i++ {
		a := &p.NodeList[i]
		size += len((*a).Address.Host)
	}
	return 66, 4 + len(p.NodeList)*26 + size
}

func (p *AnswerNodeList) NEOEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeType)))
			{
				l := uint32(len((*a).Address.Host))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				copy(data, (*a).Address.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Address.Port)
			binary.BigEndian.PutUint32(data[2:], uint32(int32((*a).NodeID)))
			binary.BigEndian.PutUint32(data[6:], uint32(int32((*a).NodeState)))
			float64_NEOEncode(data[10:], (*a).IdTimestamp)
			data = data[18:]
		}
	}
}

func (p *AnswerNodeList) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		p.NodeList = make([]NodeInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < 18+l {
					goto overflow
				}
				nread += 18 + l
				(*a).Address.Host = string(data[:l])
				data = data[l:]
			}
			(*a).Address.Port = binary.BigEndian.Uint16(data[0:])
			(*a).NodeID = NodeID(int32(binary.BigEndian.Uint32(data[2:])))
			(*a).NodeState = NodeState(int32(binary.BigEndian.Uint32(data[6:])))
			(*a).IdTimestamp = float64_NEODecode(data[10:])
			data = data[18:]
		}
		nread += l * 8
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 67. SetNodeState

func (p *SetNodeState) NEOEncodedInfo() (uint16, int) {
	return 67, 8
}

func (p *SetNodeState) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeID)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.NodeState)))
}

func (p *SetNodeState) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.NodeID = NodeID(int32(binary.BigEndian.Uint32(data[0:])))
	p.NodeState = NodeState(int32(binary.BigEndian.Uint32(data[4:])))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 68. AddPendingNodes

func (p *AddPendingNodes) NEOEncodedInfo() (uint16, int) {
	return 68, 4 + len(p.NodeList)*4
}

func (p *AddPendingNodes) NEOEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *AddPendingNodes) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 69. TweakPartitionTable

func (p *TweakPartitionTable) NEOEncodedInfo() (uint16, int) {
	return 69, 4 + len(p.NodeList)*4
}

func (p *TweakPartitionTable) NEOEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *TweakPartitionTable) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 70. NotifyNodeInformation

func (p *NotifyNodeInformation) NEOEncodedInfo() (uint16, int) {
	var size int
	for i := 0; i < len(p.NodeList); i++ {
		a := &p.NodeList[i]
		size += len((*a).Address.Host)
	}
	return 70, 12 + len(p.NodeList)*26 + size
}

func (p *NotifyNodeInformation) NEOEncode(data []byte) {
	float64_NEOEncode(data[0:], p.IdTimestamp)
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeType)))
			{
				l := uint32(len((*a).Address.Host))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				copy(data, (*a).Address.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Address.Port)
			binary.BigEndian.PutUint32(data[2:], uint32(int32((*a).NodeID)))
			binary.BigEndian.PutUint32(data[6:], uint32(int32((*a).NodeState)))
			float64_NEOEncode(data[10:], (*a).IdTimestamp)
			data = data[18:]
		}
	}
}

func (p *NotifyNodeInformation) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.IdTimestamp = float64_NEODecode(data[0:])
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.NodeList = make([]NodeInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < 18+l {
					goto overflow
				}
				nread += 18 + l
				(*a).Address.Host = string(data[:l])
				data = data[l:]
			}
			(*a).Address.Port = binary.BigEndian.Uint16(data[0:])
			(*a).NodeID = NodeID(int32(binary.BigEndian.Uint32(data[2:])))
			(*a).NodeState = NodeState(int32(binary.BigEndian.Uint32(data[6:])))
			(*a).IdTimestamp = float64_NEODecode(data[10:])
			data = data[18:]
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 71. NodeInformation

func (p *NodeInformation) NEOEncodedInfo() (uint16, int) {
	return 71, 0
}

func (p *NodeInformation) NEOEncode(data []byte) {
}

func (p *NodeInformation) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 72. SetClusterState

func (p *SetClusterState) NEOEncodedInfo() (uint16, int) {
	return 72, 4
}

func (p *SetClusterState) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *SetClusterState) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 73. repairFlags

func (p *repairFlags) NEOEncodedInfo() (uint16, int) {
	return 73, 1
}

func (p *repairFlags) NEOEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.DryRun)
}

func (p *repairFlags) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.DryRun = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 74. Repair

func (p *Repair) NEOEncodedInfo() (uint16, int) {
	return 74, 5 + len(p.NodeList)*4
}

func (p *Repair) NEOEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
	(data[0:])[0] = bool2byte(p.repairFlags.DryRun)
}

func (p *Repair) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 1+l*4 {
			goto overflow
		}
		nread += 1 + l*4
		p.NodeList = make([]NodeID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	p.repairFlags.DryRun = byte2bool((data[0:])[0])
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 75. RepairOne

func (p *RepairOne) NEOEncodedInfo() (uint16, int) {
	return 75, 1
}

func (p *RepairOne) NEOEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.repairFlags.DryRun)
}

func (p *RepairOne) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.repairFlags.DryRun = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 76. ClusterInformation

func (p *ClusterInformation) NEOEncodedInfo() (uint16, int) {
	return 76, 4
}

func (p *ClusterInformation) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *ClusterInformation) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 77. X_ClusterState

func (p *X_ClusterState) NEOEncodedInfo() (uint16, int) {
	return 77, 4
}

func (p *X_ClusterState) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *X_ClusterState) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 78. ObjectUndoSerial

func (p *ObjectUndoSerial) NEOEncodedInfo() (uint16, int) {
	return 78, 28 + len(p.OidList)*8
}

func (p *ObjectUndoSerial) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.UndoneTID))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[24:], l)
		data = data[28:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *ObjectUndoSerial) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 28 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.UndoneTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	{
		l := binary.BigEndian.Uint32(data[24:])
		data = data[28:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 28 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 79. AnswerObjectUndoSerial

func (p *AnswerObjectUndoSerial) NEOEncodedInfo() (uint16, int) {
	return 79, 4 + len(p.ObjectTIDDict)*25
}

func (p *AnswerObjectUndoSerial) NEOEncode(data []byte) {
	{
		l := uint32(len(p.ObjectTIDDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]zodb.Oid, 0, l)
		for key := range p.ObjectTIDDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			binary.BigEndian.PutUint64(data[8:], uint64(p.ObjectTIDDict[key].CurrentSerial))
			binary.BigEndian.PutUint64(data[16:], uint64(p.ObjectTIDDict[key].UndoSerial))
			(data[24:])[0] = bool2byte(p.ObjectTIDDict[key].IsCurrent)
			data = data[25:]
		}
	}
}

func (p *AnswerObjectUndoSerial) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*25 {
			goto overflow
		}
		nread += l * 25
		p.ObjectTIDDict = make(map[zodb.Oid]struct {
			CurrentSerial zodb.Tid
			UndoSerial    zodb.Tid
			IsCurrent     bool
		}, l)
		m := p.ObjectTIDDict
		for i := 0; uint32(i) < l; i++ {
			key := zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			var v struct {
				CurrentSerial zodb.Tid
				UndoSerial    zodb.Tid
				IsCurrent     bool
			}
			v.CurrentSerial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
			v.UndoSerial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
			v.IsCurrent = byte2bool((data[24:])[0])
			m[key] = v
			data = data[25:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 80. CheckCurrentSerial

func (p *CheckCurrentSerial) NEOEncodedInfo() (uint16, int) {
	return 80, 24
}

func (p *CheckCurrentSerial) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.Serial))
}

func (p *CheckCurrentSerial) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[8:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 81. Pack

func (p *Pack) NEOEncodedInfo() (uint16, int) {
	return 81, 8
}

func (p *Pack) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *Pack) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 82. AnswerPack

func (p *AnswerPack) NEOEncodedInfo() (uint16, int) {
	return 82, 1
}

func (p *AnswerPack) NEOEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Status)
}

func (p *AnswerPack) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.Status = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 83. CheckReplicas

func (p *CheckReplicas) NEOEncodedInfo() (uint16, int) {
	return 83, 20 + len(p.PartitionDict)*8
}

func (p *CheckReplicas) NEOEncode(data []byte) {
	{
		l := uint32(len(p.PartitionDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]uint32, 0, l)
		for key := range p.PartitionDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint32(data[0:], key)
			binary.BigEndian.PutUint32(data[4:], uint32(int32(p.PartitionDict[key])))
			data = data[8:]
		}
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *CheckReplicas) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 16+l*8 {
			goto overflow
		}
		nread += 16 + l*8
		p.PartitionDict = make(map[uint32]NodeID, l)
		m := p.PartitionDict
		for i := 0; uint32(i) < l; i++ {
			key := binary.BigEndian.Uint32(data[0:])
			m[key] = NodeID(int32(binary.BigEndian.Uint32(data[4:])))
			data = data[8:]
		}
	}
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 84. CheckPartition

func (p *CheckPartition) NEOEncodedInfo() (uint16, int) {
	return 84, 30 + len(p.Source.UpstreamName) + len(p.Source.Address.Host)
}

func (p *CheckPartition) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	{
		l := uint32(len(p.Source.UpstreamName))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Source.UpstreamName)
		data = data[l:]
	}
	{
		l := uint32(len(p.Source.Address.Host))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Source.Address.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Source.Address.Port)
	binary.BigEndian.PutUint64(data[2:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[10:], uint64(p.MaxTID))
}

func (p *CheckPartition) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Source.UpstreamName = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 18+l {
			goto overflow
		}
		nread += 18 + l
		p.Source.Address.Host = string(data[:l])
		data = data[l:]
	}
	p.Source.Address.Port = binary.BigEndian.Uint16(data[0:])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[2:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[10:]))
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 85. CheckTIDRange

func (p *CheckTIDRange) NEOEncodedInfo() (uint16, int) {
	return 85, 24
}

func (p *CheckTIDRange) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTID))
}

func (p *CheckTIDRange) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	p.Length = binary.BigEndian.Uint32(data[4:])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 86. AnswerCheckTIDRange

func (p *AnswerCheckTIDRange) NEOEncodedInfo() (uint16, int) {
	return 86, 32
}

func (p *AnswerCheckTIDRange) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Count)
	copy(data[4:], p.Checksum[:])
	binary.BigEndian.PutUint64(data[24:], uint64(p.MaxTID))
}

func (p *AnswerCheckTIDRange) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 32 {
		goto overflow
	}
	p.Count = binary.BigEndian.Uint32(data[0:])
	copy(p.Checksum[:], data[4:24])
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[24:]))
	return 32, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 87. CheckSerialRange

func (p *CheckSerialRange) NEOEncodedInfo() (uint16, int) {
	return 87, 32
}

func (p *CheckSerialRange) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTID))
	binary.BigEndian.PutUint64(data[24:], uint64(p.MinOID))
}

func (p *CheckSerialRange) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 32 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	p.Length = binary.BigEndian.Uint32(data[4:])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	p.MinOID = zodb.Oid(binary.BigEndian.Uint64(data[24:]))
	return 32, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 88. AnswerCheckSerialRange

func (p *AnswerCheckSerialRange) NEOEncodedInfo() (uint16, int) {
	return 88, 60
}

func (p *AnswerCheckSerialRange) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Count)
	copy(data[4:], p.TidChecksum[:])
	binary.BigEndian.PutUint64(data[24:], uint64(p.MaxTID))
	copy(data[32:], p.OidChecksum[:])
	binary.BigEndian.PutUint64(data[52:], uint64(p.MaxOID))
}

func (p *AnswerCheckSerialRange) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 60 {
		goto overflow
	}
	p.Count = binary.BigEndian.Uint32(data[0:])
	copy(p.TidChecksum[:], data[4:24])
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[24:]))
	copy(p.OidChecksum[:], data[32:52])
	p.MaxOID = zodb.Oid(binary.BigEndian.Uint64(data[52:]))
	return 60, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 89. PartitionCorrupted

func (p *PartitionCorrupted) NEOEncodedInfo() (uint16, int) {
	return 89, 8 + len(p.CellList)*4
}

func (p *PartitionCorrupted) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *PartitionCorrupted) NEODecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.CellList = make([]NodeID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a) = NodeID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 90. LastTransaction

func (p *LastTransaction) NEOEncodedInfo() (uint16, int) {
	return 90, 0
}

func (p *LastTransaction) NEOEncode(data []byte) {
}

func (p *LastTransaction) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 91. AnswerLastTransaction

func (p *AnswerLastTransaction) NEOEncodedInfo() (uint16, int) {
	return 91, 8
}

func (p *AnswerLastTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerLastTransaction) NEODecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 92. NotifyReady

func (p *NotifyReady) NEOEncodedInfo() (uint16, int) {
	return 92, 0
}

func (p *NotifyReady) NEOEncode(data []byte) {
}

func (p *NotifyReady) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// registry of packet types
var pktTypeRegistry = map[uint16]reflect.Type{
	0:  reflect.TypeOf(Address{}),
	1:  reflect.TypeOf(NodeInfo{}),
	2:  reflect.TypeOf(CellInfo{}),
	3:  reflect.TypeOf(RowInfo{}),
	4:  reflect.TypeOf(Notify{}),
	5:  reflect.TypeOf(Error{}),
	6:  reflect.TypeOf(Ping{}),
	7:  reflect.TypeOf(CloseClient{}),
	8:  reflect.TypeOf(RequestIdentification{}),
	9:  reflect.TypeOf(AcceptIdentification{}),
	10: reflect.TypeOf(PrimaryMaster{}),
	11: reflect.TypeOf(AnswerPrimary{}),
	12: reflect.TypeOf(AnnouncePrimary{}),
	13: reflect.TypeOf(ReelectPrimary{}),
	14: reflect.TypeOf(Recovery{}),
	15: reflect.TypeOf(AnswerRecovery{}),
	16: reflect.TypeOf(LastIDs{}),
	17: reflect.TypeOf(AnswerLastIDs{}),
	18: reflect.TypeOf(X_PartitionTable{}),
	19: reflect.TypeOf(AnswerPartitionTable{}),
	20: reflect.TypeOf(NotifyPartitionTable{}),
	21: reflect.TypeOf(PartitionChanges{}),
	22: reflect.TypeOf(StartOperation{}),
	23: reflect.TypeOf(StopOperation{}),
	24: reflect.TypeOf(UnfinishedTransactions{}),
	25: reflect.TypeOf(AnswerUnfinishedTransactions{}),
	26: reflect.TypeOf(LockedTransactions{}),
	27: reflect.TypeOf(AnswerLockedTransactions{}),
	28: reflect.TypeOf(FinalTID{}),
	29: reflect.TypeOf(AnswerFinalTID{}),
	30: reflect.TypeOf(ValidateTransaction{}),
	31: reflect.TypeOf(BeginTransaction{}),
	32: reflect.TypeOf(AnswerBeginTransaction{}),
	33: reflect.TypeOf(FailedVote{}),
	34: reflect.TypeOf(FinishTransaction{}),
	35: reflect.TypeOf(AnswerFinishTransaction{}),
	36: reflect.TypeOf(NotifyTransactionFinished{}),
	37: reflect.TypeOf(LockInformation{}),
	38: reflect.TypeOf(AnswerLockInformation{}),
	39: reflect.TypeOf(InvalidateObjects{}),
	40: reflect.TypeOf(UnlockInformation{}),
	41: reflect.TypeOf(GenerateOIDs{}),
	42: reflect.TypeOf(AnswerGenerateOIDs{}),
	43: reflect.TypeOf(Deadlock{}),
	44: reflect.TypeOf(RebaseTransaction{}),
	45: reflect.TypeOf(AnswerRebaseTransaction{}),
	46: reflect.TypeOf(RebaseObject{}),
	47: reflect.TypeOf(AnswerRebaseObject{}),
	48: reflect.TypeOf(StoreObject{}),
	49: reflect.TypeOf(AnswerStoreObject{}),
	50: reflect.TypeOf(AbortTransaction{}),
	51: reflect.TypeOf(StoreTransaction{}),
	52: reflect.TypeOf(VoteTransaction{}),
	53: reflect.TypeOf(GetObject{}),
	54: reflect.TypeOf(AnswerGetObject{}),
	55: reflect.TypeOf(TIDList{}),
	56: reflect.TypeOf(AnswerTIDList{}),
	57: reflect.TypeOf(TIDListFrom{}),
	58: reflect.TypeOf(AnswerTIDListFrom{}),
	59: reflect.TypeOf(TransactionInformation{}),
	60: reflect.TypeOf(AnswerTransactionInformation{}),
	61: reflect.TypeOf(ObjectHistory{}),
	62: reflect.TypeOf(AnswerObjectHistory{}),
	63: reflect.TypeOf(PartitionList{}),
	64: reflect.TypeOf(AnswerPartitionList{}),
	65: reflect.TypeOf(NodeList{}),
	66: reflect.TypeOf(AnswerNodeList{}),
	67: reflect.TypeOf(SetNodeState{}),
	68: reflect.TypeOf(AddPendingNodes{}),
	69: reflect.TypeOf(TweakPartitionTable{}),
	70: reflect.TypeOf(NotifyNodeInformation{}),
	71: reflect.TypeOf(NodeInformation{}),
	72: reflect.TypeOf(SetClusterState{}),
	73: reflect.TypeOf(repairFlags{}),
	74: reflect.TypeOf(Repair{}),
	75: reflect.TypeOf(RepairOne{}),
	76: reflect.TypeOf(ClusterInformation{}),
	77: reflect.TypeOf(X_ClusterState{}),
	78: reflect.TypeOf(ObjectUndoSerial{}),
	79: reflect.TypeOf(AnswerObjectUndoSerial{}),
	80: reflect.TypeOf(CheckCurrentSerial{}),
	81: reflect.TypeOf(Pack{}),
	82: reflect.TypeOf(AnswerPack{}),
	83: reflect.TypeOf(CheckReplicas{}),
	84: reflect.TypeOf(CheckPartition{}),
	85: reflect.TypeOf(CheckTIDRange{}),
	86: reflect.TypeOf(AnswerCheckTIDRange{}),
	87: reflect.TypeOf(CheckSerialRange{}),
	88: reflect.TypeOf(AnswerCheckSerialRange{}),
	89: reflect.TypeOf(PartitionCorrupted{}),
	90: reflect.TypeOf(LastTransaction{}),
	91: reflect.TypeOf(AnswerLastTransaction{}),
	92: reflect.TypeOf(NotifyReady{}),
}
