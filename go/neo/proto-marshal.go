// DO NOT EDIT - AUTOGENERATED (by protogen.go)

package neo

import (
	"encoding/binary"
	"reflect"
	"sort"

	"lab.nexedi.com/kirr/neo/go/zodb"
)

// messages marshalling

// 0. Address

func (_ *Address) NEOMsgCode() uint16 {
	return 0
}

func (p *Address) NEOMsgEncodedLen() int {
	return 6 + len(p.Host)
}

func (p *Address) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.Host))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Port)
}

func (p *Address) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 2+l {
			goto overflow
		}
		nread += 2 + l
		p.Host = string(data[:l])
		data = data[l:]
	}
	p.Port = binary.BigEndian.Uint16(data[0:])
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 1. NodeInfo

func (_ *NodeInfo) NEOMsgCode() uint16 {
	return 1
}

func (p *NodeInfo) NEOMsgEncodedLen() int {
	return 26 + len(p.Address.Host)
}

func (p *NodeInfo) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
	{
		l := uint32(len(p.Address.Host))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Address.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Address.Port)
	binary.BigEndian.PutUint32(data[2:], uint32(int32(p.NodeUUID)))
	binary.BigEndian.PutUint32(data[6:], uint32(int32(p.NodeState)))
	float64_NEOEncode(data[10:], p.IdTimestamp)
}

func (p *NodeInfo) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < 18+l {
			goto overflow
		}
		nread += 18 + l
		p.Address.Host = string(data[:l])
		data = data[l:]
	}
	p.Address.Port = binary.BigEndian.Uint16(data[0:])
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[2:])))
	p.NodeState = NodeState(int32(binary.BigEndian.Uint32(data[6:])))
	p.IdTimestamp = float64_NEODecode(data[10:])
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 2. CellInfo

func (_ *CellInfo) NEOMsgCode() uint16 {
	return 2
}

func (p *CellInfo) NEOMsgEncodedLen() int {
	return 8
}

func (p *CellInfo) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeUUID)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.CellState)))
}

func (p *CellInfo) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
	p.CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 3. RowInfo

func (_ *RowInfo) NEOMsgCode() uint16 {
	return 3
}

func (p *RowInfo) NEOMsgEncodedLen() int {
	return 8 + len(p.CellList)*8
}

func (p *RowInfo) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Offset)
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeUUID)))
			binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
			data = data[8:]
		}
	}
}

func (p *RowInfo) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Offset = binary.BigEndian.Uint32(data[0:])
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.CellList = make([]CellInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a).NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
			data = data[8:]
		}
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 4. Error

func (_ *Error) NEOMsgCode() uint16 {
	return 4
}

func (p *Error) NEOMsgEncodedLen() int {
	return 8 + len(p.Message)
}

func (p *Error) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(p.Code))
	{
		l := uint32(len(p.Message))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Message)
		data = data[l:]
	}
}

func (p *Error) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Code = ErrorCode(binary.BigEndian.Uint32(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < l {
			goto overflow
		}
		nread += l
		p.Message = string(data[:l])
		data = data[l:]
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 5. Ping

func (_ *Ping) NEOMsgCode() uint16 {
	return 5
}

func (p *Ping) NEOMsgEncodedLen() int {
	return 0
}

func (p *Ping) NEOMsgEncode(data []byte) {
}

func (p *Ping) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 6. CloseClient

func (_ *CloseClient) NEOMsgCode() uint16 {
	return 6
}

func (p *CloseClient) NEOMsgEncodedLen() int {
	return 0
}

func (p *CloseClient) NEOMsgEncode(data []byte) {
}

func (p *CloseClient) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 7. RequestIdentification

func (_ *RequestIdentification) NEOMsgCode() uint16 {
	return 7
}

func (p *RequestIdentification) NEOMsgEncodedLen() int {
	return 26 + len(p.Address.Host) + len(p.ClusterName)
}

func (p *RequestIdentification) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.NodeUUID)))
	{
		l := uint32(len(p.Address.Host))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.Address.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Address.Port)
	{
		l := uint32(len(p.ClusterName))
		binary.BigEndian.PutUint32(data[2:], l)
		data = data[6:]
		copy(data, p.ClusterName)
		data = data[l:]
	}
	float64_NEOEncode(data[0:], p.IdTimestamp)
}

func (p *RequestIdentification) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 6+l {
			goto overflow
		}
		nread += 6 + l
		p.Address.Host = string(data[:l])
		data = data[l:]
	}
	p.Address.Port = binary.BigEndian.Uint16(data[0:])
	{
		l := binary.BigEndian.Uint32(data[2:])
		data = data[6:]
		if uint32(len(data)) < 8+l {
			goto overflow
		}
		nread += 8 + l
		p.ClusterName = string(data[:l])
		data = data[l:]
	}
	p.IdTimestamp = float64_NEODecode(data[0:])
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 8. AcceptIdentification

func (_ *AcceptIdentification) NEOMsgCode() uint16 {
	return 8
}

func (p *AcceptIdentification) NEOMsgEncodedLen() int {
	return 20
}

func (p *AcceptIdentification) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.MyNodeUUID)))
	binary.BigEndian.PutUint32(data[8:], p.NumPartitions)
	binary.BigEndian.PutUint32(data[12:], p.NumReplicas)
	binary.BigEndian.PutUint32(data[16:], uint32(int32(p.YourNodeUUID)))
}

func (p *AcceptIdentification) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 20 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	p.MyNodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
	p.NumPartitions = binary.BigEndian.Uint32(data[8:])
	p.NumReplicas = binary.BigEndian.Uint32(data[12:])
	p.YourNodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[16:])))
	return 20, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 9. PrimaryMaster

func (_ *PrimaryMaster) NEOMsgCode() uint16 {
	return 9
}

func (p *PrimaryMaster) NEOMsgEncodedLen() int {
	return 0
}

func (p *PrimaryMaster) NEOMsgEncode(data []byte) {
}

func (p *PrimaryMaster) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 10. AnswerPrimary

func (_ *AnswerPrimary) NEOMsgCode() uint16 {
	return 10
}

func (p *AnswerPrimary) NEOMsgEncodedLen() int {
	return 4
}

func (p *AnswerPrimary) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.PrimaryNodeUUID)))
}

func (p *AnswerPrimary) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.PrimaryNodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 11. NotPrimaryMaster

func (_ *NotPrimaryMaster) NEOMsgCode() uint16 {
	return 11
}

func (p *NotPrimaryMaster) NEOMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.KnownMasterList); i++ {
		a := &p.KnownMasterList[i]
		size += len((*a).Address.Host)
	}
	return 8 + len(p.KnownMasterList)*6 + size
}

func (p *NotPrimaryMaster) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.Primary)))
	{
		l := uint32(len(p.KnownMasterList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.KnownMasterList[i]
			{
				l := uint32(len((*a).Address.Host))
				binary.BigEndian.PutUint32(data[0:], l)
				data = data[4:]
				copy(data, (*a).Address.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Address.Port)
			data = data[2:]
		}
	}
}

func (p *NotPrimaryMaster) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Primary = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		p.KnownMasterList = make([]struct{ Address }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.KnownMasterList[i]
			if uint32(len(data)) < 4 {
				goto overflow
			}
			{
				l := binary.BigEndian.Uint32(data[0:])
				data = data[4:]
				if uint32(len(data)) < 2+l {
					goto overflow
				}
				nread += 2 + l
				(*a).Address.Host = string(data[:l])
				data = data[l:]
			}
			(*a).Address.Port = binary.BigEndian.Uint16(data[0:])
			data = data[2:]
		}
		nread += l * 4
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 12. Recovery

func (_ *Recovery) NEOMsgCode() uint16 {
	return 12
}

func (p *Recovery) NEOMsgEncodedLen() int {
	return 0
}

func (p *Recovery) NEOMsgEncode(data []byte) {
}

func (p *Recovery) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 13. AnswerRecovery

func (_ *AnswerRecovery) NEOMsgCode() uint16 {
	return 13
}

func (p *AnswerRecovery) NEOMsgEncodedLen() int {
	return 24
}

func (p *AnswerRecovery) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.BackupTid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.TruncateTid))
}

func (p *AnswerRecovery) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	p.BackupTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.TruncateTid = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 14. LastIDs

func (_ *LastIDs) NEOMsgCode() uint16 {
	return 14
}

func (p *LastIDs) NEOMsgEncodedLen() int {
	return 0
}

func (p *LastIDs) NEOMsgEncode(data []byte) {
}

func (p *LastIDs) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 15. AnswerLastIDs

func (_ *AnswerLastIDs) NEOMsgCode() uint16 {
	return 15
}

func (p *AnswerLastIDs) NEOMsgEncodedLen() int {
	return 16
}

func (p *AnswerLastIDs) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.LastOid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LastTid))
}

func (p *AnswerLastIDs) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.LastOid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.LastTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 16. AskPartitionTable

func (_ *AskPartitionTable) NEOMsgCode() uint16 {
	return 16
}

func (p *AskPartitionTable) NEOMsgEncodedLen() int {
	return 0
}

func (p *AskPartitionTable) NEOMsgEncode(data []byte) {
}

func (p *AskPartitionTable) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 17. AnswerPartitionTable

func (_ *AnswerPartitionTable) NEOMsgCode() uint16 {
	return 17
}

func (p *AnswerPartitionTable) NEOMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 12 + len(p.RowList)*8 + size
}

func (p *AnswerPartitionTable) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeUUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerPartitionTable) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < l*8 {
					goto overflow
				}
				nread += l * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 18. NotifyPartitionTable

func (_ *NotifyPartitionTable) NEOMsgCode() uint16 {
	return 18
}

func (p *NotifyPartitionTable) NEOMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 12 + len(p.RowList)*8 + size
}

func (p *NotifyPartitionTable) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeUUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *NotifyPartitionTable) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < l*8 {
					goto overflow
				}
				nread += l * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 19. NotifyPartitionChanges

func (_ *NotifyPartitionChanges) NEOMsgCode() uint16 {
	return 19
}

func (p *NotifyPartitionChanges) NEOMsgEncodedLen() int {
	return 12 + len(p.CellList)*12
}

func (p *NotifyPartitionChanges) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellInfo.NodeUUID)))
			binary.BigEndian.PutUint32(data[8:], uint32(int32((*a).CellInfo.CellState)))
			data = data[12:]
		}
	}
}

func (p *NotifyPartitionChanges) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*12 {
			goto overflow
		}
		nread += l * 12
		p.CellList = make([]struct {
			Offset   uint32
			CellInfo CellInfo
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			(*a).CellInfo.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
			(*a).CellInfo.CellState = CellState(int32(binary.BigEndian.Uint32(data[8:])))
			data = data[12:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 20. StartOperation

func (_ *StartOperation) NEOMsgCode() uint16 {
	return 20
}

func (p *StartOperation) NEOMsgEncodedLen() int {
	return 1
}

func (p *StartOperation) NEOMsgEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Backup)
}

func (p *StartOperation) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.Backup = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 21. StopOperation

func (_ *StopOperation) NEOMsgCode() uint16 {
	return 21
}

func (p *StopOperation) NEOMsgEncodedLen() int {
	return 0
}

func (p *StopOperation) NEOMsgEncode(data []byte) {
}

func (p *StopOperation) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 22. UnfinishedTransactions

func (_ *UnfinishedTransactions) NEOMsgCode() uint16 {
	return 22
}

func (p *UnfinishedTransactions) NEOMsgEncodedLen() int {
	return 4 + len(p.RowList)*4
}

func (p *UnfinishedTransactions) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			data = data[4:]
		}
	}
}

func (p *UnfinishedTransactions) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.RowList = make([]struct{ Offset uint32 }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 23. AnswerUnfinishedTransactions

func (_ *AnswerUnfinishedTransactions) NEOMsgCode() uint16 {
	return 23
}

func (p *AnswerUnfinishedTransactions) NEOMsgEncodedLen() int {
	return 12 + len(p.TidList)*8
}

func (p *AnswerUnfinishedTransactions) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.MaxTID))
	{
		l := uint32(len(p.TidList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a).UnfinishedTID))
			data = data[8:]
		}
	}
}

func (p *AnswerUnfinishedTransactions) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.TidList = make([]struct{ UnfinishedTID zodb.Tid }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			(*a).UnfinishedTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 24. LockedTransactions

func (_ *LockedTransactions) NEOMsgCode() uint16 {
	return 24
}

func (p *LockedTransactions) NEOMsgEncodedLen() int {
	return 0
}

func (p *LockedTransactions) NEOMsgEncode(data []byte) {
}

func (p *LockedTransactions) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 25. AnswerLockedTransactions

func (_ *AnswerLockedTransactions) NEOMsgCode() uint16 {
	return 25
}

func (p *AnswerLockedTransactions) NEOMsgEncodedLen() int {
	return 4 + len(p.TidDict)*16
}

func (p *AnswerLockedTransactions) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.TidDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]zodb.Tid, 0, l)
		for key := range p.TidDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			binary.BigEndian.PutUint64(data[8:], uint64(p.TidDict[key]))
			data = data[16:]
		}
	}
}

func (p *AnswerLockedTransactions) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*16 {
			goto overflow
		}
		nread += l * 16
		p.TidDict = make(map[zodb.Tid]zodb.Tid, l)
		m := p.TidDict
		for i := 0; uint32(i) < l; i++ {
			key := zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			m[key] = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
			data = data[16:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 26. FinalTID

func (_ *FinalTID) NEOMsgCode() uint16 {
	return 26
}

func (p *FinalTID) NEOMsgEncodedLen() int {
	return 8
}

func (p *FinalTID) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
}

func (p *FinalTID) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 27. AnswerFinalTID

func (_ *AnswerFinalTID) NEOMsgCode() uint16 {
	return 27
}

func (p *AnswerFinalTID) NEOMsgEncodedLen() int {
	return 8
}

func (p *AnswerFinalTID) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerFinalTID) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 28. ValidateTransaction

func (_ *ValidateTransaction) NEOMsgCode() uint16 {
	return 28
}

func (p *ValidateTransaction) NEOMsgEncodedLen() int {
	return 16
}

func (p *ValidateTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *ValidateTransaction) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 29. BeginTransaction

func (_ *BeginTransaction) NEOMsgCode() uint16 {
	return 29
}

func (p *BeginTransaction) NEOMsgEncodedLen() int {
	return 8
}

func (p *BeginTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *BeginTransaction) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 30. AnswerBeginTransaction

func (_ *AnswerBeginTransaction) NEOMsgCode() uint16 {
	return 30
}

func (p *AnswerBeginTransaction) NEOMsgEncodedLen() int {
	return 8
}

func (p *AnswerBeginTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerBeginTransaction) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 31. FailedVote

func (_ *FailedVote) NEOMsgCode() uint16 {
	return 31
}

func (p *FailedVote) NEOMsgEncodedLen() int {
	return 12 + len(p.NodeList)*4
}

func (p *FailedVote) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *FailedVote) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 32. FinishTransaction

func (_ *FinishTransaction) NEOMsgCode() uint16 {
	return 32
}

func (p *FinishTransaction) NEOMsgEncodedLen() int {
	return 16 + len(p.OIDList)*8 + len(p.CheckedList)*8
}

func (p *FinishTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.OIDList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OIDList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
	{
		l := uint32(len(p.CheckedList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CheckedList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *FinishTransaction) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 4+l*8 {
			goto overflow
		}
		nread += 4 + l*8
		p.OIDList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OIDList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.CheckedList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CheckedList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 33. AnswerFinishTransaction

func (_ *AnswerFinishTransaction) NEOMsgCode() uint16 {
	return 33
}

func (p *AnswerFinishTransaction) NEOMsgEncodedLen() int {
	return 16
}

func (p *AnswerFinishTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *AnswerFinishTransaction) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 34. NotifyTransactionFinished

func (_ *NotifyTransactionFinished) NEOMsgCode() uint16 {
	return 34
}

func (p *NotifyTransactionFinished) NEOMsgEncodedLen() int {
	return 16
}

func (p *NotifyTransactionFinished) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *NotifyTransactionFinished) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 35. LockInformation

func (_ *LockInformation) NEOMsgCode() uint16 {
	return 35
}

func (p *LockInformation) NEOMsgEncodedLen() int {
	return 16
}

func (p *LockInformation) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Ttid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *LockInformation) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.Ttid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 36. AnswerLockInformation

func (_ *AnswerLockInformation) NEOMsgCode() uint16 {
	return 36
}

func (p *AnswerLockInformation) NEOMsgEncodedLen() int {
	return 8
}

func (p *AnswerLockInformation) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Ttid))
}

func (p *AnswerLockInformation) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Ttid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 37. InvalidateObjects

func (_ *InvalidateObjects) NEOMsgCode() uint16 {
	return 37
}

func (p *InvalidateObjects) NEOMsgEncodedLen() int {
	return 12 + len(p.OidList)*8
}

func (p *InvalidateObjects) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *InvalidateObjects) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 38. UnlockInformation

func (_ *UnlockInformation) NEOMsgCode() uint16 {
	return 38
}

func (p *UnlockInformation) NEOMsgEncodedLen() int {
	return 8
}

func (p *UnlockInformation) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
}

func (p *UnlockInformation) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 39. GenerateOIDs

func (_ *GenerateOIDs) NEOMsgCode() uint16 {
	return 39
}

func (p *GenerateOIDs) NEOMsgEncodedLen() int {
	return 4
}

func (p *GenerateOIDs) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.NumOIDs)
}

func (p *GenerateOIDs) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.NumOIDs = binary.BigEndian.Uint32(data[0:])
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 40. AnswerGenerateOIDs

func (_ *AnswerGenerateOIDs) NEOMsgCode() uint16 {
	return 40
}

func (p *AnswerGenerateOIDs) NEOMsgEncodedLen() int {
	return 4 + len(p.OidList)*8
}

func (p *AnswerGenerateOIDs) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerGenerateOIDs) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 41. Deadlock

func (_ *Deadlock) NEOMsgCode() uint16 {
	return 41
}

func (p *Deadlock) NEOMsgEncodedLen() int {
	return 16
}

func (p *Deadlock) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LockingTid))
}

func (p *Deadlock) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LockingTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 42. RebaseTransaction

func (_ *RebaseTransaction) NEOMsgCode() uint16 {
	return 42
}

func (p *RebaseTransaction) NEOMsgEncodedLen() int {
	return 16
}

func (p *RebaseTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LockingTid))
}

func (p *RebaseTransaction) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LockingTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 43. AnswerRebaseTransaction

func (_ *AnswerRebaseTransaction) NEOMsgCode() uint16 {
	return 43
}

func (p *AnswerRebaseTransaction) NEOMsgEncodedLen() int {
	return 4 + len(p.OidList)*8
}

func (p *AnswerRebaseTransaction) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerRebaseTransaction) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 44. RebaseObject

func (_ *RebaseObject) NEOMsgCode() uint16 {
	return 44
}

func (p *RebaseObject) NEOMsgEncodedLen() int {
	return 16
}

func (p *RebaseObject) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Oid))
}

func (p *RebaseObject) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 45. AnswerRebaseObject

func (_ *AnswerRebaseObject) NEOMsgCode() uint16 {
	return 45
}

func (p *AnswerRebaseObject) NEOMsgEncodedLen() int {
	return 41 + len(p.Data)
}

func (p *AnswerRebaseObject) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[8:], uint64(p.ConflictSerial))
	(data[16:])[0] = bool2byte(p.Compression)
	copy(data[17:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		copy(data, p.Data)
		data = data[l:]
	}
}

func (p *AnswerRebaseObject) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 41 {
		goto overflow
	}
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.ConflictSerial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Compression = byte2bool((data[16:])[0])
	copy(p.Checksum[:], data[17:37])
	{
		l := binary.BigEndian.Uint32(data[37:])
		data = data[41:]
		if uint32(len(data)) < l {
			goto overflow
		}
		nread += l
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	return 41 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 46. StoreObject

func (_ *StoreObject) NEOMsgCode() uint16 {
	return 46
}

func (p *StoreObject) NEOMsgEncodedLen() int {
	return 57 + len(p.Data)
}

func (p *StoreObject) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	(data[16:])[0] = bool2byte(p.Compression)
	copy(data[17:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		copy(data, p.Data)
		data = data[l:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *StoreObject) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 41 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Compression = byte2bool((data[16:])[0])
	copy(p.Checksum[:], data[17:37])
	{
		l := binary.BigEndian.Uint32(data[37:])
		data = data[41:]
		if uint32(len(data)) < 16+l {
			goto overflow
		}
		nread += 16 + l
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	p.DataSerial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 41 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 47. AnswerStoreObject

func (_ *AnswerStoreObject) NEOMsgCode() uint16 {
	return 47
}

func (p *AnswerStoreObject) NEOMsgEncodedLen() int {
	return 8
}

func (p *AnswerStoreObject) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Conflict))
}

func (p *AnswerStoreObject) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Conflict = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 48. AbortTransaction

func (_ *AbortTransaction) NEOMsgCode() uint16 {
	return 48
}

func (p *AbortTransaction) NEOMsgEncodedLen() int {
	return 12 + len(p.NodeList)*4
}

func (p *AbortTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *AbortTransaction) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 49. StoreTransaction

func (_ *StoreTransaction) NEOMsgCode() uint16 {
	return 49
}

func (p *StoreTransaction) NEOMsgEncodedLen() int {
	return 24 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *StoreTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *StoreTransaction) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.User = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Description = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Extension = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 50. VoteTransaction

func (_ *VoteTransaction) NEOMsgCode() uint16 {
	return 50
}

func (p *VoteTransaction) NEOMsgEncodedLen() int {
	return 8
}

func (p *VoteTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *VoteTransaction) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 51. GetObject

func (_ *GetObject) NEOMsgCode() uint16 {
	return 51
}

func (p *GetObject) NEOMsgEncodedLen() int {
	return 24
}

func (p *GetObject) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[16:], uint64(p.Tid))
}

func (p *GetObject) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 52. AnswerGetObject

func (_ *AnswerGetObject) NEOMsgCode() uint16 {
	return 52
}

func (p *AnswerGetObject) NEOMsgEncodedLen() int {
	return 57 + len(p.Data)
}

func (p *AnswerGetObject) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[16:], uint64(p.NextSerial))
	(data[24:])[0] = bool2byte(p.Compression)
	copy(data[25:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[45:], l)
		data = data[49:]
		copy(data, p.Data)
		data = data[l:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
}

func (p *AnswerGetObject) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 49 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.NextSerial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	p.Compression = byte2bool((data[24:])[0])
	copy(p.Checksum[:], data[25:45])
	{
		l := binary.BigEndian.Uint32(data[45:])
		data = data[49:]
		if uint32(len(data)) < 8+l {
			goto overflow
		}
		nread += 8 + l
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	p.DataSerial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 49 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 53. TIDList

func (_ *TIDList) NEOMsgCode() uint16 {
	return 53
}

func (p *TIDList) NEOMsgEncodedLen() int {
	return 20
}

func (p *TIDList) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], p.First)
	binary.BigEndian.PutUint64(data[8:], p.Last)
	binary.BigEndian.PutUint32(data[16:], p.Partition)
}

func (p *TIDList) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 20 {
		goto overflow
	}
	p.First = binary.BigEndian.Uint64(data[0:])
	p.Last = binary.BigEndian.Uint64(data[8:])
	p.Partition = binary.BigEndian.Uint32(data[16:])
	return 20, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 54. AnswerTIDList

func (_ *AnswerTIDList) NEOMsgCode() uint16 {
	return 54
}

func (p *AnswerTIDList) NEOMsgEncodedLen() int {
	return 4 + len(p.TIDList)*8
}

func (p *AnswerTIDList) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.TIDList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TIDList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTIDList) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.TIDList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TIDList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 55. TIDListFrom

func (_ *TIDListFrom) NEOMsgCode() uint16 {
	return 55
}

func (p *TIDListFrom) NEOMsgEncodedLen() int {
	return 24
}

func (p *TIDListFrom) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
	binary.BigEndian.PutUint32(data[16:], p.Length)
	binary.BigEndian.PutUint32(data[20:], p.Partition)
}

func (p *TIDListFrom) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Length = binary.BigEndian.Uint32(data[16:])
	p.Partition = binary.BigEndian.Uint32(data[20:])
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 56. AnswerTIDListFrom

func (_ *AnswerTIDListFrom) NEOMsgCode() uint16 {
	return 56
}

func (p *AnswerTIDListFrom) NEOMsgEncodedLen() int {
	return 4 + len(p.TidList)*8
}

func (p *AnswerTIDListFrom) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.TidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTIDListFrom) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.TidList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 57. TransactionInformation

func (_ *TransactionInformation) NEOMsgCode() uint16 {
	return 57
}

func (p *TransactionInformation) NEOMsgEncodedLen() int {
	return 8
}

func (p *TransactionInformation) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *TransactionInformation) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 58. AnswerTransactionInformation

func (_ *AnswerTransactionInformation) NEOMsgCode() uint16 {
	return 58
}

func (p *AnswerTransactionInformation) NEOMsgEncodedLen() int {
	return 25 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *AnswerTransactionInformation) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	(data[0:])[0] = bool2byte(p.Packed)
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[1:], l)
		data = data[5:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTransactionInformation) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.User = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Description = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 5+l {
			goto overflow
		}
		nread += 5 + l
		p.Extension = string(data[:l])
		data = data[l:]
	}
	p.Packed = byte2bool((data[0:])[0])
	{
		l := binary.BigEndian.Uint32(data[1:])
		data = data[5:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 59. ObjectHistory

func (_ *ObjectHistory) NEOMsgCode() uint16 {
	return 59
}

func (p *ObjectHistory) NEOMsgEncodedLen() int {
	return 24
}

func (p *ObjectHistory) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], p.First)
	binary.BigEndian.PutUint64(data[16:], p.Last)
}

func (p *ObjectHistory) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.First = binary.BigEndian.Uint64(data[8:])
	p.Last = binary.BigEndian.Uint64(data[16:])
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 60. AnswerObjectHistory

func (_ *AnswerObjectHistory) NEOMsgCode() uint16 {
	return 60
}

func (p *AnswerObjectHistory) NEOMsgEncodedLen() int {
	return 12 + len(p.HistoryList)*12
}

func (p *AnswerObjectHistory) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	{
		l := uint32(len(p.HistoryList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.HistoryList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a).Serial))
			binary.BigEndian.PutUint32(data[8:], (*a).Size)
			data = data[12:]
		}
	}
}

func (p *AnswerObjectHistory) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*12 {
			goto overflow
		}
		nread += l * 12
		p.HistoryList = make([]struct {
			Serial zodb.Tid
			Size   uint32
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.HistoryList[i]
			(*a).Serial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			(*a).Size = binary.BigEndian.Uint32(data[8:])
			data = data[12:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 61. PartitionList

func (_ *PartitionList) NEOMsgCode() uint16 {
	return 61
}

func (p *PartitionList) NEOMsgEncodedLen() int {
	return 12
}

func (p *PartitionList) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.MinOffset)
	binary.BigEndian.PutUint32(data[4:], p.MaxOffset)
	binary.BigEndian.PutUint32(data[8:], uint32(int32(p.NodeUUID)))
}

func (p *PartitionList) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.MinOffset = binary.BigEndian.Uint32(data[0:])
	p.MaxOffset = binary.BigEndian.Uint32(data[4:])
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[8:])))
	return 12, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 62. AnswerPartitionList

func (_ *AnswerPartitionList) NEOMsgCode() uint16 {
	return 62
}

func (p *AnswerPartitionList) NEOMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 12 + len(p.RowList)*8 + size
}

func (p *AnswerPartitionList) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeUUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerPartitionList) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < l*8 {
					goto overflow
				}
				nread += l * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 63. NodeList

func (_ *NodeList) NEOMsgCode() uint16 {
	return 63
}

func (p *NodeList) NEOMsgEncodedLen() int {
	return 4
}

func (p *NodeList) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
}

func (p *NodeList) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 64. AnswerNodeList

func (_ *AnswerNodeList) NEOMsgCode() uint16 {
	return 64
}

func (p *AnswerNodeList) NEOMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.NodeList); i++ {
		a := &p.NodeList[i]
		size += len((*a).Address.Host)
	}
	return 4 + len(p.NodeList)*26 + size
}

func (p *AnswerNodeList) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeType)))
			{
				l := uint32(len((*a).Address.Host))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				copy(data, (*a).Address.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Address.Port)
			binary.BigEndian.PutUint32(data[2:], uint32(int32((*a).NodeUUID)))
			binary.BigEndian.PutUint32(data[6:], uint32(int32((*a).NodeState)))
			float64_NEOEncode(data[10:], (*a).IdTimestamp)
			data = data[18:]
		}
	}
}

func (p *AnswerNodeList) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		p.NodeList = make([]NodeInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < 18+l {
					goto overflow
				}
				nread += 18 + l
				(*a).Address.Host = string(data[:l])
				data = data[l:]
			}
			(*a).Address.Port = binary.BigEndian.Uint16(data[0:])
			(*a).NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[2:])))
			(*a).NodeState = NodeState(int32(binary.BigEndian.Uint32(data[6:])))
			(*a).IdTimestamp = float64_NEODecode(data[10:])
			data = data[18:]
		}
		nread += l * 8
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 65. SetNodeState

func (_ *SetNodeState) NEOMsgCode() uint16 {
	return 65
}

func (p *SetNodeState) NEOMsgEncodedLen() int {
	return 8
}

func (p *SetNodeState) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeUUID)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.NodeState)))
}

func (p *SetNodeState) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
	p.NodeState = NodeState(int32(binary.BigEndian.Uint32(data[4:])))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 66. AddPendingNodes

func (_ *AddPendingNodes) NEOMsgCode() uint16 {
	return 66
}

func (p *AddPendingNodes) NEOMsgEncodedLen() int {
	return 4 + len(p.NodeList)*4
}

func (p *AddPendingNodes) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *AddPendingNodes) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 67. TweakPartitionTable

func (_ *TweakPartitionTable) NEOMsgCode() uint16 {
	return 67
}

func (p *TweakPartitionTable) NEOMsgEncodedLen() int {
	return 4 + len(p.NodeList)*4
}

func (p *TweakPartitionTable) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *TweakPartitionTable) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 68. NotifyNodeInformation

func (_ *NotifyNodeInformation) NEOMsgCode() uint16 {
	return 68
}

func (p *NotifyNodeInformation) NEOMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.NodeList); i++ {
		a := &p.NodeList[i]
		size += len((*a).Address.Host)
	}
	return 12 + len(p.NodeList)*26 + size
}

func (p *NotifyNodeInformation) NEOMsgEncode(data []byte) {
	float64_NEOEncode(data[0:], p.IdTimestamp)
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeType)))
			{
				l := uint32(len((*a).Address.Host))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				copy(data, (*a).Address.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Address.Port)
			binary.BigEndian.PutUint32(data[2:], uint32(int32((*a).NodeUUID)))
			binary.BigEndian.PutUint32(data[6:], uint32(int32((*a).NodeState)))
			float64_NEOEncode(data[10:], (*a).IdTimestamp)
			data = data[18:]
		}
	}
}

func (p *NotifyNodeInformation) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.IdTimestamp = float64_NEODecode(data[0:])
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.NodeList = make([]NodeInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < 18+l {
					goto overflow
				}
				nread += 18 + l
				(*a).Address.Host = string(data[:l])
				data = data[l:]
			}
			(*a).Address.Port = binary.BigEndian.Uint16(data[0:])
			(*a).NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[2:])))
			(*a).NodeState = NodeState(int32(binary.BigEndian.Uint32(data[6:])))
			(*a).IdTimestamp = float64_NEODecode(data[10:])
			data = data[18:]
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 69. NodeInformation

func (_ *NodeInformation) NEOMsgCode() uint16 {
	return 69
}

func (p *NodeInformation) NEOMsgEncodedLen() int {
	return 0
}

func (p *NodeInformation) NEOMsgEncode(data []byte) {
}

func (p *NodeInformation) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 70. SetClusterState

func (_ *SetClusterState) NEOMsgCode() uint16 {
	return 70
}

func (p *SetClusterState) NEOMsgEncodedLen() int {
	return 4
}

func (p *SetClusterState) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *SetClusterState) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 71. repairFlags

func (_ *repairFlags) NEOMsgCode() uint16 {
	return 71
}

func (p *repairFlags) NEOMsgEncodedLen() int {
	return 1
}

func (p *repairFlags) NEOMsgEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.DryRun)
}

func (p *repairFlags) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.DryRun = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 72. Repair

func (_ *Repair) NEOMsgCode() uint16 {
	return 72
}

func (p *Repair) NEOMsgEncodedLen() int {
	return 5 + len(p.NodeList)*4
}

func (p *Repair) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
	(data[0:])[0] = bool2byte(p.repairFlags.DryRun)
}

func (p *Repair) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 1+l*4 {
			goto overflow
		}
		nread += 1 + l*4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	p.repairFlags.DryRun = byte2bool((data[0:])[0])
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 73. RepairOne

func (_ *RepairOne) NEOMsgCode() uint16 {
	return 73
}

func (p *RepairOne) NEOMsgEncodedLen() int {
	return 1
}

func (p *RepairOne) NEOMsgEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.repairFlags.DryRun)
}

func (p *RepairOne) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.repairFlags.DryRun = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 74. NotifyClusterState

func (_ *NotifyClusterState) NEOMsgCode() uint16 {
	return 74
}

func (p *NotifyClusterState) NEOMsgEncodedLen() int {
	return 4
}

func (p *NotifyClusterState) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *NotifyClusterState) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 75. AskClusterState

func (_ *AskClusterState) NEOMsgCode() uint16 {
	return 75
}

func (p *AskClusterState) NEOMsgEncodedLen() int {
	return 0
}

func (p *AskClusterState) NEOMsgEncode(data []byte) {
}

func (p *AskClusterState) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 76. AnswerClusterState

func (_ *AnswerClusterState) NEOMsgCode() uint16 {
	return 76
}

func (p *AnswerClusterState) NEOMsgEncodedLen() int {
	return 4
}

func (p *AnswerClusterState) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *AnswerClusterState) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 77. ObjectUndoSerial

func (_ *ObjectUndoSerial) NEOMsgCode() uint16 {
	return 77
}

func (p *ObjectUndoSerial) NEOMsgEncodedLen() int {
	return 28 + len(p.OidList)*8
}

func (p *ObjectUndoSerial) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.UndoneTID))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[24:], l)
		data = data[28:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *ObjectUndoSerial) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 28 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.UndoneTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	{
		l := binary.BigEndian.Uint32(data[24:])
		data = data[28:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 28 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 78. AnswerObjectUndoSerial

func (_ *AnswerObjectUndoSerial) NEOMsgCode() uint16 {
	return 78
}

func (p *AnswerObjectUndoSerial) NEOMsgEncodedLen() int {
	return 4 + len(p.ObjectTIDDict)*25
}

func (p *AnswerObjectUndoSerial) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.ObjectTIDDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]zodb.Oid, 0, l)
		for key := range p.ObjectTIDDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			binary.BigEndian.PutUint64(data[8:], uint64(p.ObjectTIDDict[key].CurrentSerial))
			binary.BigEndian.PutUint64(data[16:], uint64(p.ObjectTIDDict[key].UndoSerial))
			(data[24:])[0] = bool2byte(p.ObjectTIDDict[key].IsCurrent)
			data = data[25:]
		}
	}
}

func (p *AnswerObjectUndoSerial) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*25 {
			goto overflow
		}
		nread += l * 25
		p.ObjectTIDDict = make(map[zodb.Oid]struct {
			CurrentSerial zodb.Tid
			UndoSerial    zodb.Tid
			IsCurrent     bool
		}, l)
		m := p.ObjectTIDDict
		for i := 0; uint32(i) < l; i++ {
			key := zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			var v struct {
				CurrentSerial zodb.Tid
				UndoSerial    zodb.Tid
				IsCurrent     bool
			}
			v.CurrentSerial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
			v.UndoSerial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
			v.IsCurrent = byte2bool((data[24:])[0])
			m[key] = v
			data = data[25:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 79. CheckCurrentSerial

func (_ *CheckCurrentSerial) NEOMsgCode() uint16 {
	return 79
}

func (p *CheckCurrentSerial) NEOMsgEncodedLen() int {
	return 24
}

func (p *CheckCurrentSerial) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.Serial))
}

func (p *CheckCurrentSerial) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[8:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 80. Pack

func (_ *Pack) NEOMsgCode() uint16 {
	return 80
}

func (p *Pack) NEOMsgEncodedLen() int {
	return 8
}

func (p *Pack) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *Pack) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 81. AnswerPack

func (_ *AnswerPack) NEOMsgCode() uint16 {
	return 81
}

func (p *AnswerPack) NEOMsgEncodedLen() int {
	return 1
}

func (p *AnswerPack) NEOMsgEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Status)
}

func (p *AnswerPack) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.Status = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 82. CheckReplicas

func (_ *CheckReplicas) NEOMsgCode() uint16 {
	return 82
}

func (p *CheckReplicas) NEOMsgEncodedLen() int {
	return 20 + len(p.PartitionDict)*8
}

func (p *CheckReplicas) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.PartitionDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]uint32, 0, l)
		for key := range p.PartitionDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint32(data[0:], key)
			binary.BigEndian.PutUint32(data[4:], uint32(int32(p.PartitionDict[key])))
			data = data[8:]
		}
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *CheckReplicas) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 16+l*8 {
			goto overflow
		}
		nread += 16 + l*8
		p.PartitionDict = make(map[uint32]NodeUUID, l)
		m := p.PartitionDict
		for i := 0; uint32(i) < l; i++ {
			key := binary.BigEndian.Uint32(data[0:])
			m[key] = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
			data = data[8:]
		}
	}
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 83. CheckPartition

func (_ *CheckPartition) NEOMsgCode() uint16 {
	return 83
}

func (p *CheckPartition) NEOMsgEncodedLen() int {
	return 30 + len(p.Source.UpstreamName) + len(p.Source.Address.Host)
}

func (p *CheckPartition) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	{
		l := uint32(len(p.Source.UpstreamName))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Source.UpstreamName)
		data = data[l:]
	}
	{
		l := uint32(len(p.Source.Address.Host))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Source.Address.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Source.Address.Port)
	binary.BigEndian.PutUint64(data[2:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[10:], uint64(p.MaxTID))
}

func (p *CheckPartition) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Source.UpstreamName = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 18+l {
			goto overflow
		}
		nread += 18 + l
		p.Source.Address.Host = string(data[:l])
		data = data[l:]
	}
	p.Source.Address.Port = binary.BigEndian.Uint16(data[0:])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[2:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[10:]))
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 84. CheckTIDRange

func (_ *CheckTIDRange) NEOMsgCode() uint16 {
	return 84
}

func (p *CheckTIDRange) NEOMsgEncodedLen() int {
	return 24
}

func (p *CheckTIDRange) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTID))
}

func (p *CheckTIDRange) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	p.Length = binary.BigEndian.Uint32(data[4:])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 85. AnswerCheckTIDRange

func (_ *AnswerCheckTIDRange) NEOMsgCode() uint16 {
	return 85
}

func (p *AnswerCheckTIDRange) NEOMsgEncodedLen() int {
	return 32
}

func (p *AnswerCheckTIDRange) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Count)
	copy(data[4:], p.Checksum[:])
	binary.BigEndian.PutUint64(data[24:], uint64(p.MaxTID))
}

func (p *AnswerCheckTIDRange) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 32 {
		goto overflow
	}
	p.Count = binary.BigEndian.Uint32(data[0:])
	copy(p.Checksum[:], data[4:24])
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[24:]))
	return 32, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 86. CheckSerialRange

func (_ *CheckSerialRange) NEOMsgCode() uint16 {
	return 86
}

func (p *CheckSerialRange) NEOMsgEncodedLen() int {
	return 32
}

func (p *CheckSerialRange) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTID))
	binary.BigEndian.PutUint64(data[24:], uint64(p.MinOID))
}

func (p *CheckSerialRange) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 32 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	p.Length = binary.BigEndian.Uint32(data[4:])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	p.MinOID = zodb.Oid(binary.BigEndian.Uint64(data[24:]))
	return 32, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 87. AnswerCheckSerialRange

func (_ *AnswerCheckSerialRange) NEOMsgCode() uint16 {
	return 87
}

func (p *AnswerCheckSerialRange) NEOMsgEncodedLen() int {
	return 60
}

func (p *AnswerCheckSerialRange) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Count)
	copy(data[4:], p.TidChecksum[:])
	binary.BigEndian.PutUint64(data[24:], uint64(p.MaxTID))
	copy(data[32:], p.OidChecksum[:])
	binary.BigEndian.PutUint64(data[52:], uint64(p.MaxOID))
}

func (p *AnswerCheckSerialRange) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 60 {
		goto overflow
	}
	p.Count = binary.BigEndian.Uint32(data[0:])
	copy(p.TidChecksum[:], data[4:24])
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[24:]))
	copy(p.OidChecksum[:], data[32:52])
	p.MaxOID = zodb.Oid(binary.BigEndian.Uint64(data[52:]))
	return 60, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 88. PartitionCorrupted

func (_ *PartitionCorrupted) NEOMsgCode() uint16 {
	return 88
}

func (p *PartitionCorrupted) NEOMsgEncodedLen() int {
	return 8 + len(p.CellList)*4
}

func (p *PartitionCorrupted) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *PartitionCorrupted) NEOMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.CellList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 89. LastTransaction

func (_ *LastTransaction) NEOMsgCode() uint16 {
	return 89
}

func (p *LastTransaction) NEOMsgEncodedLen() int {
	return 0
}

func (p *LastTransaction) NEOMsgEncode(data []byte) {
}

func (p *LastTransaction) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 90. AnswerLastTransaction

func (_ *AnswerLastTransaction) NEOMsgCode() uint16 {
	return 90
}

func (p *AnswerLastTransaction) NEOMsgEncodedLen() int {
	return 8
}

func (p *AnswerLastTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerLastTransaction) NEOMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 91. NotifyReady

func (_ *NotifyReady) NEOMsgCode() uint16 {
	return 91
}

func (p *NotifyReady) NEOMsgEncodedLen() int {
	return 0
}

func (p *NotifyReady) NEOMsgEncode(data []byte) {
}

func (p *NotifyReady) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// registry of message types
var msgTypeRegistry = map[uint16]reflect.Type{
	0:  reflect.TypeOf(Address{}),
	1:  reflect.TypeOf(NodeInfo{}),
	2:  reflect.TypeOf(CellInfo{}),
	3:  reflect.TypeOf(RowInfo{}),
	4:  reflect.TypeOf(Error{}),
	5:  reflect.TypeOf(Ping{}),
	6:  reflect.TypeOf(CloseClient{}),
	7:  reflect.TypeOf(RequestIdentification{}),
	8:  reflect.TypeOf(AcceptIdentification{}),
	9:  reflect.TypeOf(PrimaryMaster{}),
	10: reflect.TypeOf(AnswerPrimary{}),
	11: reflect.TypeOf(NotPrimaryMaster{}),
	12: reflect.TypeOf(Recovery{}),
	13: reflect.TypeOf(AnswerRecovery{}),
	14: reflect.TypeOf(LastIDs{}),
	15: reflect.TypeOf(AnswerLastIDs{}),
	16: reflect.TypeOf(AskPartitionTable{}),
	17: reflect.TypeOf(AnswerPartitionTable{}),
	18: reflect.TypeOf(NotifyPartitionTable{}),
	19: reflect.TypeOf(NotifyPartitionChanges{}),
	20: reflect.TypeOf(StartOperation{}),
	21: reflect.TypeOf(StopOperation{}),
	22: reflect.TypeOf(UnfinishedTransactions{}),
	23: reflect.TypeOf(AnswerUnfinishedTransactions{}),
	24: reflect.TypeOf(LockedTransactions{}),
	25: reflect.TypeOf(AnswerLockedTransactions{}),
	26: reflect.TypeOf(FinalTID{}),
	27: reflect.TypeOf(AnswerFinalTID{}),
	28: reflect.TypeOf(ValidateTransaction{}),
	29: reflect.TypeOf(BeginTransaction{}),
	30: reflect.TypeOf(AnswerBeginTransaction{}),
	31: reflect.TypeOf(FailedVote{}),
	32: reflect.TypeOf(FinishTransaction{}),
	33: reflect.TypeOf(AnswerFinishTransaction{}),
	34: reflect.TypeOf(NotifyTransactionFinished{}),
	35: reflect.TypeOf(LockInformation{}),
	36: reflect.TypeOf(AnswerLockInformation{}),
	37: reflect.TypeOf(InvalidateObjects{}),
	38: reflect.TypeOf(UnlockInformation{}),
	39: reflect.TypeOf(GenerateOIDs{}),
	40: reflect.TypeOf(AnswerGenerateOIDs{}),
	41: reflect.TypeOf(Deadlock{}),
	42: reflect.TypeOf(RebaseTransaction{}),
	43: reflect.TypeOf(AnswerRebaseTransaction{}),
	44: reflect.TypeOf(RebaseObject{}),
	45: reflect.TypeOf(AnswerRebaseObject{}),
	46: reflect.TypeOf(StoreObject{}),
	47: reflect.TypeOf(AnswerStoreObject{}),
	48: reflect.TypeOf(AbortTransaction{}),
	49: reflect.TypeOf(StoreTransaction{}),
	50: reflect.TypeOf(VoteTransaction{}),
	51: reflect.TypeOf(GetObject{}),
	52: reflect.TypeOf(AnswerGetObject{}),
	53: reflect.TypeOf(TIDList{}),
	54: reflect.TypeOf(AnswerTIDList{}),
	55: reflect.TypeOf(TIDListFrom{}),
	56: reflect.TypeOf(AnswerTIDListFrom{}),
	57: reflect.TypeOf(TransactionInformation{}),
	58: reflect.TypeOf(AnswerTransactionInformation{}),
	59: reflect.TypeOf(ObjectHistory{}),
	60: reflect.TypeOf(AnswerObjectHistory{}),
	61: reflect.TypeOf(PartitionList{}),
	62: reflect.TypeOf(AnswerPartitionList{}),
	63: reflect.TypeOf(NodeList{}),
	64: reflect.TypeOf(AnswerNodeList{}),
	65: reflect.TypeOf(SetNodeState{}),
	66: reflect.TypeOf(AddPendingNodes{}),
	67: reflect.TypeOf(TweakPartitionTable{}),
	68: reflect.TypeOf(NotifyNodeInformation{}),
	69: reflect.TypeOf(NodeInformation{}),
	70: reflect.TypeOf(SetClusterState{}),
	71: reflect.TypeOf(repairFlags{}),
	72: reflect.TypeOf(Repair{}),
	73: reflect.TypeOf(RepairOne{}),
	74: reflect.TypeOf(NotifyClusterState{}),
	75: reflect.TypeOf(AskClusterState{}),
	76: reflect.TypeOf(AnswerClusterState{}),
	77: reflect.TypeOf(ObjectUndoSerial{}),
	78: reflect.TypeOf(AnswerObjectUndoSerial{}),
	79: reflect.TypeOf(CheckCurrentSerial{}),
	80: reflect.TypeOf(Pack{}),
	81: reflect.TypeOf(AnswerPack{}),
	82: reflect.TypeOf(CheckReplicas{}),
	83: reflect.TypeOf(CheckPartition{}),
	84: reflect.TypeOf(CheckTIDRange{}),
	85: reflect.TypeOf(AnswerCheckTIDRange{}),
	86: reflect.TypeOf(CheckSerialRange{}),
	87: reflect.TypeOf(AnswerCheckSerialRange{}),
	88: reflect.TypeOf(PartitionCorrupted{}),
	89: reflect.TypeOf(LastTransaction{}),
	90: reflect.TypeOf(AnswerLastTransaction{}),
	91: reflect.TypeOf(NotifyReady{}),
}
