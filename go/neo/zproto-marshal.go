// Code generated by protogen.go; DO NOT EDIT.

package neo

// protocol messages to/from wire marshalling.

import (
	"encoding/binary"
	"reflect"
	"sort"

	"lab.nexedi.com/kirr/neo/go/zodb"
)

// messages marshalling

// 0. Error (answer)

func (*Error) neoMsgCode() uint16 {
	return 0 | answerBit
}

func (p *Error) neoMsgEncodedLen() int {
	return 8 + len(p.Message)
}

func (p *Error) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(p.Code))
	{
		l := uint32(len(p.Message))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Message)
		data = data[l:]
	}
}

func (p *Error) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Code = ErrorCode(binary.BigEndian.Uint32(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < l {
			goto overflow
		}
		nread += l
		p.Message = string(data[:l])
		data = data[l:]
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 1. RequestIdentification

func (*RequestIdentification) neoMsgCode() uint16 {
	return 1
}

func (p *RequestIdentification) neoMsgEncodedLen() int {
	return 26 + len(p.Address.Host) + len(p.ClusterName)
}

func (p *RequestIdentification) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.UUID)))
	{
		l := uint32(len(p.Address.Host))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.Address.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Address.Port)
	{
		l := uint32(len(p.ClusterName))
		binary.BigEndian.PutUint32(data[2:], l)
		data = data[6:]
		copy(data, p.ClusterName)
		data = data[l:]
	}
	float64_NEOEncode(data[0:], p.IdTimestamp)
}

func (p *RequestIdentification) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	p.UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 6+l {
			goto overflow
		}
		nread += 6 + l
		p.Address.Host = string(data[:l])
		data = data[l:]
	}
	p.Address.Port = binary.BigEndian.Uint16(data[0:])
	{
		l := binary.BigEndian.Uint32(data[2:])
		data = data[6:]
		if uint32(len(data)) < 8+l {
			goto overflow
		}
		nread += 8 + l
		p.ClusterName = string(data[:l])
		data = data[l:]
	}
	p.IdTimestamp = float64_NEODecode(data[0:])
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 2. AcceptIdentification (answer)

func (*AcceptIdentification) neoMsgCode() uint16 {
	return 2 | answerBit
}

func (p *AcceptIdentification) neoMsgEncodedLen() int {
	return 20
}

func (p *AcceptIdentification) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.MyUUID)))
	binary.BigEndian.PutUint32(data[8:], p.NumPartitions)
	binary.BigEndian.PutUint32(data[12:], p.NumReplicas)
	binary.BigEndian.PutUint32(data[16:], uint32(int32(p.YourUUID)))
}

func (p *AcceptIdentification) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 20 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	p.MyUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
	p.NumPartitions = binary.BigEndian.Uint32(data[8:])
	p.NumReplicas = binary.BigEndian.Uint32(data[12:])
	p.YourUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[16:])))
	return 20, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 3. Ping

func (*Ping) neoMsgCode() uint16 {
	return 3
}

func (p *Ping) neoMsgEncodedLen() int {
	return 0
}

func (p *Ping) neoMsgEncode(data []byte) {
}

func (p *Ping) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 4. Pong (answer)

func (*Pong) neoMsgCode() uint16 {
	return 4 | answerBit
}

func (p *Pong) neoMsgEncodedLen() int {
	return 0
}

func (p *Pong) neoMsgEncode(data []byte) {
}

func (p *Pong) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 5. CloseClient

func (*CloseClient) neoMsgCode() uint16 {
	return 5
}

func (p *CloseClient) neoMsgEncodedLen() int {
	return 0
}

func (p *CloseClient) neoMsgEncode(data []byte) {
}

func (p *CloseClient) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 6. PrimaryMaster

func (*PrimaryMaster) neoMsgCode() uint16 {
	return 6
}

func (p *PrimaryMaster) neoMsgEncodedLen() int {
	return 0
}

func (p *PrimaryMaster) neoMsgEncode(data []byte) {
}

func (p *PrimaryMaster) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 7. AnswerPrimary

func (*AnswerPrimary) neoMsgCode() uint16 {
	return 7 | answerBit
}

func (p *AnswerPrimary) neoMsgEncodedLen() int {
	return 4
}

func (p *AnswerPrimary) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.PrimaryNodeUUID)))
}

func (p *AnswerPrimary) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.PrimaryNodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 8. NotPrimaryMaster

func (*NotPrimaryMaster) neoMsgCode() uint16 {
	return 8
}

func (p *NotPrimaryMaster) neoMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.KnownMasterList); i++ {
		a := &p.KnownMasterList[i]
		size += len((*a).Address.Host)
	}
	return 8 + len(p.KnownMasterList)*6 + size
}

func (p *NotPrimaryMaster) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.Primary)))
	{
		l := uint32(len(p.KnownMasterList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.KnownMasterList[i]
			{
				l := uint32(len((*a).Address.Host))
				binary.BigEndian.PutUint32(data[0:], l)
				data = data[4:]
				copy(data, (*a).Address.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Address.Port)
			data = data[2:]
		}
	}
}

func (p *NotPrimaryMaster) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Primary = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		p.KnownMasterList = make([]struct{ Address }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.KnownMasterList[i]
			if uint32(len(data)) < 4 {
				goto overflow
			}
			{
				l := binary.BigEndian.Uint32(data[0:])
				data = data[4:]
				if uint32(len(data)) < 2+l {
					goto overflow
				}
				nread += 2 + l
				(*a).Address.Host = string(data[:l])
				data = data[l:]
			}
			(*a).Address.Port = binary.BigEndian.Uint16(data[0:])
			data = data[2:]
		}
		nread += l * 4
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 9. NotifyNodeInformation

func (*NotifyNodeInformation) neoMsgCode() uint16 {
	return 9
}

func (p *NotifyNodeInformation) neoMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.NodeList); i++ {
		a := &p.NodeList[i]
		size += len((*a).Addr.Host)
	}
	return 12 + len(p.NodeList)*26 + size
}

func (p *NotifyNodeInformation) neoMsgEncode(data []byte) {
	float64_NEOEncode(data[0:], p.IdTimestamp)
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).Type)))
			{
				l := uint32(len((*a).Addr.Host))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				copy(data, (*a).Addr.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Addr.Port)
			binary.BigEndian.PutUint32(data[2:], uint32(int32((*a).UUID)))
			binary.BigEndian.PutUint32(data[6:], uint32(int32((*a).State)))
			float64_NEOEncode(data[10:], (*a).IdTimestamp)
			data = data[18:]
		}
	}
}

func (p *NotifyNodeInformation) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.IdTimestamp = float64_NEODecode(data[0:])
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.NodeList = make([]NodeInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).Type = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < 18+l {
					goto overflow
				}
				nread += 18 + l
				(*a).Addr.Host = string(data[:l])
				data = data[l:]
			}
			(*a).Addr.Port = binary.BigEndian.Uint16(data[0:])
			(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[2:])))
			(*a).State = NodeState(int32(binary.BigEndian.Uint32(data[6:])))
			(*a).IdTimestamp = float64_NEODecode(data[10:])
			data = data[18:]
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 10. Recovery

func (*Recovery) neoMsgCode() uint16 {
	return 10
}

func (p *Recovery) neoMsgEncodedLen() int {
	return 0
}

func (p *Recovery) neoMsgEncode(data []byte) {
}

func (p *Recovery) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 11. AnswerRecovery

func (*AnswerRecovery) neoMsgCode() uint16 {
	return 11 | answerBit
}

func (p *AnswerRecovery) neoMsgEncodedLen() int {
	return 24
}

func (p *AnswerRecovery) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.BackupTid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.TruncateTid))
}

func (p *AnswerRecovery) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	p.BackupTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.TruncateTid = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 12. LastIDs

func (*LastIDs) neoMsgCode() uint16 {
	return 12
}

func (p *LastIDs) neoMsgEncodedLen() int {
	return 0
}

func (p *LastIDs) neoMsgEncode(data []byte) {
}

func (p *LastIDs) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 13. AnswerLastIDs

func (*AnswerLastIDs) neoMsgCode() uint16 {
	return 13 | answerBit
}

func (p *AnswerLastIDs) neoMsgEncodedLen() int {
	return 16
}

func (p *AnswerLastIDs) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.LastOid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LastTid))
}

func (p *AnswerLastIDs) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.LastOid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.LastTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 14. AskPartitionTable

func (*AskPartitionTable) neoMsgCode() uint16 {
	return 14
}

func (p *AskPartitionTable) neoMsgEncodedLen() int {
	return 0
}

func (p *AskPartitionTable) neoMsgEncode(data []byte) {
}

func (p *AskPartitionTable) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 15. AnswerPartitionTable

func (*AnswerPartitionTable) neoMsgCode() uint16 {
	return 15 | answerBit
}

func (p *AnswerPartitionTable) neoMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 12 + len(p.RowList)*8 + size
}

func (p *AnswerPartitionTable) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).State)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerPartitionTable) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < l*8 {
					goto overflow
				}
				nread += l * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).State = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 16. SendPartitionTable

func (*SendPartitionTable) neoMsgCode() uint16 {
	return 16
}

func (p *SendPartitionTable) neoMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 12 + len(p.RowList)*8 + size
}

func (p *SendPartitionTable) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).State)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *SendPartitionTable) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < l*8 {
					goto overflow
				}
				nread += l * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).State = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 17. NotifyPartitionChanges

func (*NotifyPartitionChanges) neoMsgCode() uint16 {
	return 17
}

func (p *NotifyPartitionChanges) neoMsgEncodedLen() int {
	return 12 + len(p.CellList)*12
}

func (p *NotifyPartitionChanges) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellInfo.UUID)))
			binary.BigEndian.PutUint32(data[8:], uint32(int32((*a).CellInfo.State)))
			data = data[12:]
		}
	}
}

func (p *NotifyPartitionChanges) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*12 {
			goto overflow
		}
		nread += l * 12
		p.CellList = make([]struct {
			Offset   uint32
			CellInfo CellInfo
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			(*a).CellInfo.UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
			(*a).CellInfo.State = CellState(int32(binary.BigEndian.Uint32(data[8:])))
			data = data[12:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 18. StartOperation

func (*StartOperation) neoMsgCode() uint16 {
	return 18
}

func (p *StartOperation) neoMsgEncodedLen() int {
	return 1
}

func (p *StartOperation) neoMsgEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Backup)
}

func (p *StartOperation) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.Backup = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 19. StopOperation

func (*StopOperation) neoMsgCode() uint16 {
	return 19
}

func (p *StopOperation) neoMsgEncodedLen() int {
	return 0
}

func (p *StopOperation) neoMsgEncode(data []byte) {
}

func (p *StopOperation) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 20. UnfinishedTransactions

func (*UnfinishedTransactions) neoMsgCode() uint16 {
	return 20
}

func (p *UnfinishedTransactions) neoMsgEncodedLen() int {
	return 4 + len(p.RowList)*4
}

func (p *UnfinishedTransactions) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			data = data[4:]
		}
	}
}

func (p *UnfinishedTransactions) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.RowList = make([]struct{ Offset uint32 }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 21. AnswerUnfinishedTransactions

func (*AnswerUnfinishedTransactions) neoMsgCode() uint16 {
	return 21 | answerBit
}

func (p *AnswerUnfinishedTransactions) neoMsgEncodedLen() int {
	return 12 + len(p.TidList)*8
}

func (p *AnswerUnfinishedTransactions) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.MaxTID))
	{
		l := uint32(len(p.TidList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a).UnfinishedTID))
			data = data[8:]
		}
	}
}

func (p *AnswerUnfinishedTransactions) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.TidList = make([]struct{ UnfinishedTID zodb.Tid }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			(*a).UnfinishedTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 22. LockedTransactions

func (*LockedTransactions) neoMsgCode() uint16 {
	return 22
}

func (p *LockedTransactions) neoMsgEncodedLen() int {
	return 0
}

func (p *LockedTransactions) neoMsgEncode(data []byte) {
}

func (p *LockedTransactions) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 23. AnswerLockedTransactions

func (*AnswerLockedTransactions) neoMsgCode() uint16 {
	return 23 | answerBit
}

func (p *AnswerLockedTransactions) neoMsgEncodedLen() int {
	return 4 + len(p.TidDict)*16
}

func (p *AnswerLockedTransactions) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.TidDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]zodb.Tid, 0, l)
		for key := range p.TidDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			binary.BigEndian.PutUint64(data[8:], uint64(p.TidDict[key]))
			data = data[16:]
		}
	}
}

func (p *AnswerLockedTransactions) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*16 {
			goto overflow
		}
		nread += l * 16
		p.TidDict = make(map[zodb.Tid]zodb.Tid, l)
		m := p.TidDict
		for i := 0; uint32(i) < l; i++ {
			key := zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			m[key] = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
			data = data[16:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 24. FinalTID

func (*FinalTID) neoMsgCode() uint16 {
	return 24
}

func (p *FinalTID) neoMsgEncodedLen() int {
	return 8
}

func (p *FinalTID) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
}

func (p *FinalTID) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 25. AnswerFinalTID

func (*AnswerFinalTID) neoMsgCode() uint16 {
	return 25 | answerBit
}

func (p *AnswerFinalTID) neoMsgEncodedLen() int {
	return 8
}

func (p *AnswerFinalTID) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerFinalTID) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 26. ValidateTransaction

func (*ValidateTransaction) neoMsgCode() uint16 {
	return 26
}

func (p *ValidateTransaction) neoMsgEncodedLen() int {
	return 16
}

func (p *ValidateTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *ValidateTransaction) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 27. BeginTransaction

func (*BeginTransaction) neoMsgCode() uint16 {
	return 27
}

func (p *BeginTransaction) neoMsgEncodedLen() int {
	return 8
}

func (p *BeginTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *BeginTransaction) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 28. AnswerBeginTransaction

func (*AnswerBeginTransaction) neoMsgCode() uint16 {
	return 28 | answerBit
}

func (p *AnswerBeginTransaction) neoMsgEncodedLen() int {
	return 8
}

func (p *AnswerBeginTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerBeginTransaction) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 29. FailedVote

func (*FailedVote) neoMsgCode() uint16 {
	return 29
}

func (p *FailedVote) neoMsgEncodedLen() int {
	return 12 + len(p.NodeList)*4
}

func (p *FailedVote) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *FailedVote) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 30. FinishTransaction

func (*FinishTransaction) neoMsgCode() uint16 {
	return 30
}

func (p *FinishTransaction) neoMsgEncodedLen() int {
	return 16 + len(p.OIDList)*8 + len(p.CheckedList)*8
}

func (p *FinishTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.OIDList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OIDList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
	{
		l := uint32(len(p.CheckedList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CheckedList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *FinishTransaction) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 4+l*8 {
			goto overflow
		}
		nread += 4 + l*8
		p.OIDList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OIDList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.CheckedList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CheckedList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 31. AnswerTransactionFinished

func (*AnswerTransactionFinished) neoMsgCode() uint16 {
	return 31 | answerBit
}

func (p *AnswerTransactionFinished) neoMsgEncodedLen() int {
	return 16
}

func (p *AnswerTransactionFinished) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *AnswerTransactionFinished) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 32. LockInformation

func (*LockInformation) neoMsgCode() uint16 {
	return 32
}

func (p *LockInformation) neoMsgEncodedLen() int {
	return 16
}

func (p *LockInformation) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Ttid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *LockInformation) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.Ttid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 33. AnswerInformationLocked

func (*AnswerInformationLocked) neoMsgCode() uint16 {
	return 33 | answerBit
}

func (p *AnswerInformationLocked) neoMsgEncodedLen() int {
	return 8
}

func (p *AnswerInformationLocked) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Ttid))
}

func (p *AnswerInformationLocked) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Ttid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 34. InvalidateObjects

func (*InvalidateObjects) neoMsgCode() uint16 {
	return 34
}

func (p *InvalidateObjects) neoMsgEncodedLen() int {
	return 12 + len(p.OidList)*8
}

func (p *InvalidateObjects) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *InvalidateObjects) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 35. NotifyUnlockInformation

func (*NotifyUnlockInformation) neoMsgCode() uint16 {
	return 35
}

func (p *NotifyUnlockInformation) neoMsgEncodedLen() int {
	return 8
}

func (p *NotifyUnlockInformation) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
}

func (p *NotifyUnlockInformation) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 36. AskNewOIDs

func (*AskNewOIDs) neoMsgCode() uint16 {
	return 36
}

func (p *AskNewOIDs) neoMsgEncodedLen() int {
	return 4
}

func (p *AskNewOIDs) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.NumOIDs)
}

func (p *AskNewOIDs) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.NumOIDs = binary.BigEndian.Uint32(data[0:])
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 37. AnswerNewOIDs

func (*AnswerNewOIDs) neoMsgCode() uint16 {
	return 37 | answerBit
}

func (p *AnswerNewOIDs) neoMsgEncodedLen() int {
	return 4 + len(p.OidList)*8
}

func (p *AnswerNewOIDs) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerNewOIDs) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 38. NotifyDeadlock

func (*NotifyDeadlock) neoMsgCode() uint16 {
	return 38
}

func (p *NotifyDeadlock) neoMsgEncodedLen() int {
	return 16
}

func (p *NotifyDeadlock) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LockingTid))
}

func (p *NotifyDeadlock) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LockingTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 39. RebaseTransaction

func (*RebaseTransaction) neoMsgCode() uint16 {
	return 39
}

func (p *RebaseTransaction) neoMsgEncodedLen() int {
	return 16
}

func (p *RebaseTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LockingTid))
}

func (p *RebaseTransaction) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LockingTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 40. AnswerRebaseTransaction

func (*AnswerRebaseTransaction) neoMsgCode() uint16 {
	return 40 | answerBit
}

func (p *AnswerRebaseTransaction) neoMsgEncodedLen() int {
	return 4 + len(p.OidList)*8
}

func (p *AnswerRebaseTransaction) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerRebaseTransaction) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 41. RebaseObject

func (*RebaseObject) neoMsgCode() uint16 {
	return 41
}

func (p *RebaseObject) neoMsgEncodedLen() int {
	return 16
}

func (p *RebaseObject) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Oid))
}

func (p *RebaseObject) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 42. AnswerRebaseObject

func (*AnswerRebaseObject) neoMsgCode() uint16 {
	return 42 | answerBit
}

func (p *AnswerRebaseObject) neoMsgEncodedLen() int {
	return 41 + len(p.Data)
}

func (p *AnswerRebaseObject) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[8:], uint64(p.ConflictSerial))
	(data[16:])[0] = bool2byte(p.Compression)
	copy(data[17:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		copy(data, p.Data)
		data = data[l:]
	}
}

func (p *AnswerRebaseObject) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 41 {
		goto overflow
	}
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.ConflictSerial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Compression = byte2bool((data[16:])[0])
	copy(p.Checksum[:], data[17:37])
	{
		l := binary.BigEndian.Uint32(data[37:])
		data = data[41:]
		if uint32(len(data)) < l {
			goto overflow
		}
		nread += l
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	return 41 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 43. StoreObject

func (*StoreObject) neoMsgCode() uint16 {
	return 43
}

func (p *StoreObject) neoMsgEncodedLen() int {
	return 57 + len(p.Data)
}

func (p *StoreObject) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	(data[16:])[0] = bool2byte(p.Compression)
	copy(data[17:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		copy(data, p.Data)
		data = data[l:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *StoreObject) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 41 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Compression = byte2bool((data[16:])[0])
	copy(p.Checksum[:], data[17:37])
	{
		l := binary.BigEndian.Uint32(data[37:])
		data = data[41:]
		if uint32(len(data)) < 16+l {
			goto overflow
		}
		nread += 16 + l
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	p.DataSerial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 41 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 44. AnswerStoreObject

func (*AnswerStoreObject) neoMsgCode() uint16 {
	return 44 | answerBit
}

func (p *AnswerStoreObject) neoMsgEncodedLen() int {
	return 8
}

func (p *AnswerStoreObject) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Conflict))
}

func (p *AnswerStoreObject) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Conflict = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 45. AbortTransaction

func (*AbortTransaction) neoMsgCode() uint16 {
	return 45
}

func (p *AbortTransaction) neoMsgEncodedLen() int {
	return 12 + len(p.NodeList)*4
}

func (p *AbortTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *AbortTransaction) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 46. StoreTransaction

func (*StoreTransaction) neoMsgCode() uint16 {
	return 46
}

func (p *StoreTransaction) neoMsgEncodedLen() int {
	return 24 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *StoreTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *StoreTransaction) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.User = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Description = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Extension = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 47. AnswerStoreTransaction

func (*AnswerStoreTransaction) neoMsgCode() uint16 {
	return 47 | answerBit
}

func (p *AnswerStoreTransaction) neoMsgEncodedLen() int {
	return 0
}

func (p *AnswerStoreTransaction) neoMsgEncode(data []byte) {
}

func (p *AnswerStoreTransaction) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 48. VoteTransaction

func (*VoteTransaction) neoMsgCode() uint16 {
	return 48
}

func (p *VoteTransaction) neoMsgEncodedLen() int {
	return 8
}

func (p *VoteTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *VoteTransaction) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 49. AnswerVoteTransaction

func (*AnswerVoteTransaction) neoMsgCode() uint16 {
	return 49 | answerBit
}

func (p *AnswerVoteTransaction) neoMsgEncodedLen() int {
	return 0
}

func (p *AnswerVoteTransaction) neoMsgEncode(data []byte) {
}

func (p *AnswerVoteTransaction) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 50. GetObject

func (*GetObject) neoMsgCode() uint16 {
	return 50
}

func (p *GetObject) neoMsgEncodedLen() int {
	return 24
}

func (p *GetObject) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[16:], uint64(p.Tid))
}

func (p *GetObject) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 51. AnswerObject

func (*AnswerObject) neoMsgCode() uint16 {
	return 51 | answerBit
}

func (p *AnswerObject) neoMsgEncodedLen() int {
	return 57 + len(p.Data)
}

func (p *AnswerObject) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[16:], uint64(p.NextSerial))
	(data[24:])[0] = bool2byte(p.Compression)
	copy(data[25:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[45:], l)
		data = data[49:]
		copy(data, p.Data)
		data = data[l:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
}

func (p *AnswerObject) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 49 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.NextSerial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	p.Compression = byte2bool((data[24:])[0])
	copy(p.Checksum[:], data[25:45])
	{
		l := binary.BigEndian.Uint32(data[45:])
		data = data[49:]
		if uint32(len(data)) < 8+l {
			goto overflow
		}
		nread += 8 + l
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	p.DataSerial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 49 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 52. AskTIDs

func (*AskTIDs) neoMsgCode() uint16 {
	return 52
}

func (p *AskTIDs) neoMsgEncodedLen() int {
	return 20
}

func (p *AskTIDs) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], p.First)
	binary.BigEndian.PutUint64(data[8:], p.Last)
	binary.BigEndian.PutUint32(data[16:], p.Partition)
}

func (p *AskTIDs) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 20 {
		goto overflow
	}
	p.First = binary.BigEndian.Uint64(data[0:])
	p.Last = binary.BigEndian.Uint64(data[8:])
	p.Partition = binary.BigEndian.Uint32(data[16:])
	return 20, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 53. AnswerTIDs

func (*AnswerTIDs) neoMsgCode() uint16 {
	return 53 | answerBit
}

func (p *AnswerTIDs) neoMsgEncodedLen() int {
	return 4 + len(p.TIDList)*8
}

func (p *AnswerTIDs) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.TIDList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TIDList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTIDs) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.TIDList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TIDList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 54. TransactionInformation

func (*TransactionInformation) neoMsgCode() uint16 {
	return 54
}

func (p *TransactionInformation) neoMsgEncodedLen() int {
	return 8
}

func (p *TransactionInformation) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *TransactionInformation) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 55. AnswerTransactionInformation

func (*AnswerTransactionInformation) neoMsgCode() uint16 {
	return 55 | answerBit
}

func (p *AnswerTransactionInformation) neoMsgEncodedLen() int {
	return 25 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *AnswerTransactionInformation) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	(data[0:])[0] = bool2byte(p.Packed)
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[1:], l)
		data = data[5:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTransactionInformation) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.User = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Description = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 5+l {
			goto overflow
		}
		nread += 5 + l
		p.Extension = string(data[:l])
		data = data[l:]
	}
	p.Packed = byte2bool((data[0:])[0])
	{
		l := binary.BigEndian.Uint32(data[1:])
		data = data[5:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 56. ObjectHistory

func (*ObjectHistory) neoMsgCode() uint16 {
	return 56
}

func (p *ObjectHistory) neoMsgEncodedLen() int {
	return 24
}

func (p *ObjectHistory) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], p.First)
	binary.BigEndian.PutUint64(data[16:], p.Last)
}

func (p *ObjectHistory) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.First = binary.BigEndian.Uint64(data[8:])
	p.Last = binary.BigEndian.Uint64(data[16:])
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 57. AnswerObjectHistory

func (*AnswerObjectHistory) neoMsgCode() uint16 {
	return 57 | answerBit
}

func (p *AnswerObjectHistory) neoMsgEncodedLen() int {
	return 12 + len(p.HistoryList)*12
}

func (p *AnswerObjectHistory) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	{
		l := uint32(len(p.HistoryList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.HistoryList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a).Serial))
			binary.BigEndian.PutUint32(data[8:], (*a).Size)
			data = data[12:]
		}
	}
}

func (p *AnswerObjectHistory) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l*12 {
			goto overflow
		}
		nread += l * 12
		p.HistoryList = make([]struct {
			Serial zodb.Tid
			Size   uint32
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.HistoryList[i]
			(*a).Serial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			(*a).Size = binary.BigEndian.Uint32(data[8:])
			data = data[12:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 58. PartitionList

func (*PartitionList) neoMsgCode() uint16 {
	return 58
}

func (p *PartitionList) neoMsgEncodedLen() int {
	return 12
}

func (p *PartitionList) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.MinOffset)
	binary.BigEndian.PutUint32(data[4:], p.MaxOffset)
	binary.BigEndian.PutUint32(data[8:], uint32(int32(p.NodeUUID)))
}

func (p *PartitionList) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.MinOffset = binary.BigEndian.Uint32(data[0:])
	p.MaxOffset = binary.BigEndian.Uint32(data[4:])
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[8:])))
	return 12, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 59. AnswerPartitionList

func (*AnswerPartitionList) neoMsgCode() uint16 {
	return 59 | answerBit
}

func (p *AnswerPartitionList) neoMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 12 + len(p.RowList)*8 + size
}

func (p *AnswerPartitionList) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).State)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerPartitionList) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < l*8 {
					goto overflow
				}
				nread += l * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).State = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += l * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 60. NodeList

func (*NodeList) neoMsgCode() uint16 {
	return 60
}

func (p *NodeList) neoMsgEncodedLen() int {
	return 4
}

func (p *NodeList) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
}

func (p *NodeList) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 61. AnswerNodeList

func (*AnswerNodeList) neoMsgCode() uint16 {
	return 61 | answerBit
}

func (p *AnswerNodeList) neoMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.NodeList); i++ {
		a := &p.NodeList[i]
		size += len((*a).Addr.Host)
	}
	return 4 + len(p.NodeList)*26 + size
}

func (p *AnswerNodeList) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).Type)))
			{
				l := uint32(len((*a).Addr.Host))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				copy(data, (*a).Addr.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Addr.Port)
			binary.BigEndian.PutUint32(data[2:], uint32(int32((*a).UUID)))
			binary.BigEndian.PutUint32(data[6:], uint32(int32((*a).State)))
			float64_NEOEncode(data[10:], (*a).IdTimestamp)
			data = data[18:]
		}
	}
}

func (p *AnswerNodeList) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		p.NodeList = make([]NodeInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			if uint32(len(data)) < 8 {
				goto overflow
			}
			(*a).Type = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < 18+l {
					goto overflow
				}
				nread += 18 + l
				(*a).Addr.Host = string(data[:l])
				data = data[l:]
			}
			(*a).Addr.Port = binary.BigEndian.Uint16(data[0:])
			(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[2:])))
			(*a).State = NodeState(int32(binary.BigEndian.Uint32(data[6:])))
			(*a).IdTimestamp = float64_NEODecode(data[10:])
			data = data[18:]
		}
		nread += l * 8
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 62. SetNodeState

func (*SetNodeState) neoMsgCode() uint16 {
	return 62
}

func (p *SetNodeState) neoMsgEncodedLen() int {
	return 8
}

func (p *SetNodeState) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeUUID)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.NodeState)))
}

func (p *SetNodeState) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
	p.NodeState = NodeState(int32(binary.BigEndian.Uint32(data[4:])))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 63. AddPendingNodes

func (*AddPendingNodes) neoMsgCode() uint16 {
	return 63
}

func (p *AddPendingNodes) neoMsgEncodedLen() int {
	return 4 + len(p.NodeList)*4
}

func (p *AddPendingNodes) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *AddPendingNodes) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 64. TweakPartitionTable

func (*TweakPartitionTable) neoMsgCode() uint16 {
	return 64
}

func (p *TweakPartitionTable) neoMsgEncodedLen() int {
	return 4 + len(p.NodeList)*4
}

func (p *TweakPartitionTable) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *TweakPartitionTable) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 65. SetClusterState

func (*SetClusterState) neoMsgCode() uint16 {
	return 65
}

func (p *SetClusterState) neoMsgEncodedLen() int {
	return 4
}

func (p *SetClusterState) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *SetClusterState) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 66. Repair

func (*Repair) neoMsgCode() uint16 {
	return 66
}

func (p *Repair) neoMsgEncodedLen() int {
	return 5 + len(p.NodeList)*4
}

func (p *Repair) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
	(data[0:])[0] = bool2byte(p.repairFlags.DryRun)
}

func (p *Repair) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 1+l*4 {
			goto overflow
		}
		nread += 1 + l*4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	p.repairFlags.DryRun = byte2bool((data[0:])[0])
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 67. RepairOne

func (*RepairOne) neoMsgCode() uint16 {
	return 67
}

func (p *RepairOne) neoMsgEncodedLen() int {
	return 1
}

func (p *RepairOne) neoMsgEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.repairFlags.DryRun)
}

func (p *RepairOne) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.repairFlags.DryRun = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 68. NotifyClusterState

func (*NotifyClusterState) neoMsgCode() uint16 {
	return 68
}

func (p *NotifyClusterState) neoMsgEncodedLen() int {
	return 4
}

func (p *NotifyClusterState) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *NotifyClusterState) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 69. AskClusterState

func (*AskClusterState) neoMsgCode() uint16 {
	return 69
}

func (p *AskClusterState) neoMsgEncodedLen() int {
	return 0
}

func (p *AskClusterState) neoMsgEncode(data []byte) {
}

func (p *AskClusterState) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 70. AnswerClusterState

func (*AnswerClusterState) neoMsgCode() uint16 {
	return 70 | answerBit
}

func (p *AnswerClusterState) neoMsgEncodedLen() int {
	return 4
}

func (p *AnswerClusterState) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *AnswerClusterState) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 71. ObjectUndoSerial

func (*ObjectUndoSerial) neoMsgCode() uint16 {
	return 71
}

func (p *ObjectUndoSerial) neoMsgEncodedLen() int {
	return 28 + len(p.OidList)*8
}

func (p *ObjectUndoSerial) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.UndoneTID))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[24:], l)
		data = data[28:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *ObjectUndoSerial) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 28 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.UndoneTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	{
		l := binary.BigEndian.Uint32(data[24:])
		data = data[28:]
		if uint32(len(data)) < l*8 {
			goto overflow
		}
		nread += l * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 28 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 72. AnswerObjectUndoSerial

func (*AnswerObjectUndoSerial) neoMsgCode() uint16 {
	return 72 | answerBit
}

func (p *AnswerObjectUndoSerial) neoMsgEncodedLen() int {
	return 4 + len(p.ObjectTIDDict)*25
}

func (p *AnswerObjectUndoSerial) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.ObjectTIDDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]zodb.Oid, 0, l)
		for key := range p.ObjectTIDDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			binary.BigEndian.PutUint64(data[8:], uint64(p.ObjectTIDDict[key].CurrentSerial))
			binary.BigEndian.PutUint64(data[16:], uint64(p.ObjectTIDDict[key].UndoSerial))
			(data[24:])[0] = bool2byte(p.ObjectTIDDict[key].IsCurrent)
			data = data[25:]
		}
	}
}

func (p *AnswerObjectUndoSerial) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l*25 {
			goto overflow
		}
		nread += l * 25
		p.ObjectTIDDict = make(map[zodb.Oid]struct {
			CurrentSerial zodb.Tid
			UndoSerial    zodb.Tid
			IsCurrent     bool
		}, l)
		m := p.ObjectTIDDict
		for i := 0; uint32(i) < l; i++ {
			key := zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			var v struct {
				CurrentSerial zodb.Tid
				UndoSerial    zodb.Tid
				IsCurrent     bool
			}
			v.CurrentSerial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
			v.UndoSerial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
			v.IsCurrent = byte2bool((data[24:])[0])
			m[key] = v
			data = data[25:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 73. CheckCurrentSerial

func (*CheckCurrentSerial) neoMsgCode() uint16 {
	return 73
}

func (p *CheckCurrentSerial) neoMsgEncodedLen() int {
	return 24
}

func (p *CheckCurrentSerial) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.Serial))
}

func (p *CheckCurrentSerial) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[8:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 74. Pack

func (*Pack) neoMsgCode() uint16 {
	return 74
}

func (p *Pack) neoMsgEncodedLen() int {
	return 8
}

func (p *Pack) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *Pack) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 75. AnswerPack

func (*AnswerPack) neoMsgCode() uint16 {
	return 75 | answerBit
}

func (p *AnswerPack) neoMsgEncodedLen() int {
	return 1
}

func (p *AnswerPack) neoMsgEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Status)
}

func (p *AnswerPack) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 1 {
		goto overflow
	}
	p.Status = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 76. CheckReplicas

func (*CheckReplicas) neoMsgCode() uint16 {
	return 76
}

func (p *CheckReplicas) neoMsgEncodedLen() int {
	return 20 + len(p.PartitionDict)*8
}

func (p *CheckReplicas) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.PartitionDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]uint32, 0, l)
		for key := range p.PartitionDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint32(data[0:], key)
			binary.BigEndian.PutUint32(data[4:], uint32(int32(p.PartitionDict[key])))
			data = data[8:]
		}
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *CheckReplicas) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 16+l*8 {
			goto overflow
		}
		nread += 16 + l*8
		p.PartitionDict = make(map[uint32]NodeUUID, l)
		m := p.PartitionDict
		for i := 0; uint32(i) < l; i++ {
			key := binary.BigEndian.Uint32(data[0:])
			m[key] = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
			data = data[8:]
		}
	}
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 77. CheckPartition

func (*CheckPartition) neoMsgCode() uint16 {
	return 77
}

func (p *CheckPartition) neoMsgEncodedLen() int {
	return 30 + len(p.Source.UpstreamName) + len(p.Source.Address.Host)
}

func (p *CheckPartition) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	{
		l := uint32(len(p.Source.UpstreamName))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Source.UpstreamName)
		data = data[l:]
	}
	{
		l := uint32(len(p.Source.Address.Host))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Source.Address.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Source.Address.Port)
	binary.BigEndian.PutUint64(data[2:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[10:], uint64(p.MaxTID))
}

func (p *CheckPartition) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < 4+l {
			goto overflow
		}
		nread += 4 + l
		p.Source.UpstreamName = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < 18+l {
			goto overflow
		}
		nread += 18 + l
		p.Source.Address.Host = string(data[:l])
		data = data[l:]
	}
	p.Source.Address.Port = binary.BigEndian.Uint16(data[0:])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[2:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[10:]))
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 78. CheckTIDRange

func (*CheckTIDRange) neoMsgCode() uint16 {
	return 78
}

func (p *CheckTIDRange) neoMsgEncodedLen() int {
	return 24
}

func (p *CheckTIDRange) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTID))
}

func (p *CheckTIDRange) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 24 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	p.Length = binary.BigEndian.Uint32(data[4:])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 79. AnswerCheckTIDRange

func (*AnswerCheckTIDRange) neoMsgCode() uint16 {
	return 79 | answerBit
}

func (p *AnswerCheckTIDRange) neoMsgEncodedLen() int {
	return 32
}

func (p *AnswerCheckTIDRange) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Count)
	copy(data[4:], p.Checksum[:])
	binary.BigEndian.PutUint64(data[24:], uint64(p.MaxTID))
}

func (p *AnswerCheckTIDRange) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 32 {
		goto overflow
	}
	p.Count = binary.BigEndian.Uint32(data[0:])
	copy(p.Checksum[:], data[4:24])
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[24:]))
	return 32, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 80. CheckSerialRange

func (*CheckSerialRange) neoMsgCode() uint16 {
	return 80
}

func (p *CheckSerialRange) neoMsgEncodedLen() int {
	return 32
}

func (p *CheckSerialRange) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTID))
	binary.BigEndian.PutUint64(data[24:], uint64(p.MinOID))
}

func (p *CheckSerialRange) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 32 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	p.Length = binary.BigEndian.Uint32(data[4:])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	p.MinOID = zodb.Oid(binary.BigEndian.Uint64(data[24:]))
	return 32, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 81. AnswerCheckSerialRange

func (*AnswerCheckSerialRange) neoMsgCode() uint16 {
	return 81 | answerBit
}

func (p *AnswerCheckSerialRange) neoMsgEncodedLen() int {
	return 60
}

func (p *AnswerCheckSerialRange) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Count)
	copy(data[4:], p.TidChecksum[:])
	binary.BigEndian.PutUint64(data[24:], uint64(p.MaxTID))
	copy(data[32:], p.OidChecksum[:])
	binary.BigEndian.PutUint64(data[52:], uint64(p.MaxOID))
}

func (p *AnswerCheckSerialRange) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 60 {
		goto overflow
	}
	p.Count = binary.BigEndian.Uint32(data[0:])
	copy(p.TidChecksum[:], data[4:24])
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[24:]))
	copy(p.OidChecksum[:], data[32:52])
	p.MaxOID = zodb.Oid(binary.BigEndian.Uint64(data[52:]))
	return 60, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 82. PartitionCorrupted

func (*PartitionCorrupted) neoMsgCode() uint16 {
	return 82
}

func (p *PartitionCorrupted) neoMsgEncodedLen() int {
	return 8 + len(p.CellList)*4
}

func (p *PartitionCorrupted) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *PartitionCorrupted) neoMsgDecode(data []byte) (int, error) {
	var nread uint32
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < l*4 {
			goto overflow
		}
		nread += l * 4
		p.CellList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 83. LastTransaction

func (*LastTransaction) neoMsgCode() uint16 {
	return 83
}

func (p *LastTransaction) neoMsgEncodedLen() int {
	return 0
}

func (p *LastTransaction) neoMsgEncode(data []byte) {
}

func (p *LastTransaction) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 84. AnswerLastTransaction

func (*AnswerLastTransaction) neoMsgCode() uint16 {
	return 84 | answerBit
}

func (p *AnswerLastTransaction) neoMsgEncodedLen() int {
	return 8
}

func (p *AnswerLastTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerLastTransaction) neoMsgDecode(data []byte) (int, error) {
	if uint32(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 85. NotifyReady

func (*NotifyReady) neoMsgCode() uint16 {
	return 85
}

func (p *NotifyReady) neoMsgEncodedLen() int {
	return 0
}

func (p *NotifyReady) neoMsgEncode(data []byte) {
}

func (p *NotifyReady) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// registry of message types
var msgTypeRegistry = map[uint16]reflect.Type{
	0 | answerBit:  reflect.TypeOf(Error{}),
	1:              reflect.TypeOf(RequestIdentification{}),
	2 | answerBit:  reflect.TypeOf(AcceptIdentification{}),
	3:              reflect.TypeOf(Ping{}),
	4 | answerBit:  reflect.TypeOf(Pong{}),
	5:              reflect.TypeOf(CloseClient{}),
	6:              reflect.TypeOf(PrimaryMaster{}),
	7 | answerBit:  reflect.TypeOf(AnswerPrimary{}),
	8:              reflect.TypeOf(NotPrimaryMaster{}),
	9:              reflect.TypeOf(NotifyNodeInformation{}),
	10:             reflect.TypeOf(Recovery{}),
	11 | answerBit: reflect.TypeOf(AnswerRecovery{}),
	12:             reflect.TypeOf(LastIDs{}),
	13 | answerBit: reflect.TypeOf(AnswerLastIDs{}),
	14:             reflect.TypeOf(AskPartitionTable{}),
	15 | answerBit: reflect.TypeOf(AnswerPartitionTable{}),
	16:             reflect.TypeOf(SendPartitionTable{}),
	17:             reflect.TypeOf(NotifyPartitionChanges{}),
	18:             reflect.TypeOf(StartOperation{}),
	19:             reflect.TypeOf(StopOperation{}),
	20:             reflect.TypeOf(UnfinishedTransactions{}),
	21 | answerBit: reflect.TypeOf(AnswerUnfinishedTransactions{}),
	22:             reflect.TypeOf(LockedTransactions{}),
	23 | answerBit: reflect.TypeOf(AnswerLockedTransactions{}),
	24:             reflect.TypeOf(FinalTID{}),
	25 | answerBit: reflect.TypeOf(AnswerFinalTID{}),
	26:             reflect.TypeOf(ValidateTransaction{}),
	27:             reflect.TypeOf(BeginTransaction{}),
	28 | answerBit: reflect.TypeOf(AnswerBeginTransaction{}),
	29:             reflect.TypeOf(FailedVote{}),
	30:             reflect.TypeOf(FinishTransaction{}),
	31 | answerBit: reflect.TypeOf(AnswerTransactionFinished{}),
	32:             reflect.TypeOf(LockInformation{}),
	33 | answerBit: reflect.TypeOf(AnswerInformationLocked{}),
	34:             reflect.TypeOf(InvalidateObjects{}),
	35:             reflect.TypeOf(NotifyUnlockInformation{}),
	36:             reflect.TypeOf(AskNewOIDs{}),
	37 | answerBit: reflect.TypeOf(AnswerNewOIDs{}),
	38:             reflect.TypeOf(NotifyDeadlock{}),
	39:             reflect.TypeOf(RebaseTransaction{}),
	40 | answerBit: reflect.TypeOf(AnswerRebaseTransaction{}),
	41:             reflect.TypeOf(RebaseObject{}),
	42 | answerBit: reflect.TypeOf(AnswerRebaseObject{}),
	43:             reflect.TypeOf(StoreObject{}),
	44 | answerBit: reflect.TypeOf(AnswerStoreObject{}),
	45:             reflect.TypeOf(AbortTransaction{}),
	46:             reflect.TypeOf(StoreTransaction{}),
	47 | answerBit: reflect.TypeOf(AnswerStoreTransaction{}),
	48:             reflect.TypeOf(VoteTransaction{}),
	49 | answerBit: reflect.TypeOf(AnswerVoteTransaction{}),
	50:             reflect.TypeOf(GetObject{}),
	51 | answerBit: reflect.TypeOf(AnswerObject{}),
	52:             reflect.TypeOf(AskTIDs{}),
	53 | answerBit: reflect.TypeOf(AnswerTIDs{}),
	54:             reflect.TypeOf(TransactionInformation{}),
	55 | answerBit: reflect.TypeOf(AnswerTransactionInformation{}),
	56:             reflect.TypeOf(ObjectHistory{}),
	57 | answerBit: reflect.TypeOf(AnswerObjectHistory{}),
	58:             reflect.TypeOf(PartitionList{}),
	59 | answerBit: reflect.TypeOf(AnswerPartitionList{}),
	60:             reflect.TypeOf(NodeList{}),
	61 | answerBit: reflect.TypeOf(AnswerNodeList{}),
	62:             reflect.TypeOf(SetNodeState{}),
	63:             reflect.TypeOf(AddPendingNodes{}),
	64:             reflect.TypeOf(TweakPartitionTable{}),
	65:             reflect.TypeOf(SetClusterState{}),
	66:             reflect.TypeOf(Repair{}),
	67:             reflect.TypeOf(RepairOne{}),
	68:             reflect.TypeOf(NotifyClusterState{}),
	69:             reflect.TypeOf(AskClusterState{}),
	70 | answerBit: reflect.TypeOf(AnswerClusterState{}),
	71:             reflect.TypeOf(ObjectUndoSerial{}),
	72 | answerBit: reflect.TypeOf(AnswerObjectUndoSerial{}),
	73:             reflect.TypeOf(CheckCurrentSerial{}),
	74:             reflect.TypeOf(Pack{}),
	75 | answerBit: reflect.TypeOf(AnswerPack{}),
	76:             reflect.TypeOf(CheckReplicas{}),
	77:             reflect.TypeOf(CheckPartition{}),
	78:             reflect.TypeOf(CheckTIDRange{}),
	79 | answerBit: reflect.TypeOf(AnswerCheckTIDRange{}),
	80:             reflect.TypeOf(CheckSerialRange{}),
	81 | answerBit: reflect.TypeOf(AnswerCheckSerialRange{}),
	82:             reflect.TypeOf(PartitionCorrupted{}),
	83:             reflect.TypeOf(LastTransaction{}),
	84 | answerBit: reflect.TypeOf(AnswerLastTransaction{}),
	85:             reflect.TypeOf(NotifyReady{}),
}
