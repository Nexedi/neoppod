// Code generated by protogen.go; DO NOT EDIT.

package neo

// protocol messages to/from wire marshalling.

import (
	"encoding/binary"
	"reflect"
	"sort"

	"lab.nexedi.com/kirr/go123/mem"
	"lab.nexedi.com/kirr/neo/go/zodb"
)

// messages marshalling

// 0 | answerBit. Error

func (*Error) neoMsgCode() uint16 {
	return 0 | answerBit
}

func (p *Error) neoMsgEncodedLen() int {
	return 8 + len(p.Message)
}

func (p *Error) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(p.Code))
	{
		l := uint32(len(p.Message))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Message)
		data = data[l:]
	}
}

func (p *Error) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.Code = ErrorCode(binary.BigEndian.Uint32(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint64(len(data)) < uint64(l) {
			goto overflow
		}
		nread += uint64(l)
		p.Message = string(data[:l])
		data = data[l:]
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 1. RequestIdentification

func (*RequestIdentification) neoMsgCode() uint16 {
	return 1
}

func (p *RequestIdentification) neoMsgEncodedLen() int {
	return 12 + p.Address.neoEncodedLen() + len(p.ClusterName) + p.IdTime.neoEncodedLen()
}

func (p *RequestIdentification) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.UUID)))
	{
		n := p.Address.neoEncode(data[8:])
		data = data[8+n:]
	}
	{
		l := uint32(len(p.ClusterName))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.ClusterName)
		data = data[l:]
	}
	{
		n := p.IdTime.neoEncode(data[0:])
		data = data[0+n:]
	}
}

func (p *RequestIdentification) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	p.UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
	data = data[8:]
	{
		n, ok := p.Address.neoDecode(data)
		if !ok {
			goto overflow
		}
		data = data[n:]
		nread += n
	}
	if uint64(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < uint64(l) {
			goto overflow
		}
		nread += uint64(l)
		p.ClusterName = string(data[:l])
		data = data[l:]
	}
	{
		n, ok := p.IdTime.neoDecode(data)
		if !ok {
			goto overflow
		}
		data = data[n:]
		nread += n
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 1 | answerBit. AcceptIdentification

func (*AcceptIdentification) neoMsgCode() uint16 {
	return 1 | answerBit
}

func (p *AcceptIdentification) neoMsgEncodedLen() int {
	return 20
}

func (p *AcceptIdentification) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.MyUUID)))
	binary.BigEndian.PutUint32(data[8:], p.NumPartitions)
	binary.BigEndian.PutUint32(data[12:], p.NumReplicas)
	binary.BigEndian.PutUint32(data[16:], uint32(int32(p.YourUUID)))
}

func (p *AcceptIdentification) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 20 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	p.MyUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
	p.NumPartitions = binary.BigEndian.Uint32(data[8:])
	p.NumReplicas = binary.BigEndian.Uint32(data[12:])
	p.YourUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[16:])))
	return 20, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 3. Ping

func (*Ping) neoMsgCode() uint16 {
	return 3
}

func (p *Ping) neoMsgEncodedLen() int {
	return 0
}

func (p *Ping) neoMsgEncode(data []byte) {
}

func (p *Ping) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 3 | answerBit. Pong

func (*Pong) neoMsgCode() uint16 {
	return 3 | answerBit
}

func (p *Pong) neoMsgEncodedLen() int {
	return 0
}

func (p *Pong) neoMsgEncode(data []byte) {
}

func (p *Pong) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 5. CloseClient

func (*CloseClient) neoMsgCode() uint16 {
	return 5
}

func (p *CloseClient) neoMsgEncodedLen() int {
	return 0
}

func (p *CloseClient) neoMsgEncode(data []byte) {
}

func (p *CloseClient) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 6. PrimaryMaster

func (*PrimaryMaster) neoMsgCode() uint16 {
	return 6
}

func (p *PrimaryMaster) neoMsgEncodedLen() int {
	return 0
}

func (p *PrimaryMaster) neoMsgEncode(data []byte) {
}

func (p *PrimaryMaster) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 6 | answerBit. AnswerPrimary

func (*AnswerPrimary) neoMsgCode() uint16 {
	return 6 | answerBit
}

func (p *AnswerPrimary) neoMsgEncodedLen() int {
	return 4
}

func (p *AnswerPrimary) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.PrimaryNodeUUID)))
}

func (p *AnswerPrimary) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 4 {
		goto overflow
	}
	p.PrimaryNodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 8. NotPrimaryMaster

func (*NotPrimaryMaster) neoMsgCode() uint16 {
	return 8
}

func (p *NotPrimaryMaster) neoMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.KnownMasterList); i++ {
		a := &p.KnownMasterList[i]
		size += (*a).neoEncodedLen()
	}
	return 8 + size
}

func (p *NotPrimaryMaster) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.Primary)))
	{
		l := uint32(len(p.KnownMasterList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.KnownMasterList[i]
			{
				n := (*a).neoEncode(data[0:])
				data = data[0+n:]
			}
			data = data[0:]
		}
	}
}

func (p *NotPrimaryMaster) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.Primary = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		p.KnownMasterList = make([]struct{ Address }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.KnownMasterList[i]
			{
				n, ok := (*a).neoDecode(data)
				if !ok {
					goto overflow
				}
				data = data[n:]
				nread += n
			}
		}
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 9. NotifyNodeInformation

func (*NotifyNodeInformation) neoMsgCode() uint16 {
	return 9
}

func (p *NotifyNodeInformation) neoMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.NodeList); i++ {
		a := &p.NodeList[i]
		size += (*a).Addr.neoEncodedLen() + (*a).IdTime.neoEncodedLen()
	}
	return 4 + p.IdTime.neoEncodedLen() + len(p.NodeList)*12 + size
}

func (p *NotifyNodeInformation) neoMsgEncode(data []byte) {
	{
		n := p.IdTime.neoEncode(data[0:])
		data = data[0+n:]
	}
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).Type)))
			{
				n := (*a).Addr.neoEncode(data[4:])
				data = data[4+n:]
			}
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
			binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).State)))
			{
				n := (*a).IdTime.neoEncode(data[8:])
				data = data[8+n:]
			}
			data = data[0:]
		}
	}
}

func (p *NotifyNodeInformation) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	{
		n, ok := p.IdTime.neoDecode(data)
		if !ok {
			goto overflow
		}
		data = data[n:]
		nread += n
	}
	if uint64(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		p.NodeList = make([]NodeInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			if uint64(len(data)) < 4 {
				goto overflow
			}
			(*a).Type = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
			{
				n, ok := (*a).Addr.neoDecode(data)
				if !ok {
					goto overflow
				}
				data = data[n:]
				nread += n
			}
			if uint64(len(data)) < 8 {
				goto overflow
			}
			(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			(*a).State = NodeState(int32(binary.BigEndian.Uint32(data[4:])))
			data = data[8:]
			{
				n, ok := (*a).IdTime.neoDecode(data)
				if !ok {
					goto overflow
				}
				data = data[n:]
				nread += n
			}
		}
		nread += uint64(l) * 12
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 10. Recovery

func (*Recovery) neoMsgCode() uint16 {
	return 10
}

func (p *Recovery) neoMsgEncodedLen() int {
	return 0
}

func (p *Recovery) neoMsgEncode(data []byte) {
}

func (p *Recovery) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 10 | answerBit. AnswerRecovery

func (*AnswerRecovery) neoMsgCode() uint16 {
	return 10 | answerBit
}

func (p *AnswerRecovery) neoMsgEncodedLen() int {
	return 24
}

func (p *AnswerRecovery) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.BackupTid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.TruncateTid))
}

func (p *AnswerRecovery) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 24 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	p.BackupTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.TruncateTid = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 12. LastIDs

func (*LastIDs) neoMsgCode() uint16 {
	return 12
}

func (p *LastIDs) neoMsgEncodedLen() int {
	return 0
}

func (p *LastIDs) neoMsgEncode(data []byte) {
}

func (p *LastIDs) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 12 | answerBit. AnswerLastIDs

func (*AnswerLastIDs) neoMsgCode() uint16 {
	return 12 | answerBit
}

func (p *AnswerLastIDs) neoMsgEncodedLen() int {
	return 16
}

func (p *AnswerLastIDs) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.LastOid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LastTid))
}

func (p *AnswerLastIDs) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 16 {
		goto overflow
	}
	p.LastOid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.LastTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 14. AskPartitionTable

func (*AskPartitionTable) neoMsgCode() uint16 {
	return 14
}

func (p *AskPartitionTable) neoMsgEncodedLen() int {
	return 0
}

func (p *AskPartitionTable) neoMsgEncode(data []byte) {
}

func (p *AskPartitionTable) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 14 | answerBit. AnswerPartitionTable

func (*AnswerPartitionTable) neoMsgCode() uint16 {
	return 14 | answerBit
}

func (p *AnswerPartitionTable) neoMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 12 + len(p.RowList)*8 + size
}

func (p *AnswerPartitionTable) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).State)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerPartitionTable) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint64(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint64(len(data)) < uint64(l)*8 {
					goto overflow
				}
				nread += uint64(l) * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).State = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += uint64(l) * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 16. SendPartitionTable

func (*SendPartitionTable) neoMsgCode() uint16 {
	return 16
}

func (p *SendPartitionTable) neoMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 12 + len(p.RowList)*8 + size
}

func (p *SendPartitionTable) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).State)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *SendPartitionTable) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint64(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint64(len(data)) < uint64(l)*8 {
					goto overflow
				}
				nread += uint64(l) * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).State = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += uint64(l) * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 17. NotifyPartitionChanges

func (*NotifyPartitionChanges) neoMsgCode() uint16 {
	return 17
}

func (p *NotifyPartitionChanges) neoMsgEncodedLen() int {
	return 12 + len(p.CellList)*12
}

func (p *NotifyPartitionChanges) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellInfo.UUID)))
			binary.BigEndian.PutUint32(data[8:], uint32(int32((*a).CellInfo.State)))
			data = data[12:]
		}
	}
}

func (p *NotifyPartitionChanges) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint64(len(data)) < uint64(l)*12 {
			goto overflow
		}
		nread += uint64(l) * 12
		p.CellList = make([]struct {
			Offset   uint32
			CellInfo CellInfo
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			(*a).CellInfo.UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
			(*a).CellInfo.State = CellState(int32(binary.BigEndian.Uint32(data[8:])))
			data = data[12:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 18. StartOperation

func (*StartOperation) neoMsgCode() uint16 {
	return 18
}

func (p *StartOperation) neoMsgEncodedLen() int {
	return 1
}

func (p *StartOperation) neoMsgEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Backup)
}

func (p *StartOperation) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 1 {
		goto overflow
	}
	p.Backup = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 19. StopOperation

func (*StopOperation) neoMsgCode() uint16 {
	return 19
}

func (p *StopOperation) neoMsgEncodedLen() int {
	return 0
}

func (p *StopOperation) neoMsgEncode(data []byte) {
}

func (p *StopOperation) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 20. UnfinishedTransactions

func (*UnfinishedTransactions) neoMsgCode() uint16 {
	return 20
}

func (p *UnfinishedTransactions) neoMsgEncodedLen() int {
	return 4 + len(p.RowList)*4
}

func (p *UnfinishedTransactions) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			data = data[4:]
		}
	}
}

func (p *UnfinishedTransactions) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*4 {
			goto overflow
		}
		nread += uint64(l) * 4
		p.RowList = make([]struct{ Offset uint32 }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 20 | answerBit. AnswerUnfinishedTransactions

func (*AnswerUnfinishedTransactions) neoMsgCode() uint16 {
	return 20 | answerBit
}

func (p *AnswerUnfinishedTransactions) neoMsgEncodedLen() int {
	return 12 + len(p.TidList)*8
}

func (p *AnswerUnfinishedTransactions) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.MaxTID))
	{
		l := uint32(len(p.TidList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a).UnfinishedTID))
			data = data[8:]
		}
	}
}

func (p *AnswerUnfinishedTransactions) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.TidList = make([]struct{ UnfinishedTID zodb.Tid }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			(*a).UnfinishedTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 22. LockedTransactions

func (*LockedTransactions) neoMsgCode() uint16 {
	return 22
}

func (p *LockedTransactions) neoMsgEncodedLen() int {
	return 0
}

func (p *LockedTransactions) neoMsgEncode(data []byte) {
}

func (p *LockedTransactions) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 22 | answerBit. AnswerLockedTransactions

func (*AnswerLockedTransactions) neoMsgCode() uint16 {
	return 22 | answerBit
}

func (p *AnswerLockedTransactions) neoMsgEncodedLen() int {
	return 4 + len(p.TidDict)*16
}

func (p *AnswerLockedTransactions) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.TidDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]zodb.Tid, 0, l)
		for key := range p.TidDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			binary.BigEndian.PutUint64(data[8:], uint64(p.TidDict[key]))
			data = data[16:]
		}
	}
}

func (p *AnswerLockedTransactions) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*16 {
			goto overflow
		}
		nread += uint64(l) * 16
		p.TidDict = make(map[zodb.Tid]zodb.Tid, l)
		m := p.TidDict
		for i := 0; uint32(i) < l; i++ {
			key := zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			m[key] = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
			data = data[16:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 24. FinalTID

func (*FinalTID) neoMsgCode() uint16 {
	return 24
}

func (p *FinalTID) neoMsgEncodedLen() int {
	return 8
}

func (p *FinalTID) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
}

func (p *FinalTID) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 24 | answerBit. AnswerFinalTID

func (*AnswerFinalTID) neoMsgCode() uint16 {
	return 24 | answerBit
}

func (p *AnswerFinalTID) neoMsgEncodedLen() int {
	return 8
}

func (p *AnswerFinalTID) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerFinalTID) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 26. ValidateTransaction

func (*ValidateTransaction) neoMsgCode() uint16 {
	return 26
}

func (p *ValidateTransaction) neoMsgEncodedLen() int {
	return 16
}

func (p *ValidateTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *ValidateTransaction) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 16 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 27. BeginTransaction

func (*BeginTransaction) neoMsgCode() uint16 {
	return 27
}

func (p *BeginTransaction) neoMsgEncodedLen() int {
	return 8
}

func (p *BeginTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *BeginTransaction) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 27 | answerBit. AnswerBeginTransaction

func (*AnswerBeginTransaction) neoMsgCode() uint16 {
	return 27 | answerBit
}

func (p *AnswerBeginTransaction) neoMsgEncodedLen() int {
	return 8
}

func (p *AnswerBeginTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerBeginTransaction) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 29. FailedVote

func (*FailedVote) neoMsgCode() uint16 {
	return 29
}

func (p *FailedVote) neoMsgEncodedLen() int {
	return 12 + len(p.NodeList)*4
}

func (p *FailedVote) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *FailedVote) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint64(len(data)) < uint64(l)*4 {
			goto overflow
		}
		nread += uint64(l) * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 30. FinishTransaction

func (*FinishTransaction) neoMsgCode() uint16 {
	return 30
}

func (p *FinishTransaction) neoMsgEncodedLen() int {
	return 16 + len(p.OIDList)*8 + len(p.CheckedList)*8
}

func (p *FinishTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.OIDList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OIDList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
	{
		l := uint32(len(p.CheckedList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CheckedList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *FinishTransaction) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint64(len(data)) < 4+uint64(l)*8 {
			goto overflow
		}
		nread += 4 + uint64(l)*8
		p.OIDList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OIDList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.CheckedList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CheckedList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 30 | answerBit. AnswerTransactionFinished

func (*AnswerTransactionFinished) neoMsgCode() uint16 {
	return 30 | answerBit
}

func (p *AnswerTransactionFinished) neoMsgEncodedLen() int {
	return 16
}

func (p *AnswerTransactionFinished) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *AnswerTransactionFinished) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 32. LockInformation

func (*LockInformation) neoMsgCode() uint16 {
	return 32
}

func (p *LockInformation) neoMsgEncodedLen() int {
	return 16
}

func (p *LockInformation) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Ttid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *LockInformation) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 16 {
		goto overflow
	}
	p.Ttid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 32 | answerBit. AnswerInformationLocked

func (*AnswerInformationLocked) neoMsgCode() uint16 {
	return 32 | answerBit
}

func (p *AnswerInformationLocked) neoMsgEncodedLen() int {
	return 8
}

func (p *AnswerInformationLocked) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Ttid))
}

func (p *AnswerInformationLocked) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.Ttid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 34. InvalidateObjects

func (*InvalidateObjects) neoMsgCode() uint16 {
	return 34
}

func (p *InvalidateObjects) neoMsgEncodedLen() int {
	return 12 + len(p.OidList)*8
}

func (p *InvalidateObjects) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *InvalidateObjects) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 35. NotifyUnlockInformation

func (*NotifyUnlockInformation) neoMsgCode() uint16 {
	return 35
}

func (p *NotifyUnlockInformation) neoMsgEncodedLen() int {
	return 8
}

func (p *NotifyUnlockInformation) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
}

func (p *NotifyUnlockInformation) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 36. AskNewOIDs

func (*AskNewOIDs) neoMsgCode() uint16 {
	return 36
}

func (p *AskNewOIDs) neoMsgEncodedLen() int {
	return 4
}

func (p *AskNewOIDs) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.NumOIDs)
}

func (p *AskNewOIDs) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 4 {
		goto overflow
	}
	p.NumOIDs = binary.BigEndian.Uint32(data[0:])
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 36 | answerBit. AnswerNewOIDs

func (*AnswerNewOIDs) neoMsgCode() uint16 {
	return 36 | answerBit
}

func (p *AnswerNewOIDs) neoMsgEncodedLen() int {
	return 4 + len(p.OidList)*8
}

func (p *AnswerNewOIDs) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerNewOIDs) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 38. NotifyDeadlock

func (*NotifyDeadlock) neoMsgCode() uint16 {
	return 38
}

func (p *NotifyDeadlock) neoMsgEncodedLen() int {
	return 16
}

func (p *NotifyDeadlock) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LockingTid))
}

func (p *NotifyDeadlock) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LockingTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 39. RebaseTransaction

func (*RebaseTransaction) neoMsgCode() uint16 {
	return 39
}

func (p *RebaseTransaction) neoMsgEncodedLen() int {
	return 16
}

func (p *RebaseTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LockingTid))
}

func (p *RebaseTransaction) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LockingTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 39 | answerBit. AnswerRebaseTransaction

func (*AnswerRebaseTransaction) neoMsgCode() uint16 {
	return 39 | answerBit
}

func (p *AnswerRebaseTransaction) neoMsgEncodedLen() int {
	return 4 + len(p.OidList)*8
}

func (p *AnswerRebaseTransaction) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerRebaseTransaction) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 41. RebaseObject

func (*RebaseObject) neoMsgCode() uint16 {
	return 41
}

func (p *RebaseObject) neoMsgEncodedLen() int {
	return 16
}

func (p *RebaseObject) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Oid))
}

func (p *RebaseObject) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 41 | answerBit. AnswerRebaseObject

func (*AnswerRebaseObject) neoMsgCode() uint16 {
	return 41 | answerBit
}

func (p *AnswerRebaseObject) neoMsgEncodedLen() int {
	return 41 + len(p.Data)
}

func (p *AnswerRebaseObject) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[8:], uint64(p.ConflictSerial))
	(data[16:])[0] = bool2byte(p.Compression)
	copy(data[17:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		copy(data, p.Data)
		data = data[l:]
	}
}

func (p *AnswerRebaseObject) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 41 {
		goto overflow
	}
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.ConflictSerial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Compression = byte2bool((data[16:])[0])
	copy(p.Checksum[:], data[17:37])
	{
		l := binary.BigEndian.Uint32(data[37:])
		data = data[41:]
		if uint64(len(data)) < uint64(l) {
			goto overflow
		}
		nread += uint64(l)
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	return 41 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 43. StoreObject

func (*StoreObject) neoMsgCode() uint16 {
	return 43
}

func (p *StoreObject) neoMsgEncodedLen() int {
	return 57 + len(p.Data)
}

func (p *StoreObject) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	(data[16:])[0] = bool2byte(p.Compression)
	copy(data[17:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		copy(data, p.Data)
		data = data[l:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *StoreObject) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 41 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Compression = byte2bool((data[16:])[0])
	copy(p.Checksum[:], data[17:37])
	{
		l := binary.BigEndian.Uint32(data[37:])
		data = data[41:]
		if uint64(len(data)) < 16+uint64(l) {
			goto overflow
		}
		nread += 16 + uint64(l)
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	p.DataSerial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 41 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 43 | answerBit. AnswerStoreObject

func (*AnswerStoreObject) neoMsgCode() uint16 {
	return 43 | answerBit
}

func (p *AnswerStoreObject) neoMsgEncodedLen() int {
	return 8
}

func (p *AnswerStoreObject) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Conflict))
}

func (p *AnswerStoreObject) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.Conflict = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 45. AbortTransaction

func (*AbortTransaction) neoMsgCode() uint16 {
	return 45
}

func (p *AbortTransaction) neoMsgEncodedLen() int {
	return 12 + len(p.NodeList)*4
}

func (p *AbortTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *AbortTransaction) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint64(len(data)) < uint64(l)*4 {
			goto overflow
		}
		nread += uint64(l) * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 46. StoreTransaction

func (*StoreTransaction) neoMsgCode() uint16 {
	return 46
}

func (p *StoreTransaction) neoMsgEncodedLen() int {
	return 24 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *StoreTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *StoreTransaction) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.User = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.Description = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.Extension = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 46 | answerBit. AnswerStoreTransaction

func (*AnswerStoreTransaction) neoMsgCode() uint16 {
	return 46 | answerBit
}

func (p *AnswerStoreTransaction) neoMsgEncodedLen() int {
	return 0
}

func (p *AnswerStoreTransaction) neoMsgEncode(data []byte) {
}

func (p *AnswerStoreTransaction) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 48. VoteTransaction

func (*VoteTransaction) neoMsgCode() uint16 {
	return 48
}

func (p *VoteTransaction) neoMsgEncodedLen() int {
	return 8
}

func (p *VoteTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *VoteTransaction) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 48 | answerBit. AnswerVoteTransaction

func (*AnswerVoteTransaction) neoMsgCode() uint16 {
	return 48 | answerBit
}

func (p *AnswerVoteTransaction) neoMsgEncodedLen() int {
	return 0
}

func (p *AnswerVoteTransaction) neoMsgEncode(data []byte) {
}

func (p *AnswerVoteTransaction) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 50. GetObject

func (*GetObject) neoMsgCode() uint16 {
	return 50
}

func (p *GetObject) neoMsgEncodedLen() int {
	return 24
}

func (p *GetObject) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[16:], uint64(p.Tid))
}

func (p *GetObject) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 24 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 50 | answerBit. AnswerObject

func (*AnswerObject) neoMsgCode() uint16 {
	return 50 | answerBit
}

func (p *AnswerObject) neoMsgEncodedLen() int {
	return 57 + len(p.Data.XData())
}

func (p *AnswerObject) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[16:], uint64(p.NextSerial))
	(data[24:])[0] = bool2byte(p.Compression)
	copy(data[25:], p.Checksum[:])
	{
		l := uint32(len(p.Data.XData()))
		binary.BigEndian.PutUint32(data[45:], l)
		data = data[49:]
		copy(data, p.Data.XData())
		data = data[l:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
}

func (p *AnswerObject) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 49 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.NextSerial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	p.Compression = byte2bool((data[24:])[0])
	copy(p.Checksum[:], data[25:45])
	{
		l := binary.BigEndian.Uint32(data[45:])
		data = data[49:]
		if uint64(len(data)) < 8+uint64(l) {
			goto overflow
		}
		nread += 8 + uint64(l)
		p.Data = mem.BufAlloc(int(l))
		copy(p.Data.Data, data[:l])
		data = data[l:]
	}
	p.DataSerial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 49 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 52. AskTIDs

func (*AskTIDs) neoMsgCode() uint16 {
	return 52
}

func (p *AskTIDs) neoMsgEncodedLen() int {
	return 20
}

func (p *AskTIDs) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], p.First)
	binary.BigEndian.PutUint64(data[8:], p.Last)
	binary.BigEndian.PutUint32(data[16:], p.Partition)
}

func (p *AskTIDs) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 20 {
		goto overflow
	}
	p.First = binary.BigEndian.Uint64(data[0:])
	p.Last = binary.BigEndian.Uint64(data[8:])
	p.Partition = binary.BigEndian.Uint32(data[16:])
	return 20, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 52 | answerBit. AnswerTIDs

func (*AnswerTIDs) neoMsgCode() uint16 {
	return 52 | answerBit
}

func (p *AnswerTIDs) neoMsgEncodedLen() int {
	return 4 + len(p.TIDList)*8
}

func (p *AnswerTIDs) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.TIDList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TIDList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTIDs) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.TIDList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TIDList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 54. TransactionInformation

func (*TransactionInformation) neoMsgCode() uint16 {
	return 54
}

func (p *TransactionInformation) neoMsgEncodedLen() int {
	return 8
}

func (p *TransactionInformation) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *TransactionInformation) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 54 | answerBit. AnswerTransactionInformation

func (*AnswerTransactionInformation) neoMsgCode() uint16 {
	return 54 | answerBit
}

func (p *AnswerTransactionInformation) neoMsgEncodedLen() int {
	return 25 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *AnswerTransactionInformation) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	(data[0:])[0] = bool2byte(p.Packed)
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[1:], l)
		data = data[5:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTransactionInformation) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.User = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.Description = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < 5+uint64(l) {
			goto overflow
		}
		nread += 5 + uint64(l)
		p.Extension = string(data[:l])
		data = data[l:]
	}
	p.Packed = byte2bool((data[0:])[0])
	{
		l := binary.BigEndian.Uint32(data[1:])
		data = data[5:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 56. ObjectHistory

func (*ObjectHistory) neoMsgCode() uint16 {
	return 56
}

func (p *ObjectHistory) neoMsgEncodedLen() int {
	return 24
}

func (p *ObjectHistory) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], p.First)
	binary.BigEndian.PutUint64(data[16:], p.Last)
}

func (p *ObjectHistory) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 24 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.First = binary.BigEndian.Uint64(data[8:])
	p.Last = binary.BigEndian.Uint64(data[16:])
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 56 | answerBit. AnswerObjectHistory

func (*AnswerObjectHistory) neoMsgCode() uint16 {
	return 56 | answerBit
}

func (p *AnswerObjectHistory) neoMsgEncodedLen() int {
	return 12 + len(p.HistoryList)*12
}

func (p *AnswerObjectHistory) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	{
		l := uint32(len(p.HistoryList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.HistoryList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a).Serial))
			binary.BigEndian.PutUint32(data[8:], (*a).Size)
			data = data[12:]
		}
	}
}

func (p *AnswerObjectHistory) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint64(len(data)) < uint64(l)*12 {
			goto overflow
		}
		nread += uint64(l) * 12
		p.HistoryList = make([]struct {
			Serial zodb.Tid
			Size   uint32
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.HistoryList[i]
			(*a).Serial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			(*a).Size = binary.BigEndian.Uint32(data[8:])
			data = data[12:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 58. PartitionList

func (*PartitionList) neoMsgCode() uint16 {
	return 58
}

func (p *PartitionList) neoMsgEncodedLen() int {
	return 12
}

func (p *PartitionList) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.MinOffset)
	binary.BigEndian.PutUint32(data[4:], p.MaxOffset)
	binary.BigEndian.PutUint32(data[8:], uint32(int32(p.NodeUUID)))
}

func (p *PartitionList) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.MinOffset = binary.BigEndian.Uint32(data[0:])
	p.MaxOffset = binary.BigEndian.Uint32(data[4:])
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[8:])))
	return 12, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 58 | answerBit. AnswerPartitionList

func (*AnswerPartitionList) neoMsgCode() uint16 {
	return 58 | answerBit
}

func (p *AnswerPartitionList) neoMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 8
	}
	return 12 + len(p.RowList)*8 + size
}

func (p *AnswerPartitionList) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).State)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerPartitionList) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if uint64(len(data)) < 8 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint64(len(data)) < uint64(l)*8 {
					goto overflow
				}
				nread += uint64(l) * 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
					(*a).State = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
				}
			}
		}
		nread += uint64(l) * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 60. NodeList

func (*NodeList) neoMsgCode() uint16 {
	return 60
}

func (p *NodeList) neoMsgEncodedLen() int {
	return 4
}

func (p *NodeList) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
}

func (p *NodeList) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 4 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 60 | answerBit. AnswerNodeList

func (*AnswerNodeList) neoMsgCode() uint16 {
	return 60 | answerBit
}

func (p *AnswerNodeList) neoMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.NodeList); i++ {
		a := &p.NodeList[i]
		size += (*a).Addr.neoEncodedLen() + (*a).IdTime.neoEncodedLen()
	}
	return 4 + len(p.NodeList)*12 + size
}

func (p *AnswerNodeList) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).Type)))
			{
				n := (*a).Addr.neoEncode(data[4:])
				data = data[4+n:]
			}
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
			binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).State)))
			{
				n := (*a).IdTime.neoEncode(data[8:])
				data = data[8+n:]
			}
			data = data[0:]
		}
	}
}

func (p *AnswerNodeList) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		p.NodeList = make([]NodeInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			if uint64(len(data)) < 4 {
				goto overflow
			}
			(*a).Type = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
			{
				n, ok := (*a).Addr.neoDecode(data)
				if !ok {
					goto overflow
				}
				data = data[n:]
				nread += n
			}
			if uint64(len(data)) < 8 {
				goto overflow
			}
			(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			(*a).State = NodeState(int32(binary.BigEndian.Uint32(data[4:])))
			data = data[8:]
			{
				n, ok := (*a).IdTime.neoDecode(data)
				if !ok {
					goto overflow
				}
				data = data[n:]
				nread += n
			}
		}
		nread += uint64(l) * 12
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 62. SetNodeState

func (*SetNodeState) neoMsgCode() uint16 {
	return 62
}

func (p *SetNodeState) neoMsgEncodedLen() int {
	return 8
}

func (p *SetNodeState) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeUUID)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.NodeState)))
}

func (p *SetNodeState) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
	p.NodeState = NodeState(int32(binary.BigEndian.Uint32(data[4:])))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 63. AddPendingNodes

func (*AddPendingNodes) neoMsgCode() uint16 {
	return 63
}

func (p *AddPendingNodes) neoMsgEncodedLen() int {
	return 4 + len(p.NodeList)*4
}

func (p *AddPendingNodes) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *AddPendingNodes) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*4 {
			goto overflow
		}
		nread += uint64(l) * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 64. TweakPartitionTable

func (*TweakPartitionTable) neoMsgCode() uint16 {
	return 64
}

func (p *TweakPartitionTable) neoMsgEncodedLen() int {
	return 4 + len(p.NodeList)*4
}

func (p *TweakPartitionTable) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *TweakPartitionTable) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*4 {
			goto overflow
		}
		nread += uint64(l) * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 65. SetClusterState

func (*SetClusterState) neoMsgCode() uint16 {
	return 65
}

func (p *SetClusterState) neoMsgEncodedLen() int {
	return 4
}

func (p *SetClusterState) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *SetClusterState) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 66. Repair

func (*Repair) neoMsgCode() uint16 {
	return 66
}

func (p *Repair) neoMsgEncodedLen() int {
	return 5 + len(p.NodeList)*4
}

func (p *Repair) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
	(data[0:])[0] = bool2byte(p.repairFlags.DryRun)
}

func (p *Repair) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < 1+uint64(l)*4 {
			goto overflow
		}
		nread += 1 + uint64(l)*4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	p.repairFlags.DryRun = byte2bool((data[0:])[0])
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 67. RepairOne

func (*RepairOne) neoMsgCode() uint16 {
	return 67
}

func (p *RepairOne) neoMsgEncodedLen() int {
	return 1
}

func (p *RepairOne) neoMsgEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.repairFlags.DryRun)
}

func (p *RepairOne) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 1 {
		goto overflow
	}
	p.repairFlags.DryRun = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 68. NotifyClusterState

func (*NotifyClusterState) neoMsgCode() uint16 {
	return 68
}

func (p *NotifyClusterState) neoMsgEncodedLen() int {
	return 4
}

func (p *NotifyClusterState) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *NotifyClusterState) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 69. AskClusterState

func (*AskClusterState) neoMsgCode() uint16 {
	return 69
}

func (p *AskClusterState) neoMsgEncodedLen() int {
	return 0
}

func (p *AskClusterState) neoMsgEncode(data []byte) {
}

func (p *AskClusterState) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 69 | answerBit. AnswerClusterState

func (*AnswerClusterState) neoMsgCode() uint16 {
	return 69 | answerBit
}

func (p *AnswerClusterState) neoMsgEncodedLen() int {
	return 4
}

func (p *AnswerClusterState) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *AnswerClusterState) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 71. ObjectUndoSerial

func (*ObjectUndoSerial) neoMsgCode() uint16 {
	return 71
}

func (p *ObjectUndoSerial) neoMsgEncodedLen() int {
	return 28 + len(p.OidList)*8
}

func (p *ObjectUndoSerial) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.UndoneTID))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[24:], l)
		data = data[28:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *ObjectUndoSerial) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 28 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.LTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.UndoneTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	{
		l := binary.BigEndian.Uint32(data[24:])
		data = data[28:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 28 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 71 | answerBit. AnswerObjectUndoSerial

func (*AnswerObjectUndoSerial) neoMsgCode() uint16 {
	return 71 | answerBit
}

func (p *AnswerObjectUndoSerial) neoMsgEncodedLen() int {
	return 4 + len(p.ObjectTIDDict)*25
}

func (p *AnswerObjectUndoSerial) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.ObjectTIDDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]zodb.Oid, 0, l)
		for key := range p.ObjectTIDDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			binary.BigEndian.PutUint64(data[8:], uint64(p.ObjectTIDDict[key].CurrentSerial))
			binary.BigEndian.PutUint64(data[16:], uint64(p.ObjectTIDDict[key].UndoSerial))
			(data[24:])[0] = bool2byte(p.ObjectTIDDict[key].IsCurrent)
			data = data[25:]
		}
	}
}

func (p *AnswerObjectUndoSerial) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*25 {
			goto overflow
		}
		nread += uint64(l) * 25
		p.ObjectTIDDict = make(map[zodb.Oid]struct {
			CurrentSerial zodb.Tid
			UndoSerial    zodb.Tid
			IsCurrent     bool
		}, l)
		m := p.ObjectTIDDict
		for i := 0; uint32(i) < l; i++ {
			key := zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			var v struct {
				CurrentSerial zodb.Tid
				UndoSerial    zodb.Tid
				IsCurrent     bool
			}
			v.CurrentSerial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
			v.UndoSerial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
			v.IsCurrent = byte2bool((data[24:])[0])
			m[key] = v
			data = data[25:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 73. AskTIDsFrom

func (*AskTIDsFrom) neoMsgCode() uint16 {
	return 73
}

func (p *AskTIDsFrom) neoMsgEncodedLen() int {
	return 24
}

func (p *AskTIDsFrom) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
	binary.BigEndian.PutUint32(data[16:], p.Length)
	binary.BigEndian.PutUint32(data[20:], p.Partition)
}

func (p *AskTIDsFrom) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 24 {
		goto overflow
	}
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Length = binary.BigEndian.Uint32(data[16:])
	p.Partition = binary.BigEndian.Uint32(data[20:])
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 73 | answerBit. AnswerTIDsFrom

func (*AnswerTIDsFrom) neoMsgCode() uint16 {
	return 73 | answerBit
}

func (p *AnswerTIDsFrom) neoMsgEncodedLen() int {
	return 4 + len(p.TidList)*8
}

func (p *AnswerTIDsFrom) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.TidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTIDsFrom) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.TidList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 75. Pack

func (*Pack) neoMsgCode() uint16 {
	return 75
}

func (p *Pack) neoMsgEncodedLen() int {
	return 8
}

func (p *Pack) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *Pack) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 75 | answerBit. AnswerPack

func (*AnswerPack) neoMsgCode() uint16 {
	return 75 | answerBit
}

func (p *AnswerPack) neoMsgEncodedLen() int {
	return 1
}

func (p *AnswerPack) neoMsgEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Status)
}

func (p *AnswerPack) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 1 {
		goto overflow
	}
	p.Status = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 77. CheckReplicas

func (*CheckReplicas) neoMsgCode() uint16 {
	return 77
}

func (p *CheckReplicas) neoMsgEncodedLen() int {
	return 20 + len(p.PartitionDict)*8
}

func (p *CheckReplicas) neoMsgEncode(data []byte) {
	{
		l := uint32(len(p.PartitionDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]uint32, 0, l)
		for key := range p.PartitionDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint32(data[0:], key)
			binary.BigEndian.PutUint32(data[4:], uint32(int32(p.PartitionDict[key])))
			data = data[8:]
		}
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *CheckReplicas) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < 16+uint64(l)*8 {
			goto overflow
		}
		nread += 16 + uint64(l)*8
		p.PartitionDict = make(map[uint32]NodeUUID, l)
		m := p.PartitionDict
		for i := 0; uint32(i) < l; i++ {
			key := binary.BigEndian.Uint32(data[0:])
			m[key] = NodeUUID(int32(binary.BigEndian.Uint32(data[4:])))
			data = data[8:]
		}
	}
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 78. CheckPartition

func (*CheckPartition) neoMsgCode() uint16 {
	return 78
}

func (p *CheckPartition) neoMsgEncodedLen() int {
	return 24 + len(p.Source.UpstreamName) + p.Source.Address.neoEncodedLen()
}

func (p *CheckPartition) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	{
		l := uint32(len(p.Source.UpstreamName))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Source.UpstreamName)
		data = data[l:]
	}
	{
		n := p.Source.Address.neoEncode(data[0:])
		data = data[0+n:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *CheckPartition) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint64(len(data)) < uint64(l) {
			goto overflow
		}
		nread += uint64(l)
		p.Source.UpstreamName = string(data[:l])
		data = data[l:]
	}
	{
		n, ok := p.Source.Address.neoDecode(data)
		if !ok {
			goto overflow
		}
		data = data[n:]
		nread += n
	}
	if uint64(len(data)) < 16 {
		goto overflow
	}
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 24 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 79. CheckTIDRange

func (*CheckTIDRange) neoMsgCode() uint16 {
	return 79
}

func (p *CheckTIDRange) neoMsgEncodedLen() int {
	return 24
}

func (p *CheckTIDRange) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTID))
}

func (p *CheckTIDRange) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 24 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	p.Length = binary.BigEndian.Uint32(data[4:])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 79 | answerBit. AnswerCheckTIDRange

func (*AnswerCheckTIDRange) neoMsgCode() uint16 {
	return 79 | answerBit
}

func (p *AnswerCheckTIDRange) neoMsgEncodedLen() int {
	return 32
}

func (p *AnswerCheckTIDRange) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Count)
	copy(data[4:], p.Checksum[:])
	binary.BigEndian.PutUint64(data[24:], uint64(p.MaxTID))
}

func (p *AnswerCheckTIDRange) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 32 {
		goto overflow
	}
	p.Count = binary.BigEndian.Uint32(data[0:])
	copy(p.Checksum[:], data[4:24])
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[24:]))
	return 32, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 81. CheckSerialRange

func (*CheckSerialRange) neoMsgCode() uint16 {
	return 81
}

func (p *CheckSerialRange) neoMsgEncodedLen() int {
	return 32
}

func (p *CheckSerialRange) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTID))
	binary.BigEndian.PutUint64(data[24:], uint64(p.MinOID))
}

func (p *CheckSerialRange) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 32 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	p.Length = binary.BigEndian.Uint32(data[4:])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	p.MinOID = zodb.Oid(binary.BigEndian.Uint64(data[24:]))
	return 32, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 81 | answerBit. AnswerCheckSerialRange

func (*AnswerCheckSerialRange) neoMsgCode() uint16 {
	return 81 | answerBit
}

func (p *AnswerCheckSerialRange) neoMsgEncodedLen() int {
	return 60
}

func (p *AnswerCheckSerialRange) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Count)
	copy(data[4:], p.TidChecksum[:])
	binary.BigEndian.PutUint64(data[24:], uint64(p.MaxTID))
	copy(data[32:], p.OidChecksum[:])
	binary.BigEndian.PutUint64(data[52:], uint64(p.MaxOID))
}

func (p *AnswerCheckSerialRange) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 60 {
		goto overflow
	}
	p.Count = binary.BigEndian.Uint32(data[0:])
	copy(p.TidChecksum[:], data[4:24])
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[24:]))
	copy(p.OidChecksum[:], data[32:52])
	p.MaxOID = zodb.Oid(binary.BigEndian.Uint64(data[52:]))
	return 60, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 83. PartitionCorrupted

func (*PartitionCorrupted) neoMsgCode() uint16 {
	return 83
}

func (p *PartitionCorrupted) neoMsgEncodedLen() int {
	return 8 + len(p.CellList)*4
}

func (p *PartitionCorrupted) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *PartitionCorrupted) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	{
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint64(len(data)) < uint64(l)*4 {
			goto overflow
		}
		nread += uint64(l) * 4
		p.CellList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
		}
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 84. NotifyReady

func (*NotifyReady) neoMsgCode() uint16 {
	return 84
}

func (p *NotifyReady) neoMsgEncodedLen() int {
	return 0
}

func (p *NotifyReady) neoMsgEncode(data []byte) {
}

func (p *NotifyReady) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 85. LastTransaction

func (*LastTransaction) neoMsgCode() uint16 {
	return 85
}

func (p *LastTransaction) neoMsgEncodedLen() int {
	return 0
}

func (p *LastTransaction) neoMsgEncode(data []byte) {
}

func (p *LastTransaction) neoMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 85 | answerBit. AnswerLastTransaction

func (*AnswerLastTransaction) neoMsgCode() uint16 {
	return 85 | answerBit
}

func (p *AnswerLastTransaction) neoMsgEncodedLen() int {
	return 8
}

func (p *AnswerLastTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerLastTransaction) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 87. CheckCurrentSerial

func (*CheckCurrentSerial) neoMsgCode() uint16 {
	return 87
}

func (p *CheckCurrentSerial) neoMsgEncodedLen() int {
	return 24
}

func (p *CheckCurrentSerial) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.Serial))
}

func (p *CheckCurrentSerial) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 24 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[8:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 87 | answerBit. AnswerCheckCurrentSerial

func (*AnswerCheckCurrentSerial) neoMsgCode() uint16 {
	return 87 | answerBit
}

func (p *AnswerCheckCurrentSerial) neoMsgEncodedLen() int {
	return 8
}

func (p *AnswerCheckCurrentSerial) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.AnswerStoreObject.Conflict))
}

func (p *AnswerCheckCurrentSerial) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.AnswerStoreObject.Conflict = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 89. NotifyTransactionFinished

func (*NotifyTransactionFinished) neoMsgCode() uint16 {
	return 89
}

func (p *NotifyTransactionFinished) neoMsgEncodedLen() int {
	return 16
}

func (p *NotifyTransactionFinished) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *NotifyTransactionFinished) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 16 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 90. Replicate

func (*Replicate) neoMsgCode() uint16 {
	return 90
}

func (p *Replicate) neoMsgEncodedLen() int {
	var size int
	for key := range p.SourceDict {
		size += len(p.SourceDict[key])
	}
	return 16 + len(p.UpstreamName) + len(p.SourceDict)*8 + size
}

func (p *Replicate) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.UpstreamName))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.UpstreamName)
		data = data[l:]
	}
	{
		l := uint32(len(p.SourceDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]uint32, 0, l)
		for key := range p.SourceDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint32(data[0:], key)
			{
				l := uint32(len(p.SourceDict[key]))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				copy(data, p.SourceDict[key])
				data = data[l:]
			}
			data = data[0:]
		}
	}
}

func (p *Replicate) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.UpstreamName = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		p.SourceDict = make(map[uint32]string, l)
		m := p.SourceDict
		for i := 0; uint32(i) < l; i++ {
			if uint64(len(data)) < 8 {
				goto overflow
			}
			key := binary.BigEndian.Uint32(data[0:])
			{
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint64(len(data)) < uint64(l) {
					goto overflow
				}
				nread += uint64(l)
				m[key] = string(data[:l])
				data = data[l:]
			}
		}
		nread += uint64(l) * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 91. ReplicationDone

func (*ReplicationDone) neoMsgCode() uint16 {
	return 91
}

func (p *ReplicationDone) neoMsgEncodedLen() int {
	return 12
}

func (p *ReplicationDone) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Offset)
	binary.BigEndian.PutUint64(data[4:], uint64(p.Tid))
}

func (p *ReplicationDone) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.Offset = binary.BigEndian.Uint32(data[0:])
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[4:]))
	return 12, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 92. FetchTransactions

func (*FetchTransactions) neoMsgCode() uint16 {
	return 92
}

func (p *FetchTransactions) neoMsgEncodedLen() int {
	return 28 + len(p.TxnKnownList)*8
}

func (p *FetchTransactions) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTid))
	{
		l := uint32(len(p.TxnKnownList))
		binary.BigEndian.PutUint32(data[24:], l)
		data = data[28:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TxnKnownList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *FetchTransactions) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 28 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	p.Length = binary.BigEndian.Uint32(data[4:])
	p.MinTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.MaxTid = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	{
		l := binary.BigEndian.Uint32(data[24:])
		data = data[28:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.TxnKnownList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TxnKnownList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 28 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 92 | answerBit. AnswerFetchTransactions

func (*AnswerFetchTransactions) neoMsgCode() uint16 {
	return 92 | answerBit
}

func (p *AnswerFetchTransactions) neoMsgEncodedLen() int {
	return 20 + len(p.TxnDeleteList)*8
}

func (p *AnswerFetchTransactions) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PackTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.NextTid))
	{
		l := uint32(len(p.TxnDeleteList))
		binary.BigEndian.PutUint32(data[16:], l)
		data = data[20:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TxnDeleteList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerFetchTransactions) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 20 {
		goto overflow
	}
	p.PackTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.NextTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	{
		l := binary.BigEndian.Uint32(data[16:])
		data = data[20:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.TxnDeleteList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TxnDeleteList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 20 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 94. FetchObjects

func (*FetchObjects) neoMsgCode() uint16 {
	return 94
}

func (p *FetchObjects) neoMsgEncodedLen() int {
	var size int
	for key := range p.ObjKnownDict {
		size += len(p.ObjKnownDict[key]) * 8
	}
	return 36 + len(p.ObjKnownDict)*12 + size
}

func (p *FetchObjects) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTid))
	binary.BigEndian.PutUint64(data[24:], uint64(p.MinOid))
	{
		l := uint32(len(p.ObjKnownDict))
		binary.BigEndian.PutUint32(data[32:], l)
		data = data[36:]
		keyv := make([]zodb.Tid, 0, l)
		for key := range p.ObjKnownDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			{
				l := uint32(len(p.ObjKnownDict[key]))
				binary.BigEndian.PutUint32(data[8:], l)
				data = data[12:]
				for i := 0; uint32(i) < l; i++ {
					a := &p.ObjKnownDict[key][i]
					binary.BigEndian.PutUint64(data[0:], uint64((*a)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *FetchObjects) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 36 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	p.Length = binary.BigEndian.Uint32(data[4:])
	p.MinTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.MaxTid = zodb.Tid(binary.BigEndian.Uint64(data[16:]))
	p.MinOid = zodb.Oid(binary.BigEndian.Uint64(data[24:]))
	{
		l := binary.BigEndian.Uint32(data[32:])
		data = data[36:]
		p.ObjKnownDict = make(map[zodb.Tid][]zodb.Oid, l)
		m := p.ObjKnownDict
		for i := 0; uint32(i) < l; i++ {
			if uint64(len(data)) < 12 {
				goto overflow
			}
			key := zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			var v []zodb.Oid
			{
				l := binary.BigEndian.Uint32(data[8:])
				data = data[12:]
				if uint64(len(data)) < uint64(l)*8 {
					goto overflow
				}
				nread += uint64(l) * 8
				v = make([]zodb.Oid, l)
				for i := 0; uint32(i) < l; i++ {
					a := &v[i]
					(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
					data = data[8:]
				}
			}
			m[key] = v
		}
		nread += uint64(l) * 12
	}
	return 36 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 94 | answerBit. AnswerFetchObjects

func (*AnswerFetchObjects) neoMsgCode() uint16 {
	return 94 | answerBit
}

func (p *AnswerFetchObjects) neoMsgEncodedLen() int {
	var size int
	for key := range p.ObjDeleteDict {
		size += len(p.ObjDeleteDict[key]) * 8
	}
	return 28 + len(p.ObjDeleteDict)*12 + size
}

func (p *AnswerFetchObjects) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PackTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.NextTid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.NextOid))
	{
		l := uint32(len(p.ObjDeleteDict))
		binary.BigEndian.PutUint32(data[24:], l)
		data = data[28:]
		keyv := make([]zodb.Tid, 0, l)
		for key := range p.ObjDeleteDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			{
				l := uint32(len(p.ObjDeleteDict[key]))
				binary.BigEndian.PutUint32(data[8:], l)
				data = data[12:]
				for i := 0; uint32(i) < l; i++ {
					a := &p.ObjDeleteDict[key][i]
					binary.BigEndian.PutUint64(data[0:], uint64((*a)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerFetchObjects) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 28 {
		goto overflow
	}
	p.PackTid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	p.NextTid = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.NextOid = zodb.Oid(binary.BigEndian.Uint64(data[16:]))
	{
		l := binary.BigEndian.Uint32(data[24:])
		data = data[28:]
		p.ObjDeleteDict = make(map[zodb.Tid][]zodb.Oid, l)
		m := p.ObjDeleteDict
		for i := 0; uint32(i) < l; i++ {
			if uint64(len(data)) < 12 {
				goto overflow
			}
			key := zodb.Tid(binary.BigEndian.Uint64(data[0:]))
			var v []zodb.Oid
			{
				l := binary.BigEndian.Uint32(data[8:])
				data = data[12:]
				if uint64(len(data)) < uint64(l)*8 {
					goto overflow
				}
				nread += uint64(l) * 8
				v = make([]zodb.Oid, l)
				for i := 0; uint32(i) < l; i++ {
					a := &v[i]
					(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
					data = data[8:]
				}
			}
			m[key] = v
		}
		nread += uint64(l) * 12
	}
	return 28 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 96. AddTransaction

func (*AddTransaction) neoMsgCode() uint16 {
	return 96
}

func (p *AddTransaction) neoMsgEncodedLen() int {
	return 33 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *AddTransaction) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	(data[0:])[0] = bool2byte(p.Packed)
	binary.BigEndian.PutUint64(data[1:], uint64(p.TTid))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[9:], l)
		data = data[13:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AddTransaction) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	{
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.User = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.Description = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint64(len(data)) < 13+uint64(l) {
			goto overflow
		}
		nread += 13 + uint64(l)
		p.Extension = string(data[:l])
		data = data[l:]
	}
	p.Packed = byte2bool((data[0:])[0])
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[1:]))
	{
		l := binary.BigEndian.Uint32(data[9:])
		data = data[13:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 97. AddObject

func (*AddObject) neoMsgCode() uint16 {
	return 97
}

func (p *AddObject) neoMsgEncodedLen() int {
	return 49 + len(p.Data)
}

func (p *AddObject) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	(data[16:])[0] = bool2byte(p.Compression)
	copy(data[17:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		copy(data, p.Data)
		data = data[l:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
}

func (p *AddObject) neoMsgDecode(data []byte) (int, error) {
	var nread uint64
	if uint64(len(data)) < 41 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0:]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8:]))
	p.Compression = byte2bool((data[16:])[0])
	copy(p.Checksum[:], data[17:37])
	{
		l := binary.BigEndian.Uint32(data[37:])
		data = data[41:]
		if uint64(len(data)) < 8+uint64(l) {
			goto overflow
		}
		nread += 8 + uint64(l)
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	p.DataSerial = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 41 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 98. Truncate

func (*Truncate) neoMsgCode() uint16 {
	return 98
}

func (p *Truncate) neoMsgEncodedLen() int {
	return 8
}

func (p *Truncate) neoMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *Truncate) neoMsgDecode(data []byte) (int, error) {
	if uint64(len(data)) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// registry of message types
var msgTypeRegistry = map[uint16]reflect.Type{
	0 | answerBit:  reflect.TypeOf(Error{}),
	1:              reflect.TypeOf(RequestIdentification{}),
	1 | answerBit:  reflect.TypeOf(AcceptIdentification{}),
	3:              reflect.TypeOf(Ping{}),
	3 | answerBit:  reflect.TypeOf(Pong{}),
	5:              reflect.TypeOf(CloseClient{}),
	6:              reflect.TypeOf(PrimaryMaster{}),
	6 | answerBit:  reflect.TypeOf(AnswerPrimary{}),
	8:              reflect.TypeOf(NotPrimaryMaster{}),
	9:              reflect.TypeOf(NotifyNodeInformation{}),
	10:             reflect.TypeOf(Recovery{}),
	10 | answerBit: reflect.TypeOf(AnswerRecovery{}),
	12:             reflect.TypeOf(LastIDs{}),
	12 | answerBit: reflect.TypeOf(AnswerLastIDs{}),
	14:             reflect.TypeOf(AskPartitionTable{}),
	14 | answerBit: reflect.TypeOf(AnswerPartitionTable{}),
	16:             reflect.TypeOf(SendPartitionTable{}),
	17:             reflect.TypeOf(NotifyPartitionChanges{}),
	18:             reflect.TypeOf(StartOperation{}),
	19:             reflect.TypeOf(StopOperation{}),
	20:             reflect.TypeOf(UnfinishedTransactions{}),
	20 | answerBit: reflect.TypeOf(AnswerUnfinishedTransactions{}),
	22:             reflect.TypeOf(LockedTransactions{}),
	22 | answerBit: reflect.TypeOf(AnswerLockedTransactions{}),
	24:             reflect.TypeOf(FinalTID{}),
	24 | answerBit: reflect.TypeOf(AnswerFinalTID{}),
	26:             reflect.TypeOf(ValidateTransaction{}),
	27:             reflect.TypeOf(BeginTransaction{}),
	27 | answerBit: reflect.TypeOf(AnswerBeginTransaction{}),
	29:             reflect.TypeOf(FailedVote{}),
	30:             reflect.TypeOf(FinishTransaction{}),
	30 | answerBit: reflect.TypeOf(AnswerTransactionFinished{}),
	32:             reflect.TypeOf(LockInformation{}),
	32 | answerBit: reflect.TypeOf(AnswerInformationLocked{}),
	34:             reflect.TypeOf(InvalidateObjects{}),
	35:             reflect.TypeOf(NotifyUnlockInformation{}),
	36:             reflect.TypeOf(AskNewOIDs{}),
	36 | answerBit: reflect.TypeOf(AnswerNewOIDs{}),
	38:             reflect.TypeOf(NotifyDeadlock{}),
	39:             reflect.TypeOf(RebaseTransaction{}),
	39 | answerBit: reflect.TypeOf(AnswerRebaseTransaction{}),
	41:             reflect.TypeOf(RebaseObject{}),
	41 | answerBit: reflect.TypeOf(AnswerRebaseObject{}),
	43:             reflect.TypeOf(StoreObject{}),
	43 | answerBit: reflect.TypeOf(AnswerStoreObject{}),
	45:             reflect.TypeOf(AbortTransaction{}),
	46:             reflect.TypeOf(StoreTransaction{}),
	46 | answerBit: reflect.TypeOf(AnswerStoreTransaction{}),
	48:             reflect.TypeOf(VoteTransaction{}),
	48 | answerBit: reflect.TypeOf(AnswerVoteTransaction{}),
	50:             reflect.TypeOf(GetObject{}),
	50 | answerBit: reflect.TypeOf(AnswerObject{}),
	52:             reflect.TypeOf(AskTIDs{}),
	52 | answerBit: reflect.TypeOf(AnswerTIDs{}),
	54:             reflect.TypeOf(TransactionInformation{}),
	54 | answerBit: reflect.TypeOf(AnswerTransactionInformation{}),
	56:             reflect.TypeOf(ObjectHistory{}),
	56 | answerBit: reflect.TypeOf(AnswerObjectHistory{}),
	58:             reflect.TypeOf(PartitionList{}),
	58 | answerBit: reflect.TypeOf(AnswerPartitionList{}),
	60:             reflect.TypeOf(NodeList{}),
	60 | answerBit: reflect.TypeOf(AnswerNodeList{}),
	62:             reflect.TypeOf(SetNodeState{}),
	63:             reflect.TypeOf(AddPendingNodes{}),
	64:             reflect.TypeOf(TweakPartitionTable{}),
	65:             reflect.TypeOf(SetClusterState{}),
	66:             reflect.TypeOf(Repair{}),
	67:             reflect.TypeOf(RepairOne{}),
	68:             reflect.TypeOf(NotifyClusterState{}),
	69:             reflect.TypeOf(AskClusterState{}),
	69 | answerBit: reflect.TypeOf(AnswerClusterState{}),
	71:             reflect.TypeOf(ObjectUndoSerial{}),
	71 | answerBit: reflect.TypeOf(AnswerObjectUndoSerial{}),
	73:             reflect.TypeOf(AskTIDsFrom{}),
	73 | answerBit: reflect.TypeOf(AnswerTIDsFrom{}),
	75:             reflect.TypeOf(Pack{}),
	75 | answerBit: reflect.TypeOf(AnswerPack{}),
	77:             reflect.TypeOf(CheckReplicas{}),
	78:             reflect.TypeOf(CheckPartition{}),
	79:             reflect.TypeOf(CheckTIDRange{}),
	79 | answerBit: reflect.TypeOf(AnswerCheckTIDRange{}),
	81:             reflect.TypeOf(CheckSerialRange{}),
	81 | answerBit: reflect.TypeOf(AnswerCheckSerialRange{}),
	83:             reflect.TypeOf(PartitionCorrupted{}),
	84:             reflect.TypeOf(NotifyReady{}),
	85:             reflect.TypeOf(LastTransaction{}),
	85 | answerBit: reflect.TypeOf(AnswerLastTransaction{}),
	87:             reflect.TypeOf(CheckCurrentSerial{}),
	87 | answerBit: reflect.TypeOf(AnswerCheckCurrentSerial{}),
	89:             reflect.TypeOf(NotifyTransactionFinished{}),
	90:             reflect.TypeOf(Replicate{}),
	91:             reflect.TypeOf(ReplicationDone{}),
	92:             reflect.TypeOf(FetchTransactions{}),
	92 | answerBit: reflect.TypeOf(AnswerFetchTransactions{}),
	94:             reflect.TypeOf(FetchObjects{}),
	94 | answerBit: reflect.TypeOf(AnswerFetchObjects{}),
	96:             reflect.TypeOf(AddTransaction{}),
	97:             reflect.TypeOf(AddObject{}),
	98:             reflect.TypeOf(Truncate{}),
}
