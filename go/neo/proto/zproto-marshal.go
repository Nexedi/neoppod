// Code generated by protogen.go; DO NOT EDIT.

package proto

// NEO. protocol messages to/from wire marshalling.

import (
	"encoding/binary"
	"reflect"
	"sort"

	"lab.nexedi.com/kirr/go123/mem"
	"lab.nexedi.com/kirr/neo/go/zodb"
)

// messages marshalling

// 0 | answerBit. Error

func (*Error) NEOMsgCode() uint16 {
	return 0 | answerBit
}

func (p *Error) NEOMsgEncodedLen() int {
	return 5 + len(p.Message)
}

func (p *Error) NEOMsgEncode(data []byte) {
	(data[0:])[0] = uint8(int8(p.Code))
	{
		l := uint32(len(p.Message))
		binary.BigEndian.PutUint32(data[1:], l)
		data = data[5:]
		copy(data, p.Message)
		data = data[l:]
	}
}

func (p *Error) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 5 {
		goto overflow
	}
	p.Code = ErrorCode(int8((data[0 : 0+1])[0]))
	{
		l := binary.BigEndian.Uint32(data[1 : 1+4])
		data = data[5:]
		if uint64(len(data)) < uint64(l) {
			goto overflow
		}
		nread += uint64(l)
		p.Message = string(data[:l])
		data = data[l:]
	}
	return 5 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 1. RequestIdentification

func (*RequestIdentification) NEOMsgCode() uint16 {
	return 1
}

func (p *RequestIdentification) NEOMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.DevPath); i++ {
		a := &p.DevPath[i]
		size += len((*a))
	}
	return 17 + p.Address.neoEncodedLen() + len(p.ClusterName) + p.IdTime.neoEncodedLen() + len(p.DevPath)*4 + len(p.NewNID)*4 + size
}

func (p *RequestIdentification) NEOMsgEncode(data []byte) {
	(data[0:])[0] = uint8(int8(p.NodeType))
	binary.BigEndian.PutUint32(data[1:], uint32(int32(p.UUID)))
	{
		n := p.Address.neoEncode(data[5:])
		data = data[5+n:]
	}
	{
		l := uint32(len(p.ClusterName))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.ClusterName)
		data = data[l:]
	}
	{
		n := p.IdTime.neoEncode(data[0:])
		data = data[0+n:]
	}
	{
		l := uint32(len(p.DevPath))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.DevPath[i]
			{
				l := uint32(len((*a)))
				binary.BigEndian.PutUint32(data[0:], l)
				data = data[4:]
				copy(data, (*a))
				data = data[l:]
			}
			data = data[0:]
		}
	}
	{
		l := uint32(len(p.NewNID))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NewNID[i]
			binary.BigEndian.PutUint32(data[0:], (*a))
			data = data[4:]
		}
	}
}

func (p *RequestIdentification) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 5 {
		goto overflow
	}
	p.NodeType = NodeType(int8((data[0 : 0+1])[0]))
	p.UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[1 : 1+4])))
	data = data[5:]
	{
		n, ok := p.Address.neoDecode(data)
		if !ok {
			goto overflow
		}
		data = data[n:]
		nread += n
	}
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < uint64(l) {
			goto overflow
		}
		nread += uint64(l)
		p.ClusterName = string(data[:l])
		data = data[l:]
	}
	{
		n, ok := p.IdTime.neoDecode(data)
		if !ok {
			goto overflow
		}
		data = data[n:]
		nread += n
	}
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		p.DevPath = make([]string, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.DevPath[i]
			if len(data) < 4 {
				goto overflow
			}
			{
				l := binary.BigEndian.Uint32(data[0 : 0+4])
				data = data[4:]
				if uint64(len(data)) < uint64(l) {
					goto overflow
				}
				nread += uint64(l)
				(*a) = string(data[:l])
				data = data[l:]
			}
		}
		if len(data) < 4 {
			goto overflow
		}
		nread += uint64(l) * 4
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*4 {
			goto overflow
		}
		nread += uint64(l) * 4
		p.NewNID = make([]uint32, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NewNID[i]
			(*a) = binary.BigEndian.Uint32(data[0 : 0+4])
			data = data[4:]
		}
	}
	return 17 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 1 | answerBit. AcceptIdentification

func (*AcceptIdentification) NEOMsgCode() uint16 {
	return 1 | answerBit
}

func (p *AcceptIdentification) NEOMsgEncodedLen() int {
	return 9
}

func (p *AcceptIdentification) NEOMsgEncode(data []byte) {
	(data[0:])[0] = uint8(int8(p.NodeType))
	binary.BigEndian.PutUint32(data[1:], uint32(int32(p.MyUUID)))
	binary.BigEndian.PutUint32(data[5:], uint32(int32(p.YourUUID)))
}

func (p *AcceptIdentification) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 9 {
		goto overflow
	}
	p.NodeType = NodeType(int8((data[0 : 0+1])[0]))
	p.MyUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[1 : 1+4])))
	p.YourUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[5 : 5+4])))
	return 9, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 2. Ping

func (*Ping) NEOMsgCode() uint16 {
	return 2
}

func (p *Ping) NEOMsgEncodedLen() int {
	return 0
}

func (p *Ping) NEOMsgEncode(data []byte) {
}

func (p *Ping) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 2 | answerBit. Pong

func (*Pong) NEOMsgCode() uint16 {
	return 2 | answerBit
}

func (p *Pong) NEOMsgEncodedLen() int {
	return 0
}

func (p *Pong) NEOMsgEncode(data []byte) {
}

func (p *Pong) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 3. CloseClient

func (*CloseClient) NEOMsgCode() uint16 {
	return 3
}

func (p *CloseClient) NEOMsgEncodedLen() int {
	return 0
}

func (p *CloseClient) NEOMsgEncode(data []byte) {
}

func (p *CloseClient) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 4. PrimaryMaster

func (*PrimaryMaster) NEOMsgCode() uint16 {
	return 4
}

func (p *PrimaryMaster) NEOMsgEncodedLen() int {
	return 0
}

func (p *PrimaryMaster) NEOMsgEncode(data []byte) {
}

func (p *PrimaryMaster) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 4 | answerBit. AnswerPrimary

func (*AnswerPrimary) NEOMsgCode() uint16 {
	return 4 | answerBit
}

func (p *AnswerPrimary) NEOMsgEncodedLen() int {
	return 4
}

func (p *AnswerPrimary) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.PrimaryNodeUUID)))
}

func (p *AnswerPrimary) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.PrimaryNodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0 : 0+4])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 5. NotPrimaryMaster

func (*NotPrimaryMaster) NEOMsgCode() uint16 {
	return 5
}

func (p *NotPrimaryMaster) NEOMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.KnownMasterList); i++ {
		a := &p.KnownMasterList[i]
		size += (*a).neoEncodedLen()
	}
	return 8 + size
}

func (p *NotPrimaryMaster) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.Primary)))
	{
		l := uint32(len(p.KnownMasterList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.KnownMasterList[i]
			{
				n := (*a).neoEncode(data[0:])
				data = data[0+n:]
			}
			data = data[0:]
		}
	}
}

func (p *NotPrimaryMaster) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 8 {
		goto overflow
	}
	p.Primary = NodeUUID(int32(binary.BigEndian.Uint32(data[0 : 0+4])))
	{
		l := binary.BigEndian.Uint32(data[4 : 4+4])
		data = data[8:]
		p.KnownMasterList = make([]struct{ Address }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.KnownMasterList[i]
			{
				n, ok := (*a).neoDecode(data)
				if !ok {
					goto overflow
				}
				data = data[n:]
				nread += n
			}
		}
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 6. NotifyNodeInformation

func (*NotifyNodeInformation) NEOMsgCode() uint16 {
	return 6
}

func (p *NotifyNodeInformation) NEOMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.NodeList); i++ {
		a := &p.NodeList[i]
		size += (*a).Addr.neoEncodedLen() + (*a).IdTime.neoEncodedLen()
	}
	return 4 + p.IdTime.neoEncodedLen() + len(p.NodeList)*6 + size
}

func (p *NotifyNodeInformation) NEOMsgEncode(data []byte) {
	{
		n := p.IdTime.neoEncode(data[0:])
		data = data[0+n:]
	}
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(data[0:])[0] = uint8(int8((*a).Type))
			{
				n := (*a).Addr.neoEncode(data[1:])
				data = data[1+n:]
			}
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
			(data[4:])[0] = uint8(int8((*a).State))
			{
				n := (*a).IdTime.neoEncode(data[5:])
				data = data[5+n:]
			}
			data = data[0:]
		}
	}
}

func (p *NotifyNodeInformation) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	{
		n, ok := p.IdTime.neoDecode(data)
		if !ok {
			goto overflow
		}
		data = data[n:]
		nread += n
	}
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		p.NodeList = make([]NodeInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			if len(data) < 1 {
				goto overflow
			}
			(*a).Type = NodeType(int8((data[0 : 0+1])[0]))
			data = data[1:]
			{
				n, ok := (*a).Addr.neoDecode(data)
				if !ok {
					goto overflow
				}
				data = data[n:]
				nread += n
			}
			if len(data) < 5 {
				goto overflow
			}
			(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0 : 0+4])))
			(*a).State = NodeState(int8((data[4 : 4+1])[0]))
			data = data[5:]
			{
				n, ok := (*a).IdTime.neoDecode(data)
				if !ok {
					goto overflow
				}
				data = data[n:]
				nread += n
			}
		}
		nread += uint64(l) * 6
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 7. Recovery

func (*Recovery) NEOMsgCode() uint16 {
	return 7
}

func (p *Recovery) NEOMsgEncodedLen() int {
	return 0
}

func (p *Recovery) NEOMsgEncode(data []byte) {
}

func (p *Recovery) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 7 | answerBit. AnswerRecovery

func (*AnswerRecovery) NEOMsgCode() uint16 {
	return 7 | answerBit
}

func (p *AnswerRecovery) NEOMsgEncodedLen() int {
	return 24
}

func (p *AnswerRecovery) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.BackupTid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.TruncateTid))
}

func (p *AnswerRecovery) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 24 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.BackupTid = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	p.TruncateTid = zodb.Tid(binary.BigEndian.Uint64(data[16 : 16+8]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 8. LastIDs

func (*LastIDs) NEOMsgCode() uint16 {
	return 8
}

func (p *LastIDs) NEOMsgEncodedLen() int {
	return 0
}

func (p *LastIDs) NEOMsgEncode(data []byte) {
}

func (p *LastIDs) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 8 | answerBit. AnswerLastIDs

func (*AnswerLastIDs) NEOMsgCode() uint16 {
	return 8 | answerBit
}

func (p *AnswerLastIDs) NEOMsgEncodedLen() int {
	return 16
}

func (p *AnswerLastIDs) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.LastOid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LastTid))
}

func (p *AnswerLastIDs) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 16 {
		goto overflow
	}
	p.LastOid = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.LastTid = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 9. AskPartitionTable

func (*AskPartitionTable) NEOMsgCode() uint16 {
	return 9
}

func (p *AskPartitionTable) NEOMsgEncodedLen() int {
	return 0
}

func (p *AskPartitionTable) NEOMsgEncode(data []byte) {
}

func (p *AskPartitionTable) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 9 | answerBit. AnswerPartitionTable

func (*AnswerPartitionTable) NEOMsgCode() uint16 {
	return 9 | answerBit
}

func (p *AnswerPartitionTable) NEOMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 5
	}
	return 16 + len(p.RowList)*4 + size
}

func (p *AnswerPartitionTable) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	binary.BigEndian.PutUint32(data[8:], p.NumReplicas)
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[12:], l)
		data = data[16:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[0:], l)
				data = data[4:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
					(data[4:])[0] = uint8(int8((*a).State))
					data = data[5:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerPartitionTable) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 16 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.NumReplicas = binary.BigEndian.Uint32(data[8 : 8+4])
	{
		l := binary.BigEndian.Uint32(data[12 : 12+4])
		data = data[16:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if len(data) < 4 {
				goto overflow
			}
			{
				l := binary.BigEndian.Uint32(data[0 : 0+4])
				data = data[4:]
				if uint64(len(data)) < uint64(l)*5 {
					goto overflow
				}
				nread += uint64(l) * 5
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0 : 0+4])))
					(*a).State = CellState(int8((data[4 : 4+1])[0]))
					data = data[5:]
				}
			}
		}
		nread += uint64(l) * 4
	}
	return 16 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 10. SendPartitionTable

func (*SendPartitionTable) NEOMsgCode() uint16 {
	return 10
}

func (p *SendPartitionTable) NEOMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 5
	}
	return 16 + len(p.RowList)*4 + size
}

func (p *SendPartitionTable) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	binary.BigEndian.PutUint32(data[8:], p.NumReplicas)
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[12:], l)
		data = data[16:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[0:], l)
				data = data[4:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
					(data[4:])[0] = uint8(int8((*a).State))
					data = data[5:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *SendPartitionTable) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 16 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.NumReplicas = binary.BigEndian.Uint32(data[8 : 8+4])
	{
		l := binary.BigEndian.Uint32(data[12 : 12+4])
		data = data[16:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if len(data) < 4 {
				goto overflow
			}
			{
				l := binary.BigEndian.Uint32(data[0 : 0+4])
				data = data[4:]
				if uint64(len(data)) < uint64(l)*5 {
					goto overflow
				}
				nread += uint64(l) * 5
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0 : 0+4])))
					(*a).State = CellState(int8((data[4 : 4+1])[0]))
					data = data[5:]
				}
			}
		}
		nread += uint64(l) * 4
	}
	return 16 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 11. NotifyPartitionChanges

func (*NotifyPartitionChanges) NEOMsgCode() uint16 {
	return 11
}

func (p *NotifyPartitionChanges) NEOMsgEncodedLen() int {
	return 16 + len(p.CellList)*9
}

func (p *NotifyPartitionChanges) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	binary.BigEndian.PutUint32(data[8:], p.NumReplicas)
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[12:], l)
		data = data[16:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellInfo.UUID)))
			(data[8:])[0] = uint8(int8((*a).CellInfo.State))
			data = data[9:]
		}
	}
}

func (p *NotifyPartitionChanges) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 16 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.NumReplicas = binary.BigEndian.Uint32(data[8 : 8+4])
	{
		l := binary.BigEndian.Uint32(data[12 : 12+4])
		data = data[16:]
		if uint64(len(data)) < uint64(l)*9 {
			goto overflow
		}
		nread += uint64(l) * 9
		p.CellList = make([]struct {
			Offset   uint32
			CellInfo CellInfo
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a).Offset = binary.BigEndian.Uint32(data[0 : 0+4])
			(*a).CellInfo.UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[4 : 4+4])))
			(*a).CellInfo.State = CellState(int8((data[8 : 8+1])[0]))
			data = data[9:]
		}
	}
	return 16 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 12. StartOperation

func (*StartOperation) NEOMsgCode() uint16 {
	return 12
}

func (p *StartOperation) NEOMsgEncodedLen() int {
	return 1
}

func (p *StartOperation) NEOMsgEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Backup)
}

func (p *StartOperation) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 1 {
		goto overflow
	}
	p.Backup = byte2bool((data[0 : 0+1])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 13. StopOperation

func (*StopOperation) NEOMsgCode() uint16 {
	return 13
}

func (p *StopOperation) NEOMsgEncodedLen() int {
	return 0
}

func (p *StopOperation) NEOMsgEncode(data []byte) {
}

func (p *StopOperation) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 14. UnfinishedTransactions

func (*UnfinishedTransactions) NEOMsgCode() uint16 {
	return 14
}

func (p *UnfinishedTransactions) NEOMsgEncodedLen() int {
	return 4 + len(p.RowList)*4
}

func (p *UnfinishedTransactions) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			data = data[4:]
		}
	}
}

func (p *UnfinishedTransactions) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*4 {
			goto overflow
		}
		nread += uint64(l) * 4
		p.RowList = make([]struct{ Offset uint32 }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			(*a).Offset = binary.BigEndian.Uint32(data[0 : 0+4])
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 14 | answerBit. AnswerUnfinishedTransactions

func (*AnswerUnfinishedTransactions) NEOMsgCode() uint16 {
	return 14 | answerBit
}

func (p *AnswerUnfinishedTransactions) NEOMsgEncodedLen() int {
	return 12 + len(p.TidList)*8
}

func (p *AnswerUnfinishedTransactions) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.MaxTID))
	{
		l := uint32(len(p.TidList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a).UnfinishedTID))
			data = data[8:]
		}
	}
}

func (p *AnswerUnfinishedTransactions) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 12 {
		goto overflow
	}
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	{
		l := binary.BigEndian.Uint32(data[8 : 8+4])
		data = data[12:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.TidList = make([]struct{ UnfinishedTID zodb.Tid }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			(*a).UnfinishedTID = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 15. LockedTransactions

func (*LockedTransactions) NEOMsgCode() uint16 {
	return 15
}

func (p *LockedTransactions) NEOMsgEncodedLen() int {
	return 0
}

func (p *LockedTransactions) NEOMsgEncode(data []byte) {
}

func (p *LockedTransactions) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 15 | answerBit. AnswerLockedTransactions

func (*AnswerLockedTransactions) NEOMsgCode() uint16 {
	return 15 | answerBit
}

func (p *AnswerLockedTransactions) NEOMsgEncodedLen() int {
	return 4 + len(p.TidDict)*16
}

func (p *AnswerLockedTransactions) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.TidDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]zodb.Tid, 0, l)
		for key := range p.TidDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			binary.BigEndian.PutUint64(data[8:], uint64(p.TidDict[key]))
			data = data[16:]
		}
	}
}

func (p *AnswerLockedTransactions) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*16 {
			goto overflow
		}
		nread += uint64(l) * 16
		p.TidDict = make(map[zodb.Tid]zodb.Tid, l)
		m := p.TidDict
		for i := 0; uint32(i) < l; i++ {
			key := zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
			m[key] = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
			data = data[16:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 16. FinalTID

func (*FinalTID) NEOMsgCode() uint16 {
	return 16
}

func (p *FinalTID) NEOMsgEncodedLen() int {
	return 8
}

func (p *FinalTID) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
}

func (p *FinalTID) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 16 | answerBit. AnswerFinalTID

func (*AnswerFinalTID) NEOMsgCode() uint16 {
	return 16 | answerBit
}

func (p *AnswerFinalTID) NEOMsgEncodedLen() int {
	return 8
}

func (p *AnswerFinalTID) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerFinalTID) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 17. ValidateTransaction

func (*ValidateTransaction) NEOMsgCode() uint16 {
	return 17
}

func (p *ValidateTransaction) NEOMsgEncodedLen() int {
	return 16
}

func (p *ValidateTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *ValidateTransaction) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 16 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 18. BeginTransaction

func (*BeginTransaction) NEOMsgCode() uint16 {
	return 18
}

func (p *BeginTransaction) NEOMsgEncodedLen() int {
	return 8
}

func (p *BeginTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *BeginTransaction) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 18 | answerBit. AnswerBeginTransaction

func (*AnswerBeginTransaction) NEOMsgCode() uint16 {
	return 18 | answerBit
}

func (p *AnswerBeginTransaction) NEOMsgEncodedLen() int {
	return 8
}

func (p *AnswerBeginTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerBeginTransaction) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 19. FailedVote

func (*FailedVote) NEOMsgCode() uint16 {
	return 19
}

func (p *FailedVote) NEOMsgEncodedLen() int {
	return 12 + len(p.NodeList)*4
}

func (p *FailedVote) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *FailedVote) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	{
		l := binary.BigEndian.Uint32(data[8 : 8+4])
		data = data[12:]
		if uint64(len(data)) < uint64(l)*4 {
			goto overflow
		}
		nread += uint64(l) * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0 : 0+4])))
			data = data[4:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 20. FinishTransaction

func (*FinishTransaction) NEOMsgCode() uint16 {
	return 20
}

func (p *FinishTransaction) NEOMsgEncodedLen() int {
	return 16 + len(p.OIDList)*8 + len(p.CheckedList)*8
}

func (p *FinishTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.OIDList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OIDList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
	{
		l := uint32(len(p.CheckedList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CheckedList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *FinishTransaction) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	{
		l := binary.BigEndian.Uint32(data[8 : 8+4])
		data = data[12:]
		if uint64(len(data)) < 4+uint64(l)*8 {
			goto overflow
		}
		nread += 4 + uint64(l)*8
		p.OIDList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OIDList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
			data = data[8:]
		}
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.CheckedList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CheckedList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 20 | answerBit. AnswerTransactionFinished

func (*AnswerTransactionFinished) NEOMsgCode() uint16 {
	return 20 | answerBit
}

func (p *AnswerTransactionFinished) NEOMsgEncodedLen() int {
	return 16
}

func (p *AnswerTransactionFinished) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *AnswerTransactionFinished) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 21. LockInformation

func (*LockInformation) NEOMsgCode() uint16 {
	return 21
}

func (p *LockInformation) NEOMsgEncodedLen() int {
	return 16
}

func (p *LockInformation) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Ttid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *LockInformation) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 16 {
		goto overflow
	}
	p.Ttid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 21 | answerBit. AnswerInformationLocked

func (*AnswerInformationLocked) NEOMsgCode() uint16 {
	return 21 | answerBit
}

func (p *AnswerInformationLocked) NEOMsgEncodedLen() int {
	return 8
}

func (p *AnswerInformationLocked) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Ttid))
}

func (p *AnswerInformationLocked) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Ttid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 22. InvalidateObjects

func (*InvalidateObjects) NEOMsgCode() uint16 {
	return 22
}

func (p *InvalidateObjects) NEOMsgEncodedLen() int {
	return 12 + len(p.OidList)*8
}

func (p *InvalidateObjects) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *InvalidateObjects) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	{
		l := binary.BigEndian.Uint32(data[8 : 8+4])
		data = data[12:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 23. NotifyUnlockInformation

func (*NotifyUnlockInformation) NEOMsgCode() uint16 {
	return 23
}

func (p *NotifyUnlockInformation) NEOMsgEncodedLen() int {
	return 8
}

func (p *NotifyUnlockInformation) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
}

func (p *NotifyUnlockInformation) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 24. AskNewOIDs

func (*AskNewOIDs) NEOMsgCode() uint16 {
	return 24
}

func (p *AskNewOIDs) NEOMsgEncodedLen() int {
	return 4
}

func (p *AskNewOIDs) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.NumOIDs)
}

func (p *AskNewOIDs) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.NumOIDs = binary.BigEndian.Uint32(data[0 : 0+4])
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 24 | answerBit. AnswerNewOIDs

func (*AnswerNewOIDs) NEOMsgCode() uint16 {
	return 24 | answerBit
}

func (p *AnswerNewOIDs) NEOMsgEncodedLen() int {
	return 4 + len(p.OidList)*8
}

func (p *AnswerNewOIDs) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerNewOIDs) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 25. NotifyDeadlock

func (*NotifyDeadlock) NEOMsgCode() uint16 {
	return 25
}

func (p *NotifyDeadlock) NEOMsgEncodedLen() int {
	return 16
}

func (p *NotifyDeadlock) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LockingTid))
}

func (p *NotifyDeadlock) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.LockingTid = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 26. RebaseTransaction

func (*RebaseTransaction) NEOMsgCode() uint16 {
	return 26
}

func (p *RebaseTransaction) NEOMsgEncodedLen() int {
	return 16
}

func (p *RebaseTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LockingTid))
}

func (p *RebaseTransaction) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.LockingTid = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 26 | answerBit. AnswerRebaseTransaction

func (*AnswerRebaseTransaction) NEOMsgCode() uint16 {
	return 26 | answerBit
}

func (p *AnswerRebaseTransaction) NEOMsgEncodedLen() int {
	return 4 + len(p.OidList)*8
}

func (p *AnswerRebaseTransaction) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerRebaseTransaction) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 27. RebaseObject

func (*RebaseObject) NEOMsgCode() uint16 {
	return 27
}

func (p *RebaseObject) NEOMsgEncodedLen() int {
	return 16
}

func (p *RebaseObject) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Oid))
}

func (p *RebaseObject) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 16 {
		goto overflow
	}
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[8 : 8+8]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 27 | answerBit. AnswerRebaseObject

func (*AnswerRebaseObject) NEOMsgCode() uint16 {
	return 27 | answerBit
}

func (p *AnswerRebaseObject) NEOMsgEncodedLen() int {
	return 41 + len(p.Data.XData())
}

func (p *AnswerRebaseObject) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[8:], uint64(p.ConflictSerial))
	(data[16:])[0] = bool2byte(p.Compression)
	copy(data[17:], p.Checksum[:])
	{
		l := uint32(len(p.Data.XData()))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		copy(data, p.Data.XData())
		data = data[l:]
	}
}

func (p *AnswerRebaseObject) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 41 {
		goto overflow
	}
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.ConflictSerial = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	p.Compression = byte2bool((data[16 : 16+1])[0])
	copy(p.Checksum[:], data[17:37])
	{
		l := binary.BigEndian.Uint32(data[37 : 37+4])
		data = data[41:]
		if uint64(len(data)) < uint64(l) {
			goto overflow
		}
		nread += uint64(l)
		p.Data = mem.BufAlloc(int(l))
		copy(p.Data.Data, data[:l])
		data = data[l:]
	}
	return 41 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 28. StoreObject

func (*StoreObject) NEOMsgCode() uint16 {
	return 28
}

func (p *StoreObject) NEOMsgEncodedLen() int {
	return 57 + len(p.Data)
}

func (p *StoreObject) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	(data[16:])[0] = bool2byte(p.Compression)
	copy(data[17:], p.Checksum[:])
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		copy(data, p.Data)
		data = data[l:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *StoreObject) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 41 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	p.Compression = byte2bool((data[16 : 16+1])[0])
	copy(p.Checksum[:], data[17:37])
	{
		l := binary.BigEndian.Uint32(data[37 : 37+4])
		data = data[41:]
		if uint64(len(data)) < 16+uint64(l) {
			goto overflow
		}
		nread += 16 + uint64(l)
		p.Data = make([]byte, l)
		copy(p.Data, data[:l])
		data = data[l:]
	}
	p.DataSerial = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	return 41 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 28 | answerBit. AnswerStoreObject

func (*AnswerStoreObject) NEOMsgCode() uint16 {
	return 28 | answerBit
}

func (p *AnswerStoreObject) NEOMsgEncodedLen() int {
	return 8
}

func (p *AnswerStoreObject) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Conflict))
}

func (p *AnswerStoreObject) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Conflict = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 29. AbortTransaction

func (*AbortTransaction) NEOMsgCode() uint16 {
	return 29
}

func (p *AbortTransaction) NEOMsgEncodedLen() int {
	return 12 + len(p.NodeList)*4
}

func (p *AbortTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *AbortTransaction) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	{
		l := binary.BigEndian.Uint32(data[8 : 8+4])
		data = data[12:]
		if uint64(len(data)) < uint64(l)*4 {
			goto overflow
		}
		nread += uint64(l) * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0 : 0+4])))
			data = data[4:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 30. StoreTransaction

func (*StoreTransaction) NEOMsgCode() uint16 {
	return 30
}

func (p *StoreTransaction) NEOMsgEncodedLen() int {
	return 24 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *StoreTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *StoreTransaction) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	{
		l := binary.BigEndian.Uint32(data[8 : 8+4])
		data = data[12:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.User = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.Description = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.Extension = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 30 | answerBit. AnswerStoreTransaction

func (*AnswerStoreTransaction) NEOMsgCode() uint16 {
	return 30 | answerBit
}

func (p *AnswerStoreTransaction) NEOMsgEncodedLen() int {
	return 0
}

func (p *AnswerStoreTransaction) NEOMsgEncode(data []byte) {
}

func (p *AnswerStoreTransaction) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 31. VoteTransaction

func (*VoteTransaction) NEOMsgCode() uint16 {
	return 31
}

func (p *VoteTransaction) NEOMsgEncodedLen() int {
	return 8
}

func (p *VoteTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *VoteTransaction) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 31 | answerBit. AnswerVoteTransaction

func (*AnswerVoteTransaction) NEOMsgCode() uint16 {
	return 31 | answerBit
}

func (p *AnswerVoteTransaction) NEOMsgEncodedLen() int {
	return 0
}

func (p *AnswerVoteTransaction) NEOMsgEncode(data []byte) {
}

func (p *AnswerVoteTransaction) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 32. GetObject

func (*GetObject) NEOMsgCode() uint16 {
	return 32
}

func (p *GetObject) NEOMsgEncodedLen() int {
	return 24
}

func (p *GetObject) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.At))
	binary.BigEndian.PutUint64(data[16:], uint64(p.Before))
}

func (p *GetObject) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 24 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.At = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	p.Before = zodb.Tid(binary.BigEndian.Uint64(data[16 : 16+8]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 32 | answerBit. AnswerObject

func (*AnswerObject) NEOMsgCode() uint16 {
	return 32 | answerBit
}

func (p *AnswerObject) NEOMsgEncodedLen() int {
	return 57 + len(p.Data.XData())
}

func (p *AnswerObject) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[16:], uint64(p.NextSerial))
	(data[24:])[0] = bool2byte(p.Compression)
	copy(data[25:], p.Checksum[:])
	{
		l := uint32(len(p.Data.XData()))
		binary.BigEndian.PutUint32(data[45:], l)
		data = data[49:]
		copy(data, p.Data.XData())
		data = data[l:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
}

func (p *AnswerObject) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 49 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	p.NextSerial = zodb.Tid(binary.BigEndian.Uint64(data[16 : 16+8]))
	p.Compression = byte2bool((data[24 : 24+1])[0])
	copy(p.Checksum[:], data[25:45])
	{
		l := binary.BigEndian.Uint32(data[45 : 45+4])
		data = data[49:]
		if uint64(len(data)) < 8+uint64(l) {
			goto overflow
		}
		nread += 8 + uint64(l)
		p.Data = mem.BufAlloc(int(l))
		copy(p.Data.Data, data[:l])
		data = data[l:]
	}
	p.DataSerial = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 49 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 33. AskTIDs

func (*AskTIDs) NEOMsgCode() uint16 {
	return 33
}

func (p *AskTIDs) NEOMsgEncodedLen() int {
	return 20
}

func (p *AskTIDs) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], p.First)
	binary.BigEndian.PutUint64(data[8:], p.Last)
	binary.BigEndian.PutUint32(data[16:], p.Partition)
}

func (p *AskTIDs) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 20 {
		goto overflow
	}
	p.First = binary.BigEndian.Uint64(data[0 : 0+8])
	p.Last = binary.BigEndian.Uint64(data[8 : 8+8])
	p.Partition = binary.BigEndian.Uint32(data[16 : 16+4])
	return 20, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 33 | answerBit. AnswerTIDs

func (*AnswerTIDs) NEOMsgCode() uint16 {
	return 33 | answerBit
}

func (p *AnswerTIDs) NEOMsgEncodedLen() int {
	return 4 + len(p.TIDList)*8
}

func (p *AnswerTIDs) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.TIDList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TIDList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTIDs) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.TIDList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TIDList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 34. TransactionInformation

func (*TransactionInformation) NEOMsgCode() uint16 {
	return 34
}

func (p *TransactionInformation) NEOMsgEncodedLen() int {
	return 8
}

func (p *TransactionInformation) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *TransactionInformation) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 34 | answerBit. AnswerTransactionInformation

func (*AnswerTransactionInformation) NEOMsgCode() uint16 {
	return 34 | answerBit
}

func (p *AnswerTransactionInformation) NEOMsgEncodedLen() int {
	return 25 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *AnswerTransactionInformation) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	(data[0:])[0] = bool2byte(p.Packed)
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[1:], l)
		data = data[5:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTransactionInformation) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	{
		l := binary.BigEndian.Uint32(data[8 : 8+4])
		data = data[12:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.User = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.Description = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < 5+uint64(l) {
			goto overflow
		}
		nread += 5 + uint64(l)
		p.Extension = string(data[:l])
		data = data[l:]
	}
	p.Packed = byte2bool((data[0 : 0+1])[0])
	{
		l := binary.BigEndian.Uint32(data[1 : 1+4])
		data = data[5:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 35. ObjectHistory

func (*ObjectHistory) NEOMsgCode() uint16 {
	return 35
}

func (p *ObjectHistory) NEOMsgEncodedLen() int {
	return 24
}

func (p *ObjectHistory) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], p.First)
	binary.BigEndian.PutUint64(data[16:], p.Last)
}

func (p *ObjectHistory) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 24 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.First = binary.BigEndian.Uint64(data[8 : 8+8])
	p.Last = binary.BigEndian.Uint64(data[16 : 16+8])
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 35 | answerBit. AnswerObjectHistory

func (*AnswerObjectHistory) NEOMsgCode() uint16 {
	return 35 | answerBit
}

func (p *AnswerObjectHistory) NEOMsgEncodedLen() int {
	return 12 + len(p.HistoryList)*12
}

func (p *AnswerObjectHistory) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	{
		l := uint32(len(p.HistoryList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.HistoryList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a).Serial))
			binary.BigEndian.PutUint32(data[8:], (*a).Size)
			data = data[12:]
		}
	}
}

func (p *AnswerObjectHistory) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 12 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
	{
		l := binary.BigEndian.Uint32(data[8 : 8+4])
		data = data[12:]
		if uint64(len(data)) < uint64(l)*12 {
			goto overflow
		}
		nread += uint64(l) * 12
		p.HistoryList = make([]struct {
			Serial zodb.Tid
			Size   uint32
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.HistoryList[i]
			(*a).Serial = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
			(*a).Size = binary.BigEndian.Uint32(data[8 : 8+4])
			data = data[12:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 36. PartitionList

func (*PartitionList) NEOMsgCode() uint16 {
	return 36
}

func (p *PartitionList) NEOMsgEncodedLen() int {
	return 12
}

func (p *PartitionList) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.MinOffset)
	binary.BigEndian.PutUint32(data[4:], p.MaxOffset)
	binary.BigEndian.PutUint32(data[8:], uint32(int32(p.NodeUUID)))
}

func (p *PartitionList) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 12 {
		goto overflow
	}
	p.MinOffset = binary.BigEndian.Uint32(data[0 : 0+4])
	p.MaxOffset = binary.BigEndian.Uint32(data[4 : 4+4])
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[8 : 8+4])))
	return 12, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 36 | answerBit. AnswerPartitionList

func (*AnswerPartitionList) NEOMsgCode() uint16 {
	return 36 | answerBit
}

func (p *AnswerPartitionList) NEOMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]
		size += len((*a).CellList) * 5
	}
	return 12 + len(p.RowList)*4 + size
}

func (p *AnswerPartitionList) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[0:], l)
				data = data[4:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
					(data[4:])[0] = uint8(int8((*a).State))
					data = data[5:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerPartitionList) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 12 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0 : 0+8]))
	{
		l := binary.BigEndian.Uint32(data[8 : 8+4])
		data = data[12:]
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if len(data) < 4 {
				goto overflow
			}
			{
				l := binary.BigEndian.Uint32(data[0 : 0+4])
				data = data[4:]
				if uint64(len(data)) < uint64(l)*5 {
					goto overflow
				}
				nread += uint64(l) * 5
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0 : 0+4])))
					(*a).State = CellState(int8((data[4 : 4+1])[0]))
					data = data[5:]
				}
			}
		}
		nread += uint64(l) * 4
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 37. NodeList

func (*NodeList) NEOMsgCode() uint16 {
	return 37
}

func (p *NodeList) NEOMsgEncodedLen() int {
	return 1
}

func (p *NodeList) NEOMsgEncode(data []byte) {
	(data[0:])[0] = uint8(int8(p.NodeType))
}

func (p *NodeList) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 1 {
		goto overflow
	}
	p.NodeType = NodeType(int8((data[0 : 0+1])[0]))
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 37 | answerBit. AnswerNodeList

func (*AnswerNodeList) NEOMsgCode() uint16 {
	return 37 | answerBit
}

func (p *AnswerNodeList) NEOMsgEncodedLen() int {
	var size int
	for i := 0; i < len(p.NodeList); i++ {
		a := &p.NodeList[i]
		size += (*a).Addr.neoEncodedLen() + (*a).IdTime.neoEncodedLen()
	}
	return 4 + len(p.NodeList)*6 + size
}

func (p *AnswerNodeList) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(data[0:])[0] = uint8(int8((*a).Type))
			{
				n := (*a).Addr.neoEncode(data[1:])
				data = data[1+n:]
			}
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
			(data[4:])[0] = uint8(int8((*a).State))
			{
				n := (*a).IdTime.neoEncode(data[5:])
				data = data[5+n:]
			}
			data = data[0:]
		}
	}
}

func (p *AnswerNodeList) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		p.NodeList = make([]NodeInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			if len(data) < 1 {
				goto overflow
			}
			(*a).Type = NodeType(int8((data[0 : 0+1])[0]))
			data = data[1:]
			{
				n, ok := (*a).Addr.neoDecode(data)
				if !ok {
					goto overflow
				}
				data = data[n:]
				nread += n
			}
			if len(data) < 5 {
				goto overflow
			}
			(*a).UUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0 : 0+4])))
			(*a).State = NodeState(int8((data[4 : 4+1])[0]))
			data = data[5:]
			{
				n, ok := (*a).IdTime.neoDecode(data)
				if !ok {
					goto overflow
				}
				data = data[n:]
				nread += n
			}
		}
		nread += uint64(l) * 6
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 38. SetNodeState

func (*SetNodeState) NEOMsgCode() uint16 {
	return 38
}

func (p *SetNodeState) NEOMsgEncodedLen() int {
	return 5
}

func (p *SetNodeState) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeUUID)))
	(data[4:])[0] = uint8(int8(p.NodeState))
}

func (p *SetNodeState) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 5 {
		goto overflow
	}
	p.NodeUUID = NodeUUID(int32(binary.BigEndian.Uint32(data[0 : 0+4])))
	p.NodeState = NodeState(int8((data[4 : 4+1])[0]))
	return 5, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 39. AddPendingNodes

func (*AddPendingNodes) NEOMsgCode() uint16 {
	return 39
}

func (p *AddPendingNodes) NEOMsgEncodedLen() int {
	return 4 + len(p.NodeList)*4
}

func (p *AddPendingNodes) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *AddPendingNodes) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*4 {
			goto overflow
		}
		nread += uint64(l) * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0 : 0+4])))
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 40. TweakPartitionTable

func (*TweakPartitionTable) NEOMsgCode() uint16 {
	return 40
}

func (p *TweakPartitionTable) NEOMsgEncodedLen() int {
	return 4 + len(p.NodeList)*4
}

func (p *TweakPartitionTable) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *TweakPartitionTable) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*4 {
			goto overflow
		}
		nread += uint64(l) * 4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0 : 0+4])))
			data = data[4:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 41. SetNumReplicas

func (*SetNumReplicas) NEOMsgCode() uint16 {
	return 41
}

func (p *SetNumReplicas) NEOMsgEncodedLen() int {
	return 4
}

func (p *SetNumReplicas) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.NumReplicas)
}

func (p *SetNumReplicas) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.NumReplicas = binary.BigEndian.Uint32(data[0 : 0+4])
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 42. SetClusterState

func (*SetClusterState) NEOMsgCode() uint16 {
	return 42
}

func (p *SetClusterState) NEOMsgEncodedLen() int {
	return 1
}

func (p *SetClusterState) NEOMsgEncode(data []byte) {
	(data[0:])[0] = uint8(int8(p.State))
}

func (p *SetClusterState) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 1 {
		goto overflow
	}
	p.State = ClusterState(int8((data[0 : 0+1])[0]))
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 43. Repair

func (*Repair) NEOMsgCode() uint16 {
	return 43
}

func (p *Repair) NEOMsgEncodedLen() int {
	return 5 + len(p.NodeList)*4
}

func (p *Repair) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
	(data[0:])[0] = bool2byte(p.repairFlags.DryRun)
}

func (p *Repair) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < 1+uint64(l)*4 {
			goto overflow
		}
		nread += 1 + uint64(l)*4
		p.NodeList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0 : 0+4])))
			data = data[4:]
		}
	}
	p.repairFlags.DryRun = byte2bool((data[0 : 0+1])[0])
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 44. RepairOne

func (*RepairOne) NEOMsgCode() uint16 {
	return 44
}

func (p *RepairOne) NEOMsgEncodedLen() int {
	return 1
}

func (p *RepairOne) NEOMsgEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.repairFlags.DryRun)
}

func (p *RepairOne) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 1 {
		goto overflow
	}
	p.repairFlags.DryRun = byte2bool((data[0 : 0+1])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 45. NotifyClusterState

func (*NotifyClusterState) NEOMsgCode() uint16 {
	return 45
}

func (p *NotifyClusterState) NEOMsgEncodedLen() int {
	return 1
}

func (p *NotifyClusterState) NEOMsgEncode(data []byte) {
	(data[0:])[0] = uint8(int8(p.State))
}

func (p *NotifyClusterState) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 1 {
		goto overflow
	}
	p.State = ClusterState(int8((data[0 : 0+1])[0]))
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 46. AskClusterState

func (*AskClusterState) NEOMsgCode() uint16 {
	return 46
}

func (p *AskClusterState) NEOMsgEncodedLen() int {
	return 0
}

func (p *AskClusterState) NEOMsgEncode(data []byte) {
}

func (p *AskClusterState) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 46 | answerBit. AnswerClusterState

func (*AnswerClusterState) NEOMsgCode() uint16 {
	return 46 | answerBit
}

func (p *AnswerClusterState) NEOMsgEncodedLen() int {
	return 1
}

func (p *AnswerClusterState) NEOMsgEncode(data []byte) {
	(data[0:])[0] = uint8(int8(p.State))
}

func (p *AnswerClusterState) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 1 {
		goto overflow
	}
	p.State = ClusterState(int8((data[0 : 0+1])[0]))
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 47. ObjectUndoSerial

func (*ObjectUndoSerial) NEOMsgCode() uint16 {
	return 47
}

func (p *ObjectUndoSerial) NEOMsgEncodedLen() int {
	return 28 + len(p.OidList)*8
}

func (p *ObjectUndoSerial) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.UndoneTID))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[24:], l)
		data = data[28:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *ObjectUndoSerial) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 28 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.LTID = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	p.UndoneTID = zodb.Tid(binary.BigEndian.Uint64(data[16 : 16+8]))
	{
		l := binary.BigEndian.Uint32(data[24 : 24+4])
		data = data[28:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
			data = data[8:]
		}
	}
	return 28 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 47 | answerBit. AnswerObjectUndoSerial

func (*AnswerObjectUndoSerial) NEOMsgCode() uint16 {
	return 47 | answerBit
}

func (p *AnswerObjectUndoSerial) NEOMsgEncodedLen() int {
	return 4 + len(p.ObjectTIDDict)*25
}

func (p *AnswerObjectUndoSerial) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.ObjectTIDDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]zodb.Oid, 0, l)
		for key := range p.ObjectTIDDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			binary.BigEndian.PutUint64(data[8:], uint64(p.ObjectTIDDict[key].CurrentSerial))
			binary.BigEndian.PutUint64(data[16:], uint64(p.ObjectTIDDict[key].UndoSerial))
			(data[24:])[0] = bool2byte(p.ObjectTIDDict[key].IsCurrent)
			data = data[25:]
		}
	}
}

func (p *AnswerObjectUndoSerial) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*25 {
			goto overflow
		}
		nread += uint64(l) * 25
		p.ObjectTIDDict = make(map[zodb.Oid]struct {
			CurrentSerial zodb.Tid
			UndoSerial    zodb.Tid
			IsCurrent     bool
		}, l)
		m := p.ObjectTIDDict
		for i := 0; uint32(i) < l; i++ {
			key := zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
			var v struct {
				CurrentSerial zodb.Tid
				UndoSerial    zodb.Tid
				IsCurrent     bool
			}
			v.CurrentSerial = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
			v.UndoSerial = zodb.Tid(binary.BigEndian.Uint64(data[16 : 16+8]))
			v.IsCurrent = byte2bool((data[24 : 24+1])[0])
			m[key] = v
			data = data[25:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 48. AskTIDsFrom

func (*AskTIDsFrom) NEOMsgCode() uint16 {
	return 48
}

func (p *AskTIDsFrom) NEOMsgEncodedLen() int {
	return 24
}

func (p *AskTIDsFrom) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
	binary.BigEndian.PutUint32(data[16:], p.Length)
	binary.BigEndian.PutUint32(data[20:], p.Partition)
}

func (p *AskTIDsFrom) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 24 {
		goto overflow
	}
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	p.Length = binary.BigEndian.Uint32(data[16 : 16+4])
	p.Partition = binary.BigEndian.Uint32(data[20 : 20+4])
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 48 | answerBit. AnswerTIDsFrom

func (*AnswerTIDsFrom) NEOMsgCode() uint16 {
	return 48 | answerBit
}

func (p *AnswerTIDsFrom) NEOMsgEncodedLen() int {
	return 4 + len(p.TidList)*8
}

func (p *AnswerTIDsFrom) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.TidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTIDsFrom) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.TidList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
			data = data[8:]
		}
	}
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 49. Pack

func (*Pack) NEOMsgCode() uint16 {
	return 49
}

func (p *Pack) NEOMsgEncodedLen() int {
	return 8
}

func (p *Pack) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *Pack) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 49 | answerBit. AnswerPack

func (*AnswerPack) NEOMsgCode() uint16 {
	return 49 | answerBit
}

func (p *AnswerPack) NEOMsgEncodedLen() int {
	return 1
}

func (p *AnswerPack) NEOMsgEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Status)
}

func (p *AnswerPack) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 1 {
		goto overflow
	}
	p.Status = byte2bool((data[0 : 0+1])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 50. CheckReplicas

func (*CheckReplicas) NEOMsgCode() uint16 {
	return 50
}

func (p *CheckReplicas) NEOMsgEncodedLen() int {
	return 20 + len(p.PartitionDict)*8
}

func (p *CheckReplicas) NEOMsgEncode(data []byte) {
	{
		l := uint32(len(p.PartitionDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]uint32, 0, l)
		for key := range p.PartitionDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint32(data[0:], key)
			binary.BigEndian.PutUint32(data[4:], uint32(int32(p.PartitionDict[key])))
			data = data[8:]
		}
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *CheckReplicas) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 4 {
		goto overflow
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < 16+uint64(l)*8 {
			goto overflow
		}
		nread += 16 + uint64(l)*8
		p.PartitionDict = make(map[uint32]NodeUUID, l)
		m := p.PartitionDict
		for i := 0; uint32(i) < l; i++ {
			key := binary.BigEndian.Uint32(data[0 : 0+4])
			m[key] = NodeUUID(int32(binary.BigEndian.Uint32(data[4 : 4+4])))
			data = data[8:]
		}
	}
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	return 4 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 51. CheckPartition

func (*CheckPartition) NEOMsgCode() uint16 {
	return 51
}

func (p *CheckPartition) NEOMsgEncodedLen() int {
	return 24 + len(p.Source.UpstreamName) + p.Source.Address.neoEncodedLen()
}

func (p *CheckPartition) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	{
		l := uint32(len(p.Source.UpstreamName))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Source.UpstreamName)
		data = data[l:]
	}
	{
		n := p.Source.Address.neoEncode(data[0:])
		data = data[0+n:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *CheckPartition) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 8 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0 : 0+4])
	{
		l := binary.BigEndian.Uint32(data[4 : 4+4])
		data = data[8:]
		if uint64(len(data)) < uint64(l) {
			goto overflow
		}
		nread += uint64(l)
		p.Source.UpstreamName = string(data[:l])
		data = data[l:]
	}
	{
		n, ok := p.Source.Address.neoDecode(data)
		if !ok {
			goto overflow
		}
		data = data[n:]
		nread += n
	}
	if len(data) < 16 {
		goto overflow
	}
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	return 24 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 52. CheckTIDRange

func (*CheckTIDRange) NEOMsgCode() uint16 {
	return 52
}

func (p *CheckTIDRange) NEOMsgEncodedLen() int {
	return 24
}

func (p *CheckTIDRange) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTID))
}

func (p *CheckTIDRange) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 24 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0 : 0+4])
	p.Length = binary.BigEndian.Uint32(data[4 : 4+4])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[16 : 16+8]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 52 | answerBit. AnswerCheckTIDRange

func (*AnswerCheckTIDRange) NEOMsgCode() uint16 {
	return 52 | answerBit
}

func (p *AnswerCheckTIDRange) NEOMsgEncodedLen() int {
	return 32
}

func (p *AnswerCheckTIDRange) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Count)
	copy(data[4:], p.Checksum[:])
	binary.BigEndian.PutUint64(data[24:], uint64(p.MaxTID))
}

func (p *AnswerCheckTIDRange) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 32 {
		goto overflow
	}
	p.Count = binary.BigEndian.Uint32(data[0 : 0+4])
	copy(p.Checksum[:], data[4:24])
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[24 : 24+8]))
	return 32, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 53. CheckSerialRange

func (*CheckSerialRange) NEOMsgCode() uint16 {
	return 53
}

func (p *CheckSerialRange) NEOMsgEncodedLen() int {
	return 32
}

func (p *CheckSerialRange) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTID))
	binary.BigEndian.PutUint64(data[24:], uint64(p.MinOID))
}

func (p *CheckSerialRange) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 32 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0 : 0+4])
	p.Length = binary.BigEndian.Uint32(data[4 : 4+4])
	p.MinTID = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[16 : 16+8]))
	p.MinOID = zodb.Oid(binary.BigEndian.Uint64(data[24 : 24+8]))
	return 32, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 53 | answerBit. AnswerCheckSerialRange

func (*AnswerCheckSerialRange) NEOMsgCode() uint16 {
	return 53 | answerBit
}

func (p *AnswerCheckSerialRange) NEOMsgEncodedLen() int {
	return 60
}

func (p *AnswerCheckSerialRange) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Count)
	copy(data[4:], p.TidChecksum[:])
	binary.BigEndian.PutUint64(data[24:], uint64(p.MaxTID))
	copy(data[32:], p.OidChecksum[:])
	binary.BigEndian.PutUint64(data[52:], uint64(p.MaxOID))
}

func (p *AnswerCheckSerialRange) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 60 {
		goto overflow
	}
	p.Count = binary.BigEndian.Uint32(data[0 : 0+4])
	copy(p.TidChecksum[:], data[4:24])
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[24 : 24+8]))
	copy(p.OidChecksum[:], data[32:52])
	p.MaxOID = zodb.Oid(binary.BigEndian.Uint64(data[52 : 52+8]))
	return 60, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 54. PartitionCorrupted

func (*PartitionCorrupted) NEOMsgCode() uint16 {
	return 54
}

func (p *PartitionCorrupted) NEOMsgEncodedLen() int {
	return 8 + len(p.CellList)*4
}

func (p *PartitionCorrupted) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *PartitionCorrupted) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 8 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0 : 0+4])
	{
		l := binary.BigEndian.Uint32(data[4 : 4+4])
		data = data[8:]
		if uint64(len(data)) < uint64(l)*4 {
			goto overflow
		}
		nread += uint64(l) * 4
		p.CellList = make([]NodeUUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			(*a) = NodeUUID(int32(binary.BigEndian.Uint32(data[0 : 0+4])))
			data = data[4:]
		}
	}
	return 8 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 55. NotifyReady

func (*NotifyReady) NEOMsgCode() uint16 {
	return 55
}

func (p *NotifyReady) NEOMsgEncodedLen() int {
	return 0
}

func (p *NotifyReady) NEOMsgEncode(data []byte) {
}

func (p *NotifyReady) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 56. LastTransaction

func (*LastTransaction) NEOMsgCode() uint16 {
	return 56
}

func (p *LastTransaction) NEOMsgEncodedLen() int {
	return 0
}

func (p *LastTransaction) NEOMsgEncode(data []byte) {
}

func (p *LastTransaction) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// 56 | answerBit. AnswerLastTransaction

func (*AnswerLastTransaction) NEOMsgCode() uint16 {
	return 56 | answerBit
}

func (p *AnswerLastTransaction) NEOMsgEncodedLen() int {
	return 8
}

func (p *AnswerLastTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerLastTransaction) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 57. CheckCurrentSerial

func (*CheckCurrentSerial) NEOMsgCode() uint16 {
	return 57
}

func (p *CheckCurrentSerial) NEOMsgEncodedLen() int {
	return 24
}

func (p *CheckCurrentSerial) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.Serial))
}

func (p *CheckCurrentSerial) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 24 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[8 : 8+8]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[16 : 16+8]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 57 | answerBit. AnswerCheckCurrentSerial

func (*AnswerCheckCurrentSerial) NEOMsgCode() uint16 {
	return 57 | answerBit
}

func (p *AnswerCheckCurrentSerial) NEOMsgEncodedLen() int {
	return 8
}

func (p *AnswerCheckCurrentSerial) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.AnswerStoreObject.Conflict))
}

func (p *AnswerCheckCurrentSerial) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.AnswerStoreObject.Conflict = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 58. NotifyTransactionFinished

func (*NotifyTransactionFinished) NEOMsgCode() uint16 {
	return 58
}

func (p *NotifyTransactionFinished) NEOMsgEncodedLen() int {
	return 16
}

func (p *NotifyTransactionFinished) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *NotifyTransactionFinished) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 16 {
		goto overflow
	}
	p.TTID = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.MaxTID = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 59. Replicate

func (*Replicate) NEOMsgCode() uint16 {
	return 59
}

func (p *Replicate) NEOMsgEncodedLen() int {
	var size int
	for key := range p.SourceDict {
		size += len(p.SourceDict[key])
	}
	return 16 + len(p.UpstreamName) + len(p.SourceDict)*8 + size
}

func (p *Replicate) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.UpstreamName))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.UpstreamName)
		data = data[l:]
	}
	{
		l := uint32(len(p.SourceDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]uint32, 0, l)
		for key := range p.SourceDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint32(data[0:], key)
			{
				l := uint32(len(p.SourceDict[key]))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				copy(data, p.SourceDict[key])
				data = data[l:]
			}
			data = data[0:]
		}
	}
}

func (p *Replicate) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	{
		l := binary.BigEndian.Uint32(data[8 : 8+4])
		data = data[12:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.UpstreamName = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		p.SourceDict = make(map[uint32]string, l)
		m := p.SourceDict
		for i := 0; uint32(i) < l; i++ {
			if len(data) < 8 {
				goto overflow
			}
			key := binary.BigEndian.Uint32(data[0 : 0+4])
			{
				l := binary.BigEndian.Uint32(data[4 : 4+4])
				data = data[8:]
				if uint64(len(data)) < uint64(l) {
					goto overflow
				}
				nread += uint64(l)
				m[key] = string(data[:l])
				data = data[l:]
			}
		}
		nread += uint64(l) * 8
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 60. ReplicationDone

func (*ReplicationDone) NEOMsgCode() uint16 {
	return 60
}

func (p *ReplicationDone) NEOMsgEncodedLen() int {
	return 12
}

func (p *ReplicationDone) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Offset)
	binary.BigEndian.PutUint64(data[4:], uint64(p.Tid))
}

func (p *ReplicationDone) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 12 {
		goto overflow
	}
	p.Offset = binary.BigEndian.Uint32(data[0 : 0+4])
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[4 : 4+8]))
	return 12, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 61. FetchTransactions

func (*FetchTransactions) NEOMsgCode() uint16 {
	return 61
}

func (p *FetchTransactions) NEOMsgEncodedLen() int {
	return 28 + len(p.TxnKnownList)*8
}

func (p *FetchTransactions) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTid))
	{
		l := uint32(len(p.TxnKnownList))
		binary.BigEndian.PutUint32(data[24:], l)
		data = data[28:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TxnKnownList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *FetchTransactions) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 28 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0 : 0+4])
	p.Length = binary.BigEndian.Uint32(data[4 : 4+4])
	p.MinTid = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	p.MaxTid = zodb.Tid(binary.BigEndian.Uint64(data[16 : 16+8]))
	{
		l := binary.BigEndian.Uint32(data[24 : 24+4])
		data = data[28:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.TxnKnownList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TxnKnownList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
			data = data[8:]
		}
	}
	return 28 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 61 | answerBit. AnswerFetchTransactions

func (*AnswerFetchTransactions) NEOMsgCode() uint16 {
	return 61 | answerBit
}

func (p *AnswerFetchTransactions) NEOMsgEncodedLen() int {
	return 20 + len(p.TxnDeleteList)*8
}

func (p *AnswerFetchTransactions) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PackTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.NextTid))
	{
		l := uint32(len(p.TxnDeleteList))
		binary.BigEndian.PutUint32(data[16:], l)
		data = data[20:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TxnDeleteList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerFetchTransactions) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 20 {
		goto overflow
	}
	p.PackTid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.NextTid = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	{
		l := binary.BigEndian.Uint32(data[16 : 16+4])
		data = data[20:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.TxnDeleteList = make([]zodb.Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TxnDeleteList[i]
			(*a) = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
			data = data[8:]
		}
	}
	return 20 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 62. FetchObjects

func (*FetchObjects) NEOMsgCode() uint16 {
	return 62
}

func (p *FetchObjects) NEOMsgEncodedLen() int {
	var size int
	for key := range p.ObjKnownDict {
		size += len(p.ObjKnownDict[key]) * 8
	}
	return 36 + len(p.ObjKnownDict)*12 + size
}

func (p *FetchObjects) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTid))
	binary.BigEndian.PutUint64(data[24:], uint64(p.MinOid))
	{
		l := uint32(len(p.ObjKnownDict))
		binary.BigEndian.PutUint32(data[32:], l)
		data = data[36:]
		keyv := make([]zodb.Tid, 0, l)
		for key := range p.ObjKnownDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			{
				l := uint32(len(p.ObjKnownDict[key]))
				binary.BigEndian.PutUint32(data[8:], l)
				data = data[12:]
				for i := 0; uint32(i) < l; i++ {
					a := &p.ObjKnownDict[key][i]
					binary.BigEndian.PutUint64(data[0:], uint64((*a)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *FetchObjects) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 36 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0 : 0+4])
	p.Length = binary.BigEndian.Uint32(data[4 : 4+4])
	p.MinTid = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	p.MaxTid = zodb.Tid(binary.BigEndian.Uint64(data[16 : 16+8]))
	p.MinOid = zodb.Oid(binary.BigEndian.Uint64(data[24 : 24+8]))
	{
		l := binary.BigEndian.Uint32(data[32 : 32+4])
		data = data[36:]
		p.ObjKnownDict = make(map[zodb.Tid][]zodb.Oid, l)
		m := p.ObjKnownDict
		for i := 0; uint32(i) < l; i++ {
			if len(data) < 12 {
				goto overflow
			}
			key := zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
			var v []zodb.Oid
			{
				l := binary.BigEndian.Uint32(data[8 : 8+4])
				data = data[12:]
				if uint64(len(data)) < uint64(l)*8 {
					goto overflow
				}
				nread += uint64(l) * 8
				v = make([]zodb.Oid, l)
				for i := 0; uint32(i) < l; i++ {
					a := &v[i]
					(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
					data = data[8:]
				}
			}
			m[key] = v
		}
		nread += uint64(l) * 12
	}
	return 36 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 62 | answerBit. AnswerFetchObjects

func (*AnswerFetchObjects) NEOMsgCode() uint16 {
	return 62 | answerBit
}

func (p *AnswerFetchObjects) NEOMsgEncodedLen() int {
	var size int
	for key := range p.ObjDeleteDict {
		size += len(p.ObjDeleteDict[key]) * 8
	}
	return 28 + len(p.ObjDeleteDict)*12 + size
}

func (p *AnswerFetchObjects) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PackTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.NextTid))
	binary.BigEndian.PutUint64(data[16:], uint64(p.NextOid))
	{
		l := uint32(len(p.ObjDeleteDict))
		binary.BigEndian.PutUint32(data[24:], l)
		data = data[28:]
		keyv := make([]zodb.Tid, 0, l)
		for key := range p.ObjDeleteDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			{
				l := uint32(len(p.ObjDeleteDict[key]))
				binary.BigEndian.PutUint32(data[8:], l)
				data = data[12:]
				for i := 0; uint32(i) < l; i++ {
					a := &p.ObjDeleteDict[key][i]
					binary.BigEndian.PutUint64(data[0:], uint64((*a)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerFetchObjects) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 28 {
		goto overflow
	}
	p.PackTid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.NextTid = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	p.NextOid = zodb.Oid(binary.BigEndian.Uint64(data[16 : 16+8]))
	{
		l := binary.BigEndian.Uint32(data[24 : 24+4])
		data = data[28:]
		p.ObjDeleteDict = make(map[zodb.Tid][]zodb.Oid, l)
		m := p.ObjDeleteDict
		for i := 0; uint32(i) < l; i++ {
			if len(data) < 12 {
				goto overflow
			}
			key := zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
			var v []zodb.Oid
			{
				l := binary.BigEndian.Uint32(data[8 : 8+4])
				data = data[12:]
				if uint64(len(data)) < uint64(l)*8 {
					goto overflow
				}
				nread += uint64(l) * 8
				v = make([]zodb.Oid, l)
				for i := 0; uint32(i) < l; i++ {
					a := &v[i]
					(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
					data = data[8:]
				}
			}
			m[key] = v
		}
		nread += uint64(l) * 12
	}
	return 28 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 63. AddTransaction

func (*AddTransaction) NEOMsgCode() uint16 {
	return 63
}

func (p *AddTransaction) NEOMsgEncodedLen() int {
	return 33 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *AddTransaction) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	(data[0:])[0] = bool2byte(p.Packed)
	binary.BigEndian.PutUint64(data[1:], uint64(p.TTid))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[9:], l)
		data = data[13:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AddTransaction) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 12 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	{
		l := binary.BigEndian.Uint32(data[8 : 8+4])
		data = data[12:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.User = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < 4+uint64(l) {
			goto overflow
		}
		nread += 4 + uint64(l)
		p.Description = string(data[:l])
		data = data[l:]
	}
	{
		l := binary.BigEndian.Uint32(data[0 : 0+4])
		data = data[4:]
		if uint64(len(data)) < 13+uint64(l) {
			goto overflow
		}
		nread += 13 + uint64(l)
		p.Extension = string(data[:l])
		data = data[l:]
	}
	p.Packed = byte2bool((data[0 : 0+1])[0])
	p.TTid = zodb.Tid(binary.BigEndian.Uint64(data[1 : 1+8]))
	{
		l := binary.BigEndian.Uint32(data[9 : 9+4])
		data = data[13:]
		if uint64(len(data)) < uint64(l)*8 {
			goto overflow
		}
		nread += uint64(l) * 8
		p.OidList = make([]zodb.Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			(*a) = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
			data = data[8:]
		}
	}
	return 12 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 64. AddObject

func (*AddObject) NEOMsgCode() uint16 {
	return 64
}

func (p *AddObject) NEOMsgEncodedLen() int {
	return 49 + len(p.Data.XData())
}

func (p *AddObject) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	(data[16:])[0] = bool2byte(p.Compression)
	copy(data[17:], p.Checksum[:])
	{
		l := uint32(len(p.Data.XData()))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		copy(data, p.Data.XData())
		data = data[l:]
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
}

func (p *AddObject) NEOMsgDecode(data []byte) (int, error) {
	var nread uint64
	if len(data) < 41 {
		goto overflow
	}
	p.Oid = zodb.Oid(binary.BigEndian.Uint64(data[0 : 0+8]))
	p.Serial = zodb.Tid(binary.BigEndian.Uint64(data[8 : 8+8]))
	p.Compression = byte2bool((data[16 : 16+1])[0])
	copy(p.Checksum[:], data[17:37])
	{
		l := binary.BigEndian.Uint32(data[37 : 37+4])
		data = data[41:]
		if uint64(len(data)) < 8+uint64(l) {
			goto overflow
		}
		nread += 8 + uint64(l)
		p.Data = mem.BufAlloc(int(l))
		copy(p.Data.Data, data[:l])
		data = data[l:]
	}
	p.DataSerial = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 41 + int(nread), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 65. Truncate

func (*Truncate) NEOMsgCode() uint16 {
	return 65
}

func (p *Truncate) NEOMsgEncodedLen() int {
	return 8
}

func (p *Truncate) NEOMsgEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *Truncate) NEOMsgDecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = zodb.Tid(binary.BigEndian.Uint64(data[0 : 0+8]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 66. FlushLog

func (*FlushLog) NEOMsgCode() uint16 {
	return 66
}

func (p *FlushLog) NEOMsgEncodedLen() int {
	return 0
}

func (p *FlushLog) NEOMsgEncode(data []byte) {
}

func (p *FlushLog) NEOMsgDecode(data []byte) (int, error) {
	return 0, nil
}

// registry of message types
var msgTypeRegistry = map[uint16]reflect.Type{
	0 | answerBit:  reflect.TypeOf(Error{}),
	1:              reflect.TypeOf(RequestIdentification{}),
	1 | answerBit:  reflect.TypeOf(AcceptIdentification{}),
	2:              reflect.TypeOf(Ping{}),
	2 | answerBit:  reflect.TypeOf(Pong{}),
	3:              reflect.TypeOf(CloseClient{}),
	4:              reflect.TypeOf(PrimaryMaster{}),
	4 | answerBit:  reflect.TypeOf(AnswerPrimary{}),
	5:              reflect.TypeOf(NotPrimaryMaster{}),
	6:              reflect.TypeOf(NotifyNodeInformation{}),
	7:              reflect.TypeOf(Recovery{}),
	7 | answerBit:  reflect.TypeOf(AnswerRecovery{}),
	8:              reflect.TypeOf(LastIDs{}),
	8 | answerBit:  reflect.TypeOf(AnswerLastIDs{}),
	9:              reflect.TypeOf(AskPartitionTable{}),
	9 | answerBit:  reflect.TypeOf(AnswerPartitionTable{}),
	10:             reflect.TypeOf(SendPartitionTable{}),
	11:             reflect.TypeOf(NotifyPartitionChanges{}),
	12:             reflect.TypeOf(StartOperation{}),
	13:             reflect.TypeOf(StopOperation{}),
	14:             reflect.TypeOf(UnfinishedTransactions{}),
	14 | answerBit: reflect.TypeOf(AnswerUnfinishedTransactions{}),
	15:             reflect.TypeOf(LockedTransactions{}),
	15 | answerBit: reflect.TypeOf(AnswerLockedTransactions{}),
	16:             reflect.TypeOf(FinalTID{}),
	16 | answerBit: reflect.TypeOf(AnswerFinalTID{}),
	17:             reflect.TypeOf(ValidateTransaction{}),
	18:             reflect.TypeOf(BeginTransaction{}),
	18 | answerBit: reflect.TypeOf(AnswerBeginTransaction{}),
	19:             reflect.TypeOf(FailedVote{}),
	20:             reflect.TypeOf(FinishTransaction{}),
	20 | answerBit: reflect.TypeOf(AnswerTransactionFinished{}),
	21:             reflect.TypeOf(LockInformation{}),
	21 | answerBit: reflect.TypeOf(AnswerInformationLocked{}),
	22:             reflect.TypeOf(InvalidateObjects{}),
	23:             reflect.TypeOf(NotifyUnlockInformation{}),
	24:             reflect.TypeOf(AskNewOIDs{}),
	24 | answerBit: reflect.TypeOf(AnswerNewOIDs{}),
	25:             reflect.TypeOf(NotifyDeadlock{}),
	26:             reflect.TypeOf(RebaseTransaction{}),
	26 | answerBit: reflect.TypeOf(AnswerRebaseTransaction{}),
	27:             reflect.TypeOf(RebaseObject{}),
	27 | answerBit: reflect.TypeOf(AnswerRebaseObject{}),
	28:             reflect.TypeOf(StoreObject{}),
	28 | answerBit: reflect.TypeOf(AnswerStoreObject{}),
	29:             reflect.TypeOf(AbortTransaction{}),
	30:             reflect.TypeOf(StoreTransaction{}),
	30 | answerBit: reflect.TypeOf(AnswerStoreTransaction{}),
	31:             reflect.TypeOf(VoteTransaction{}),
	31 | answerBit: reflect.TypeOf(AnswerVoteTransaction{}),
	32:             reflect.TypeOf(GetObject{}),
	32 | answerBit: reflect.TypeOf(AnswerObject{}),
	33:             reflect.TypeOf(AskTIDs{}),
	33 | answerBit: reflect.TypeOf(AnswerTIDs{}),
	34:             reflect.TypeOf(TransactionInformation{}),
	34 | answerBit: reflect.TypeOf(AnswerTransactionInformation{}),
	35:             reflect.TypeOf(ObjectHistory{}),
	35 | answerBit: reflect.TypeOf(AnswerObjectHistory{}),
	36:             reflect.TypeOf(PartitionList{}),
	36 | answerBit: reflect.TypeOf(AnswerPartitionList{}),
	37:             reflect.TypeOf(NodeList{}),
	37 | answerBit: reflect.TypeOf(AnswerNodeList{}),
	38:             reflect.TypeOf(SetNodeState{}),
	39:             reflect.TypeOf(AddPendingNodes{}),
	40:             reflect.TypeOf(TweakPartitionTable{}),
	41:             reflect.TypeOf(SetNumReplicas{}),
	42:             reflect.TypeOf(SetClusterState{}),
	43:             reflect.TypeOf(Repair{}),
	44:             reflect.TypeOf(RepairOne{}),
	45:             reflect.TypeOf(NotifyClusterState{}),
	46:             reflect.TypeOf(AskClusterState{}),
	46 | answerBit: reflect.TypeOf(AnswerClusterState{}),
	47:             reflect.TypeOf(ObjectUndoSerial{}),
	47 | answerBit: reflect.TypeOf(AnswerObjectUndoSerial{}),
	48:             reflect.TypeOf(AskTIDsFrom{}),
	48 | answerBit: reflect.TypeOf(AnswerTIDsFrom{}),
	49:             reflect.TypeOf(Pack{}),
	49 | answerBit: reflect.TypeOf(AnswerPack{}),
	50:             reflect.TypeOf(CheckReplicas{}),
	51:             reflect.TypeOf(CheckPartition{}),
	52:             reflect.TypeOf(CheckTIDRange{}),
	52 | answerBit: reflect.TypeOf(AnswerCheckTIDRange{}),
	53:             reflect.TypeOf(CheckSerialRange{}),
	53 | answerBit: reflect.TypeOf(AnswerCheckSerialRange{}),
	54:             reflect.TypeOf(PartitionCorrupted{}),
	55:             reflect.TypeOf(NotifyReady{}),
	56:             reflect.TypeOf(LastTransaction{}),
	56 | answerBit: reflect.TypeOf(AnswerLastTransaction{}),
	57:             reflect.TypeOf(CheckCurrentSerial{}),
	57 | answerBit: reflect.TypeOf(AnswerCheckCurrentSerial{}),
	58:             reflect.TypeOf(NotifyTransactionFinished{}),
	59:             reflect.TypeOf(Replicate{}),
	60:             reflect.TypeOf(ReplicationDone{}),
	61:             reflect.TypeOf(FetchTransactions{}),
	61 | answerBit: reflect.TypeOf(AnswerFetchTransactions{}),
	62:             reflect.TypeOf(FetchObjects{}),
	62 | answerBit: reflect.TypeOf(AnswerFetchObjects{}),
	63:             reflect.TypeOf(AddTransaction{}),
	64:             reflect.TypeOf(AddObject{}),
	65:             reflect.TypeOf(Truncate{}),
	66:             reflect.TypeOf(FlushLog{}),
}
