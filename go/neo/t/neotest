#!/bin/bash -e
# neotest: run tests and benchmarks against FileStorage, ZEO and various NEO/py and NEO/go clusters

# Copyright (C) 2017-2018  Nexedi SA and Contributors.
#                          Kirill Smelkov <kirr@nexedi.com>
#
# This program is free software: you can Use, Study, Modify and Redistribute
# it under the terms of the GNU General Public License version 3, or (at your
# option) any later version, as published by the Free Software Foundation.
#
# You can also Link and Combine this program with other software covered by
# the terms of any of the Free Software licenses or any of the Open Source
# Initiative approved licenses and Convey the resulting work. Corresponding
# source of such a combination shall include the source code for all other
# software used.
#
# This program is distributed WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# See COPYING file for full licensing terms.
# See https://www.nexedi.com/licensing for rationale and options.

set -o pipefail

# ---- deploy NEO for tests/benchmarks at a node ----

die() {
	echo 2>&1 "$@"
	exit 1
}

# cmd_deploy [user@]<host>:<path>	- deploy NEO & needed software for tests there
# ssh-key or password for access should be available
cmd_deploy() {
	host=`echo $1 |sed -e 's/:[^:]*$//'`	# user@host
	path=${1:$((${#host} + 1))}		# path
	test -z "$host" -o -z "$path" && die "Usage: neotest deploy [user@]<host>:<path>"
	echo -e "\n*** deploying to $@ ..."
	scp $0 $host:neotest
	ssh $host ./neotest deploy-local "$path"
}

# cmd_deploy-local <path>		- deploy NEO & needed software for tests @path
cmd_deploy-local() {
	path=$1
	test -z "$path" && die "Usage: neotest deploy-local <path>"
	test -e $path/deployed && echo "# already deployed" && return
	mkdir -p $path
	cd $path

	# python part
	virtualenv venv

	# env.sh for deployment
	cat >env.sh << 'EOF'
X=${1:-${BASH_SOURCE[0]}}       # path to original env.sh is explicitly passed
X=$(cd `dirname $X` && pwd)     # when there is other env.sh wrapping us

export GOPATH=$X:$GOPATH
export PATH=$X/bin:$PATH
export PS1="(`basename $X`) $PS1"

# strip trailing : from $GOPATH
GOPATH=${GOPATH%:}

# python
. $X/venv/bin/activate

# ioping
export PATH=$X/ioping:$PATH

# XXX for mysqld
export PATH=$PATH:/sbin:/usr/sbin
EOF

	. env.sh

	pip install pygolang	# for tcpu.py

	mkdir -p src/lab.nexedi.com/kirr
	pushd src/lab.nexedi.com/kirr
	test -d neo || git clone -o kirr https://lab.nexedi.com/kirr/neo.git neo
	cd neo
	pip install -e .[admin,client,ctl,master,storage-sqlite,storage-mysqldb]
	popd

	go get -v -t lab.nexedi.com/kirr/neo/go/...
	go get -v golang.org/x/perf/cmd/benchstat		# to summarize/diff benchmark results
	#go get -v github.com/aclements/perflock/cmd/perflock	# handy to fix CPU frequency/etc

	git clone -o kirr -b x/hist https://lab.nexedi.com/kirr/ioping.git
	pushd ioping
	make -j`nproc`
	popd

	echo ok >deployed
	echo "# deployed ok"
}

# jump to deploy command early if we have to
case "$1" in
deploy|deploy-local)
	cmd="$1"
	shift
	cmd_$cmd "$@"
	exit
	;;
esac

# on <url> ...		- run ... on deployed url from inside dir of neotest
on() {
	#echo "on $@"
	host=`echo $1 |sed -e 's/:[^:]*$//'`	# user@host
	path=${1:$((${#host} + 1))}		# path
	test -z "$host" -o -z "$path" && die "on $1: invalid URL"
	shift
	ssh $host "bash -c \"test -e $path/deployed || { echo 1>&2 '$url not yet deployed'; exit 1; }
cd $path
. env.sh
#set -x
cd src/lab.nexedi.com/kirr/neo/go/neo/t
$@
\""
}

# ---- go/py unit tests ----
cmd_test-go() {
	go test lab.nexedi.com/kirr/neo/go/...
}

cmd_test-py() {
	# NOTE testing with only sqlite should be ok to check for client correctness
	NEO_TESTS_ADAPTER=SQLite python -m neo.scripts.runner -ufz
}

cmd_test-local() {
	cmd_test-go
	cmd_test-py
}

cmd_test() {
	url="$1"
	test -z "$url" && die "Usage neotest test [user@]<host>:<path>"
	on $url ./neotest test-local
}


# ---- net/fs setup + processes control/teardown ----

# init_net	- initialize networking
init_net() {
	# determine our external addresses IPv4 or IPv6
	# 2: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
	#     inet 192.168.102.52/24 brd 192.168.102.255 scope global dynamic wlan0
	#        valid_lft 82495sec preferred_lft 82495sec
	#
	# 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 state UNKNOWN qlen 1000
	#     inet6 2401:5180:0:37::1/64 scope global
	#        valid_lft forever preferred_lft forever
	# 2: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 state UP qlen 1000
	#     inet6 2401:5180:0:1d:429a:e612:c957:29/64 scope global noprefixroute dynamic
	#        valid_lft 86232sec preferred_lft 14232sec
	myaddr4v=(`ip -4 addr show scope global |grep inet |awk '{print $2}' |sed -e 's|/.*$||'`) || :
	myaddr6v=(`ip -6 addr show scope global |grep inet |awk '{print $2}' |sed -e 's|/.*$||'`) || :
	test "${#myaddr4v[@]}" -gt 0 || die "init_net: cannot determine my IPv4 network addresses"
	test "${#myaddr6v[@]}" -gt 0 || die "init_net: cannot determine my IPv6 network addresses"

	# prefer ipv4 for now
	myaddr="${myaddr4v[0]}"
}

# init_fs	- do initial disk allocations
init_fs() {
	log=`pwd`/log;		mkdir -p $log
	var=`pwd`/var;		mkdir -p $var
}

# if we are abnormally terminating
install_trap() {
	trap 'set +e
echo "E: abnormal termination - stopping..."
j="$(jobs -p)"
test -z "$j" && exit
echo "E: killing left jobs..."
jobs -l
kill $j' EXIT
}

# ---- information about system ----

# pyver <egg> (<showas>) - print version of egg
pyver() {
	local egg=$1
	local showas=$2
	test "$showas" == "" && showas=$egg
	local loc
	local pyver
	{
		read loc
		read pyver
	} < <(python -c "
import pkg_resources as p
try:
	e=p.require(\"$egg\")[0]
except p.DistributionNotFound:
	print(\"\nø\")
else:
	print(\"%s\n%s\" % (e.location, e.version))
	")
	local gitver=$(git -C $loc describe --long --dirty 2>/dev/null)
	local ver
	test "$gitver" != "" && ver="$gitver" || ver="$pyver"
	printf "sw/%-16s %s\n" "${showas}:" "$ver"
}

# proginfo <prog> ...	- run `prog ...` or print that prog is missing
proginfo() {
	prog=$1
	shift
	which $prog >/dev/null 2>&1 && $prog "$@" || printf "%-16s: ø\n" "$prog"
}

# fkghz file	- extract value from file (in KHz) and render it as GHz
fkghz() {
	python -c "print '%.2fGHz' % (`cat $1` / 1E6)"
}

# xhostname	- show short system host name
xhostname() {
	# prefer first part of FQDN for misconfigured systems like
	# fqdn=z6001.ivan.nexedi.com, hostname=z6001-COMP-2784
	fqdn=`hostname --fqdn 2>/dev/null || :`
	if test -n "$fqdn"; then
		echo "$fqdn" |sed -e 's/\./ /' |awk '{print $1}'
	else
		hostname
	fi
}

# show information about local system (os, hardware, versions, ...)
system_info() {
	echo -ne "date:\t"; date --rfc-2822
	echo -ne "xnode:\t`whoami`@`hostname --fqdn 2>/dev/null || hostname` ("
	echo -n "${myaddr6v[0]}"
	test "${#myaddr6v[@]}" -eq 1 || echo -n " (+ $((${#myaddr6v[@]} - 1))·ipv6)"
	echo -n " ${myaddr4v[0]}"
	test "${#myaddr4v[@]}" -eq 1 || echo -n " (+ $((${#myaddr4v[@]} - 1))·ipv4)"
	echo ")"
	echo -ne "uname:\t"; uname -a

	# cpu
	echo -ne "cpu:\t"; grep "^model name" /proc/cpuinfo |head -1 |sed -e 's/model name\s*: //'
	syscpu=/sys/devices/system/cpu
	sysidle=$syscpu/cpuidle

	cpuvabbrev() {	# cpuvabbrev cpu0 cpu1 cpu2 ... cpuN	-> cpu/[0-N]
		test $# -le 1 && echo "$@" && return

		min=""
		max=""
		while [ $# -ne 0 ]; do
			v=$1
			shift
			n=${v#cpu}

			test -z "$min" && min=$n && max=$n continue
			if (( $n != $max + 1 )); then
				die "cpuvabbrev: assert: nonconsecutive $max $n"
			fi
			max=$n
		done
		echo "cpu/[$min-$max]"
	}

	freqcpuv=()	# [] of cpu
	freqstr=""	# text about cpufreq for cpus in ^^^
	freqdump() {
		test "${#freqcpuv[@]}" = 0 && return
		echo "`cpuvabbrev ${freqcpuv[*]}`/freq: $freqstr"
		freqcpuv=()
		freqstr=""
	}

	idlecpuv=()	# ----//---- for cpuidle
	idlestr=""
	idledump() {
		test "${#idlecpuv[@]}" = 0 && return
		echo "`cpuvabbrev ${idlecpuv[*]}`/idle: $idlestr"
		idlecpuv=()
		idlestr=""
	}

	freqstable=y
	while read cpu; do
		f="$cpu/cpufreq"
		fmin=`fkghz $f/scaling_min_freq`
		fmax=`fkghz $f/scaling_max_freq`
		fs="`cat $f/scaling_driver`/`cat $f/scaling_governor` [$fmin - $fmax]"
		if [ "$fs" != "$freqstr" ]; then
			freqdump
			freqstr="$fs"
		fi
		freqcpuv+=(`basename $cpu`)
		test "$fmin" != "$fmax" && freqstable=n
	done \
	< <(ls -vd $syscpu/cpu[0-9]*)
	freqdump

	latmax=0
	while read cpu; do
		is="`cat $sysidle/current_driver`/`cat $sysidle/current_governor_ro`:"
		while read state; do
			is+=" "
			lat=`cat $state/latency`
			res=`cat $state/residency 2>/dev/null` || res="?"	# added in linux 3.15
			test "`cat $state/disable`" = "1" && is+="!" || latmax=$(($lat>$latmax?$lat:$latmax))
			is+="`cat $state/name`·${lat}/${res}"
		done \
		< <(ls -vd $cpu/cpuidle/state[0-9]*)

		is+=" # elat/tres µs"

		if [ "$is" != "$idlestr" ]; then
			idledump
			idlestr="$is"
		fi
		idlecpuv+=(`basename $cpu`)
	done \
	< <(ls -vd $syscpu/cpu[0-9]*)
	idledump

	test "$freqstable" = y || echo "WARNING: cpu: frequency not fixed - benchmark timings won't be stable"
	test "$latmax" -le 10  || {
		echo "WARNING: cpu: C-state exit-latency is max ${latmax}μs - benchmark timings won't be stable"
		echo "WARNING: cpu: (up to that might be adding to networked and IPC request-reply latency)"
	}


	# disk under .
	# TODO show all disks and just mark which is current
	mntpt=`stat -c '%m' .`				# mountpoint of current filesystem
	blkdev=`findmnt -n -o source -v -u $mntpt`	# mountpoint -> device
	blkdev=`realpath $blkdev`			# /dev/mapper/vg0-root	-> /dev/dm-0
	blkdev1=`basename $blkdev`			# /dev/sda  -> sda

	# showblk1 <device>
	showblk1() {
		blkdev=$1
		blkdev1=`basename $blkdev`			# /dev/sda  -> sda
		# XXX lsblk: tmpfs: not a block device
		printf "disk/%s: %s\n" "$blkdev1" "`lsblk -dn -o MODEL $blkdev`  rev `lsblk -dn -o REV,SIZE $blkdev`"
	}

	case "$blkdev1" in
	md*)
		# software raid
		slavev=`ls -x /sys/class/block/$blkdev1/slaves`
		printf "disk/%s:\t%s\n" "$blkdev1" "(`cat /sys/class/block/$blkdev1/md/level`) -> $slavev"
		# XXX dup wrt dm-*; move recursion to common place
		for s in $slavev; do
			s=`echo $s |sed -e 's/[0-9]*$//'`	# sda3 -> sda
			showblk1 /dev/$s
		done
		;;
	dm-*)
		# device mapper
		slavev=`ls -x /sys/class/block/$blkdev1/slaves`
		printf "disk/%s:\t%s\n" "$blkdev1" "(`cat /sys/class/block/$blkdev1/dm/name`) -> $slavev"
		# XXX dup wrt md*; move recursion to common place
		for s in $slavev; do
			s=`echo $s |sed -e 's/[0-9]*$//'`	# sda3 -> sda
			showblk1 /dev/$s
		done
		;;
	*)
		blkdev_main=`echo $blkdev |sed -e 's/[0-9]*$//'`	# /dev/sda3 -> /dev/sda
		showblk1 $blkdev_main
		;;
	esac

	printf "%-20s" "sw/python:";	proginfo python --version 2>&1	# https://bugs.python.org/issue18338
	printf "%-20s" "sw/go:";	proginfo go version
	printf "%-20s" "sw/sqlite:";	proginfo python -c \
		'import sqlite3 as s; print "sqlite %s (py mod %s)" % (s.sqlite_version, s.version)'
	printf "%-20s" "sw/mysqld:";	proginfo mysqld --version

	pyver neoppod neo
	pyver zodb
	pyver zeo
	pyver mysqlclient
}


# ---- benchmarking ----

# cpustat ...	- run ... and print CPU C-states statistic
cpustat() {
	# XXX +cpufreq transition statistics (CPU_FREQ_STAT) ?

	syscpu=/sys/devices/system/cpu
	cpuv=( `ls -vd $syscpu/cpu[0-9]*` )
	# XXX we assume cpuidle states are the same for all cpus and get list of them from cpu0
	statev=( `ls -vd ${cpuv[0]}/cpuidle/state[0-9]* |xargs -n 1 basename` )

	# get current [state]usage. usage for a state is summed across all cpus
	statev_usage() {
		usagev=()
		for s in ${statev[*]}; do
			#echo >&2 $s
			susage=0
			for u in `cat $syscpu/cpu[0-9]*/cpuidle/$s/usage`; do
				#echo -e >&2 "\t$u"
				((susage+=$u))
			done
			usagev+=($susage)
		done
		echo ${usagev[*]}
	}

	ustartv=( `statev_usage` )
	#echo >&2 "--------"
	#sleep 1
	ret=0
	out="$("$@" 2>&1)" || ret=$?
	uendv=( `statev_usage` )

	stat="#"
	for ((i=0;i<${#statev[*]};i++)); do
		s=${statev[$i]}
		sname=`cat ${cpuv[0]}/cpuidle/$s/name`
		du=$((${uendv[$i]} - ${ustartv[$i]}))
		#stat+=" $sname(+$du)"
		stat+=" $sname·$du"
		#stat+=" $du·$sname"
	done

	if [ `echo "$out" | wc -l` -gt 1 ]; then
		# multiline out - add another line
		echo "$out"
		echo "$stat"
	else
		# 1-line out	- add stats at line tail
		echo -n "$out"
		echo -e "\t$stat"
	fi

	return $ret
}

Nrun=5			# repeat benchmarks N time

#profile=
profile=cpustat

# nrun ...	- run ... $Nrun times serially
nrun() {
	for i in `seq $Nrun`; do
		$profile "$@"
	done
}

# bench_cpu	- microbenchmark CPU
bench_cpu() {
	echo -ne "node:\t"; xhostname
	echo     "cluster:"
	nrun sh -c "python -m test.pystone |tail -1 |sed -e \
		\"s|^This machine benchmarks at \([0-9.]\+\) pystones/second$|Benchmarkpystone 1 \1 pystone/s|\""

	sizev="4096"		# 1024 $((2*1024*1024))
	benchv="crc32 sha1"	# adler32
	for bench in $benchv; do
		for size in $sizev; do
			nrun tcpu.py $bench $size
			nrun tcpu_go $bench $size
		done
	done
}

# bench_disk	- benchmark direct (uncached) and cached random reads
bench_disk() {
	echo -ne "node:\t"; xhostname
	echo     "cluster:"
	# ioping2bench <topic>	- converts timings from ioping to std benchmark
	ioping2bench() {
		# min/avg/max/mdev = 102.2 us / 138.6 us / 403.3 us / 12.2 us
		sed -u -e \
		"s|^min/avg/max/mdev = \([0-9.]\+\) \([^ ]\+\) / \([0-9.]\+\) \([^ ]\+\) / \([0-9.]\+\)\+ \([^ ]\+\) / \([0-9.]\+\) \([^ ]\+\)\$|&\n\
Benchmark$1-min 1 \\1 \\2/op\n\
Benchmark$1-avg 1 \\3 \\4/op\
|"
	}

	sizev="4K"	# 2M (XXX it is not linear, but we save benchmarking time for now)
	benchtime=3s

	for size in $sizev; do
		echo -e "\n*** disk: random direct (no kernel cache) $size-read latency"
		nrun ioping -D -i 0ms -s $size -S 1024M -w $benchtime -q -k . |\
			ioping2bench "disk/randread/direct/$size"
	done


	# warmup so kernel puts the file into pagecache
	for i in `seq 3`; do
		cat ioping.tmp >/dev/null
	done

	for size in $sizev; do
		echo -e "\n*** disk: random cached $size-read latency"
		nrun ioping -C -i 0ms -s $size -S 1024M -w $benchtime -q -k . |\
			ioping2bench "disk/randread/pagecache/$size"
	done
}



# command: benchmark local disk
cmd_bench-disk() {
	bench_disk
}

# command: benchmark local cpu
cmd_bench-cpu() {
	bench_cpu
}

# command: print information about local node
cmd_info-local() {
	system_info
}

# command: print information about remote node
cmd_info() {
	url="$1"
	test -z "$url" && die "Usage neotest info [user@]<host>:<path>"
	on $url ./neotest info-local
}

# utility: cpustat on running arbitrary command
cmd_cpustat() {
	cpustat "$@"
}

# ---- main driver ----

usage() {
cat 1>&2 << EOF
Neotest is a tool to test and benchmark NEO.

Usage:

	neotest command [arguments]

The commands are:

	test		run all tests on a remote host
	test-local	run all tests locally

	test-go		run NEO/go unit tests	(part of test-local)
	test-py		run NEO/py unit tests	(part of test-local)


	bench-cpu	benchmark local cpu
	bench-disk	benchmark local disk


	deploy		deploy NEO & needed software for tests to remote host
	deploy-local	deploy NEO & needed software for tests locally

	info		print information about a node
	info-local	print information about local deployment

Additional utility commands:

	cpustat		run a command and print CPU-related statistics
EOF
}

# commands and their flags:
#
# build: needs to rebuild NEO stuff
# net:   needs init_net
# fs:    needs init_fs
case "$1" in
test)		f=(                     );;
test-local)	f=(build                );;
test-go)	f=(build                );;
test-py)	f=(                     );;

bench-cpu)	f=(build                );;
bench-disk)	f=(          fs         );;

info)		f=(                     );;
info-local)	f=(      net            );;

cpustat)	f=(                     );;

-h)
	usage
	exit 0
	;;
*)
	usage
	exit 1
	;;
esac


for flag in ${f[*]}; do
	case "$flag" in
	build)
		# make sure tcpu* is on PATH (because we could be invoked from another dir)
		X=$(cd `dirname $0` && pwd)
		export PATH=$X:$PATH

		# rebuild go bits
		# neo/py, wendelin.core, ... - must be pip install'ed - `neotest deploy` cares about that
		go install -v lab.nexedi.com/kirr/neo/go/...
		go build -o $X/tcpu_go $X/tcpu.go
		;;

	net)
		# setup network environment
		init_net
		;;

	fs)
		# setup fs environment
		init_fs
		;;

	*)
		die "internal-error: command $1: invalid flag: $flag"
		;;
	esac
done

# run the command
cmd="$1"
shift
cmd_$cmd "$@"
