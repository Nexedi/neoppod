#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (C) 2018  Nexedi SA and Contributors.
#                     Kirill Smelkov <kirr@nexedi.com>
#
# This program is free software: you can Use, Study, Modify and Redistribute
# it under the terms of the GNU General Public License version 3, or (at your
# option) any later version, as published by the Free Software Foundation.
#
# You can also Link and Combine this program with other software covered by
# the terms of any of the Free Software licenses or any of the Open Source
# Initiative approved licenses and Convey the resulting work. Corresponding
# source of such a combination shall include the source code for all other
# software used.
#
# This program is distributed WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# See COPYING file for full licensing terms.
# See https://www.nexedi.com/licensing for rationale and options.
"""benchplot - make scalability & difference plots from neotest benchmarks"""

import sys, re
import matplotlib.pyplot as plt
import matplotlib.patches
from collections import OrderedDict
from benchlib import load_file, Unit


# BenchSeries represents several runs of a benchmark with different "-<n>".
#
# .series is [] of (n, Stats)
class BenchSeries(object):
    def __init__(self, name, series):
        self.name   = name
        self.series = series


# SeriesSet is a collection of benchmark series.
#
# it is represented by {} name -> BenchSeries.
# all series have the same unit.
class SeriesSet(OrderedDict):
    def __init__(self, unit):
        super(SeriesSet, self).__init__()
        self.unit = unit


_n_re = re.compile(ur'.*(·\d+)$')

# seriesof extracts "·<n>" series from benchmark B.
#
# all values must have the same unit.
#
# returns -> SeriesSet | None.
def seriesof(B):
    S = SeriesSet(unit=None)
    Bn = B.byname()
    for name in Bn:
        m = _n_re.match(name)
        if m is None:
            continue    # no ·<n>

        name_ = name[:m.start(1)]   # without ·<n>
        n = m.group(1)
        n = n[1:]
        n = int(n)

        bs = S.get(name_)
        if bs is None:
            S[name_] = bs = BenchSeries(name_, [])

        stats = Bn[name].stats()
        if S.unit is None:
            S.unit = stats.unit
        if S.unit != stats.unit:
            raise ValueError('seriesof: different units: (%s, %s)' % (S.unit, stats.unit))
        bs.series.append((n, stats))

    if S.unit is None:
        return None # nothing found

    return S


# yticklabel_forvalue returns text for ytick label dedicated to showing particular value.
#
# it is a bit smaller in size and cares not to overlap with neighbours.
def yticklabel_forvalue(yv, yvprev, yvnext):
    # smaller in size (not to overload / overlap)
    # (NOTE our custom ticks are not at edges: i-1 and i+1 are always in range)
    if yv - yvprev > yvnext - yv:
        d = '_' # shift a bit down
        #d = '_^' # shift a bit down
    else:
        d = '^' # shift a bit up
        #d = '^_' # shift a bit up

    l = r'${}%s{%d}$' % (d, yv)
    #l = r'${}%s{{}%s{%d}}$' % (d[0], d[1], yv)

    return l


# plotseries makes plot of benchmark series how they change by "·<n>"
#
# S should be {} name -> BenchSeries.
#
# The whole plot is labeled as labkey.
def plotseries(labkey, S):
    plt.title("ZODB server handling read requests")

    # order plots (and thus their order in legend automatically) by value at "·1"
    namev = S.keys()
    namev.sort(key = lambda _: S[_].series[0][1].avg, reverse=True)
    xticks  = set()
    yticks0 = set()
    yticks_ = set()

    for name in namev:
        bs = S[name]
        x = [n for n,_ in bs.series]
        y = [s.avg for _,s in bs.series]
        err1 = [s.avg - s.min for _,s in bs.series]
        err2 = [s.max - s.avg for _,s in bs.series]
        # XXX ecolor='black'
        plt.errorbar(x, y, yerr=[err1, err2], capsize=2, label=name)

        # XXX fmt for line
        # XXX always use the same colors for the same lines (e.g. picking by hash)

        # remember n we saw in xticks
        for _ in x:
            xticks.add(_)

        # remember first and last values
        for _ in y[:1]:     # XXX with [:2] it becomes too noisy
            yticks0.add(int(_))
        yticks_.add(int(y[-1]))



    # first legend showing labels from labkey
    # https://matplotlib.org/tutorials/intermediate/legend_guide.html#multiple-legends-on-the-same-axes
    # r - invisible something
    r = matplotlib.patches.Rectangle((0,0), 1, 1, fill=False, edgecolor='none', visible=False)
    lh = [r] * len(labkey)
    ltext = ['%s: %s' % (k,v) for k,v in labkey]
    lablegend = plt.legend(lh, ltext, handlelength=0, handletextpad=0, loc="upper right")
    ax = plt.gca().add_artist(lablegend)

    # main legend about lines
    plt.legend(loc='upper left')

    plt.ylabel(S.unit)
    plt.xlabel("XXX number of clients running simultaneously")

    # mark every n we saw in xticks. we don't need other xticks besides that.
    xtickv = list(xticks)
    xtickv.sort()
    plt.xticks(xtickv)

    # mark first values with dedicated y ticks.
    yticks = set(plt.yticks()[0])
    yticks.update(yticks0)
    ytickv = list(yticks)
    ytickv.sort()
    yticklabv = []

    for i, _ in enumerate(ytickv):
        if _ not in yticks0:
            l = '%d' % _
        else:
            # (NOTE our custom ticks are not at edges: i-1 and i+1 are always in range)
            l = yticklabel_forvalue(_, ytickv[i-1], ytickv[i+1])

        yticklabv.append(l)

    plt.yticks(ytickv, yticklabv)

    # show on the right ticks for last y values
    ax2 = plt.twinx()
    yticks_.add(ytickv[0])  # min/max ticks from left, so that
    yticks_.add(ytickv[-1]) # scales at left and right match
    ytick_v = list(yticks_)
    ytick_v.sort()
    ytick_labv = []
    for i, _ in enumerate(ytick_v):
        if i in (0, len(ytick_v)-1):
            l = '%d' % _    # first/last
        else:
            l = yticklabel_forvalue(_, ytick_v[i-1], ytick_v[i+1])

        ytick_labv.append(l)

    ax2.set_yticks(ytick_v)
    ax2.set_yticklabels(ytick_labv)

    plt.show()






def main():
    B = load_file(sys.argv[1])
    splitby = ['dataset', 'cluster']

    Bl = B.bylabel(splitby)
    for labkey in Bl:
        # XXX req/s hardcoded. XXX other units?
        Bu = Bl[labkey].byunit()
        S = seriesof(Bu[Unit('req/s')])
        if S is None:
            continue    # nothing found

        # working directly with fs1 is very fast and makes seeing other variants hard.
        del S['fs1-zwrk.go']

        # only show !log for neo/py as this are faster
        for k in S.keys():
            m = re.match(r'.*(\(!log\)).*$', k)
            if m is None:
                continue

            k_ = k[:m.start(1)] + k[m.end(1):]  # without "(!log)"
            #print 'hide %s (have %s)' % (k_, k)
            S.pop(k_, None) # discard




        # XXX + nproc=...
        plotseries(labkey, S)




if __name__ == '__main__':
    main()
