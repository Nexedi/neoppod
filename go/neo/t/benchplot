#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (C) 2018  Nexedi SA and Contributors.
#                     Kirill Smelkov <kirr@nexedi.com>
#
# This program is free software: you can Use, Study, Modify and Redistribute
# it under the terms of the GNU General Public License version 3, or (at your
# option) any later version, as published by the Free Software Foundation.
#
# You can also Link and Combine this program with other software covered by
# the terms of any of the Free Software licenses or any of the Open Source
# Initiative approved licenses and Convey the resulting work. Corresponding
# source of such a combination shall include the source code for all other
# software used.
#
# This program is distributed WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# See COPYING file for full licensing terms.
# See https://www.nexedi.com/licensing for rationale and options.
"""benchplot - make scalability & difference plots from neotest benchmarks"""

import sys, re
from collections import OrderedDict
from benchlib import load_file, Unit

import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from mpl_toolkits.axes_grid1.inset_locator import zoomed_inset_axes, mark_inset, \
        TransformedBbox, BboxPatch, BboxConnectorPatch


# BenchSeries represents several runs of a benchmark with different "-<n>".
#
# .series is [] of (n, Stats)
class BenchSeries(object):
    def __init__(self, name, series):
        self.name   = name
        self.series = series


# SeriesSet is a collection of benchmark series.
#
# it is represented by {} name -> BenchSeries.
# all series have the same unit.
class SeriesSet(OrderedDict):
    def __init__(self, unit):
        super(SeriesSet, self).__init__()
        self.unit = unit


_n_re = re.compile(ur'.*(·\d+)$')

# seriesof extracts "·<n>" series from benchmark B.
#
# all values must have the same unit.
#
# returns -> SeriesSet | None.
def seriesof(B):
    S = SeriesSet(unit=None)
    Bn = B.byname()
    for name in Bn:
        m = _n_re.match(name)
        if m is None:
            continue    # no ·<n>

        name_ = name[:m.start(1)]   # without ·<n>
        n = m.group(1)
        n = n[1:]
        n = int(n)

        bs = S.get(name_)
        if bs is None:
            S[name_] = bs = BenchSeries(name_, [])

        stats = Bn[name].stats()
        if S.unit is None:
            S.unit = stats.unit
        if S.unit != stats.unit:
            raise ValueError('seriesof: different units: (%s, %s)' % (S.unit, stats.unit))
        bs.series.append((n, stats))

    if S.unit is None:
        return None # nothing found

    return S

# xseriesof, similarly to seriesof, extracts series from benchmark B, but omits non-interesting ones.
def xseriesof(B):
    S = seriesof(B)
    if S is None:
        return None

    # working directly with fs1 is very fast and makes seeing other variants hard.
    del S['fs1-zwrk.go']

    # only show !log for neo/py as this are faster
    for k in S.keys():
        m = re.match(r'.*(\(!log\)).*$', k)
        if m is None:
            continue

        k_ = k[:m.start(1)] + k[m.end(1):]  # without "(!log)"
        #print 'hide %s (have %s)' % (k_, k)
        S.pop(k_, None) # discard

    return S


# yticklabel_forvalue returns text for ytick label dedicated to showing particular value.
#
# it is a bit smaller in size and cares not to overlap with neighbours.
def yticklabel_forvalue(yv, yvprev, yvnext):
    # smaller in size (not to overload / overlap)
    # (NOTE our custom ticks are not at edges: i-1 and i+1 are always in range)
    if yv - yvprev > yvnext - yv:
        d = '_' # shift a bit down
        #d = '_^' # shift a bit down
    else:
        d = '^' # shift a bit up
        #d = '^_' # shift a bit up

    l = r'${}%s{%d}$' % (d, yv)
    #l = r'${}%s{{}%s{%d}}$' % (d[0], d[1], yv)

    return l




# stylefor is {} name -> Line2D style kw, so that we can always use e.g. the
# same colors for plots for the same server.
def _(**kw): return kw
stylefor = {
        'neo/go/fs1-zwrk.go':                   _(color='C0'),
        'neo/go/fs1(!sha1)-zwrk.go(!sha1)':     _(color='C0', ls='dashed'),
        'neo/go/sqlite-zwrk.go':                _(color='C1'),
        'neo/go/sqlite-zwrk.go(!sha1)':         _(color='C1', ls='dashed'),
        'zeo/py/fs1-zwrk.go':                   _(color='C2'),
        'neo/py(!log)/sqlite-zwrk.go':          _(color='C3'), # ls='dashed'), # XXX dashed?
        'neo/py(!log)/sql-zwrk.go':             _(color='C4'), # ls='dashed'), # XXX dashed?
}
del _

# r0 is invisible something
# (useful as e.g. proxy in text-only legend)
r0 = Rectangle((0,0), 1, 1, fill=False, edgecolor='none', visible=False)

# plotseries makes plot of benchmark series how they change by "·<n>"
#
# S should be {} name -> BenchSeries.
#
# The whole plot is labeled as labkey.      XXX <- no longer so
def plotseries(ax, labkey, S):
    #plt.title("ZODB server handling read requests")
    #plt.title("----")   # XXX don't use vspace

    # order plots (and thus their order in legend automatically) by value at "·1"
    namev = S.keys()
    namev.sort(key = lambda _: S[_].series[0][1].avg, reverse=True)
    xticks  = set()
    yticks0 = set()
    yticks_ = set()

    for name in namev:
        bs = S[name]
        x = [n for n,_ in bs.series]
        y = [s.avg for _,s in bs.series]
        err1 = [s.avg - s.min for _,s in bs.series]
        err2 = [s.max - s.avg for _,s in bs.series]
        # XXX ecolor='black'
        ax.errorbar(x, y, yerr=[err1, err2], capsize=2, label=name, **stylefor[name])

        # XXX fmt for line
        # XXX always use the same colors for the same lines (e.g. picking by hash)

        # remember n we saw in xticks
        for _ in x:
            xticks.add(_)

        # remember first and last values
        for _ in y[:1]:     # XXX with [:2] it becomes too noisy
            yticks0.add(int(_))
        yticks_.add(int(y[-1]))


    # first legend showing labels from labkey
    # https://matplotlib.org/tutorials/intermediate/legend_guide.html#multiple-legends-on-the-same-axes
    lh = [r0] * len(labkey)
    ltext = ['%s: %s' % (k,v) for k,v in labkey]
    #lablegend = plt.legend(lh, ltext, handlelength=0, handletextpad=0, loc="upper right")
    #ax = plt.gca().add_artist(lablegend)

    # main legend about lines
    ax.legend(loc='upper left')

    #plt.ylabel('%s (higher is better)' % S.unit)   # XXX
    #plt.xlabel("XXX number of clients running simultaneously")

    # mark every n we saw in xticks. we don't need other xticks besides that.
    xtickv = list(xticks)
    xtickv.sort()
    ax.set_xticks(xtickv)

    # mark first values with dedicated y ticks.
    yticks = set(ax.get_yticks())
    yticks.update(yticks0)
    ytickv = list(yticks)
    ytickv.sort()
    yticklabv = []

    for i, _ in enumerate(ytickv):
        if _ not in yticks0:
            l = '%d' % _
        else:
            yprev = (ytickv[i-1] if i > 0 else 0)
            ynext = (ytickv[i+1] if i + 1 < len(ytickv) else float('inf'))
            l = yticklabel_forvalue(_, yprev, ynext)

        yticklabv.append(l)

    ax.set_yticks(ytickv)
    ax.set_yticklabels(yticklabv)


    # always start y from 0 (it goes to -500 for latencies if auto)
    ax.set_ylim(bottom=0)


    # show on the right ticks for last y values
    ax2 = ax.twinx()
    ax2.set_ylim(ax.get_ylim()) # same y scale as on ax
    ytick_v = list(yticks_)
    ytick_v.sort()
    ytick_labv = []
    for i, _ in enumerate(ytick_v):
        yprev = (ytick_v[i-1] if i > 0 else 0)
        ynext = (ytick_v[i+1] if i + 1 < len(ytick_v) else float('inf'))
        l = yticklabel_forvalue(_, yprev, ynext)

        ytick_labv.append(l)

    ax2.set_yticks(ytick_v)
    ax2.set_yticklabels(ytick_labv)


# plotlat1 makes plot of benchmark latencies for serial (1 client) case.
def plotlat1(ax, S):
    # XXX use the same color/style for name as in different plot
    for name in S:
        b = S[name].series[0]
        if b[0] != 1:   # n
            continue

        s = b[1]    # stats

        # 1 hand-made error bar (cannot control line styles of cap lines with errorbar)
        w = 0.15
        lw = None
        ax.plot([1-w, 1+w], [s.min]*2, lw=lw, **stylefor[name])
        ax.plot([1-w, 1+w], [s.max]*2, lw=lw, **stylefor[name])
        ax.plot([1]*2, [s.min, s.max], lw=lw, **stylefor[name])

        #ax.legend() # XXX temp






def main():
    B = load_file(sys.argv[1])
    splitby = ['dataset', 'cluster']

    Bl = B.bylabel(splitby)
    for labkey in Bl:
        # FIXME hack
        if labkey == ():   # cpu benchmarks
            continue

        Bu = Bl[labkey].byunit()

        fig = plt.figure(figsize=(2*7.5,10))       # XXX figsize - temp?
        fig.suptitle("ZODB server handling read requests")
        fig.text(0.5, 0.04, "XXX number of clients running simultaneously", ha='center')


        ax1 = plt.subplot(121)
        ax1.set_title(u'#requests,  object/s  (↑ is better)')  # XXX add vspace between title and plot

        # XXX req/s hardcoded. XXX other units?
        Sreq = xseriesof(Bu[Unit('req/s')])
        if Sreq is not None:
            # XXX + nproc=...
            plotseries(ax1, labkey, Sreq)
        else:
            plt.text("xxx not found")


        ax2 = plt.subplot(122)
        ax2.set_title(u'latency,  µs/object  (↓ is better)')

        Slat = xseriesof(Bu[Unit(u'latency-µs/object')])
        if Slat is not None:
            # FIXME use same colors/styles for corresponding lines in ax1
            plotseries(ax2, labkey, Slat)

            # don't show legend in latency plot - instead show latency details for client=1
            ax2.legend().set_visible(False)

            ax21 = zoomed_inset_axes(ax2, 8, loc='upper left', borderpad=3.0)
            zlatmax = 200   # XXX hardcoded
            zxmin, zxmax = 0.8, 1.2     # XXX adjust?
            ax21.set_ylim(0, zlatmax)
            ax21.set_xlim(zxmin, zxmax)
            ax21.set_xticks([])
            ax21.set_xticklabels([])

            # vvv a bit adjusted mark_inset(ax2, ax21, ...) - to connect box'es the way we need
            rect = TransformedBbox(ax21.viewLim, ax2.transData)
            ax2.add_patch(BboxPatch(rect, fill=False, fc="none", ec="0.5", lw=0.5))
            ax2.add_patch(BboxConnectorPatch(ax21.bbox, rect, 3,2, 4,1, ec="0.5", lw=0.5))

            plotlat1(ax21, Slat)

        else:
            plt.text("xxx not found")


        #fig.legend()
        fig.legend([r0,r0], ["aaa", "bbb"])
        #fig.tight_layout()
        fig.subplots_adjust(
                left=0.05,     # no big marging on the left
                #wspace=0.1
        )

        plt.show()
        return      # XXX temp to show only first





if __name__ == '__main__':
    main()
