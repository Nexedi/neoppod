#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# TODO author/copyright
"""generate reference database and index for tests"""

from ZODB.FileStorage import FileStorage
from ZODB import DB
from persistent import Persistent
import transaction

import struct
import time
import random
import logging

# convert numeric oid to/from str
def p64(num):
    return struct.pack('>Q', num)

def unpack64(packed):
    return struct.unpack('>Q', packed)[0]

def hex64(packed):
    return '0x%016x' % unpack64(packed)

# escape string into valid "..." string
def escapeqq(s):
    # this escape almost everything except " character
    q = s.encode("string_escape")
    q = q.replace('"', r'\"')
    return '"' + q + '"'

# make time.time() predictable
_xtime = time.mktime(time.strptime("04 Jan 1979", "%d %b %Y"))
def xtime():
    global _xtime
    _xtime += 1.1
    return _xtime
time.time = xtime


def commit(user, description, extension):
    txn = transaction.get()
    txn.user = user
    txn.description = description
    txn.extension = extension
    txn.commit()

class Object(Persistent):
    # .value
    def __init__(self, value):
        self.value = value

    def __getstate__(self):
        return self.value

    def __setstate__(self, state):
        self.value = state

def main():
    logging.basicConfig()

    outfs = "testdata/1.fs"

    stor = FileStorage(outfs, create=True)
    db   = DB(stor)
    conn = db.open()
    root = conn.root()
    assert root._p_oid == p64(0), `root._p_oid`

    # generate random changes to objects hooked to top-level root by a/b/c/... key
    random.seed(0)

    namev = [_ for _ in "abcdefg"]
    for i in range(2):
        for j in range(25):
            name = random.choice(namev)
            if name in root:
                obj = root[name]
            else:
                root[name] = obj = Object(None)

            obj.value = "%s%i.%i" % (name, i, j)

            commit(u"user%i.%i" % (i,j), u"step %i.%i" % (i, j), {"x-generator": "zodb/py2 (%s)" % name})

        # undo a transaction one step before a latest one a couple of times
        for j in range(2):
            ul = db.undoLog(1, 2)[0]
            db.undo(ul["id"])
            commit(u"root%i.%i\nYour\nMagesty " % (i, j),
                   u"undo %i.%i\nmore detailed description\n\nzzz ..." % (i, j) + "\t"*(i+j),
                   {"x-generator": "zodb/py2 (undo %s)" % ul["id"]})

    # TODO delete an object

    conn.close()
    db.close()
    stor.close()

    # dump to go what to expect
    with open("testdata_expect_test.go", "w") as f:
        def emit(v):
            print >>f, v
        emit("// DO NOT EDIT - AUTOGENERATED (by py/gen-testdata)")
        emit("package fs1\n")

        # index
        emit("const _1fs_indexTopPos = %i" % stor._pos)
        emit("var _1fs_indexEntryv = [...]indexEntry{")
        for k, v in stor._index.iteritems():
            emit("\t{%8i, %8i}," % (unpack64(k), v))
        emit("}")

        # database records
        stor = FileStorage(outfs, read_only=True)

        emit("\nvar _1fs_dbEntryv = [...]dbEntry{")
        for txn in stor.iterator():     # txn is TransactionRecord
            # txn.extension is already depickled dict - we want to put raw data from file
            # also we need to access txn record legth which is not provided by higher-level iterator
            # do deep-dive into FileStorage
            th = stor._read_txn_header(txn._tpos)
            assert th.tid == txn.tid
            assert th.tlen == txn._tend - txn._tpos

            emit("\t{")

            # -> TxnHeader
            emit("\t\tTxnHeader{")
            emit("\t\t\tTid:\t%s," % hex64(txn.tid))
            emit("\t\t\tRecLenm8:\t%i," % th.tlen)
            emit("\t\t\tStatus:\t'%s'," % txn.status)
            emit("\t\t\tUser:\t\t[]byte(%s)," % escapeqq(txn.user))
            emit("\t\t\tDescription:\t[]byte(%s)," % escapeqq(txn.description))
            emit("\t\t\tExtension:\t[]byte(%s)," % escapeqq(th.ext))
            emit("\t\t},")

            # -> DataHeader + payload
            emit("\n\t\t[]txnEntry{")

            for drec in txn:            # drec is itemof(TransactionRecordIterator) = Record
                # same as with txn - not everything is possible to get via
                # higher-level api
                dh = stor._read_data_header(drec.pos)
                assert dh.oid == drec.oid
                assert dh.tid == drec.tid
                assert dh.tloc == txn._tpos

                emit("\t\t\t{")
                emit("\t\t\t\tDataHeader{")
                emit("\t\t\t\t\tOid:\t%i," % unpack64(drec.oid))
                emit("\t\t\t\t\tTid:\t%s," % hex64(drec.tid))
                # drec: .data .prev (=prev_txn)

                emit("\t\t\t\t\tPrevDataRecPos:\t%i," % dh.prev)
                emit("\t\t\t\t\tTxnPos:\t%i," % txn._tpos)
                assert drec.version == ''
                emit("\t\t\t\t\tDataLen:\t%i," % dh.plen)
                emit("\t\t\t\t},")
                plen = dh.plen
                if plen == 0:
                    data = p64(dh.back) # back-pointer or 0 (= delete)
                else:
                    data = drec.data

                emit("\t\t\t\t[]byte(%s)," % escapeqq(data))
                emit("\t\t\t},")

            emit("\t\t},")
            emit("\t},")
        emit("}")


if __name__ == '__main__':
    main()
