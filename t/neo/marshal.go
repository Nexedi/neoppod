// DO NOT EDIT - AUTOGENERATED (by protogen.go)

package neo

import (
	"encoding/binary"
	"sort"
)

// 0. Address

func (p *Address) NEOEncodedLen() int {
	return 6 + len(p.Host)
}

func (p *Address) NEOEncode(data []byte) {
	{
		l := uint32(len(p.Host))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Port)
}

func (p *Address) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.Host = string(data[:l])
		data = data[l:]
		nread0 += 4 + l
	}
	if len(data) < 2 {
		goto overflow
	}
	p.Port = binary.BigEndian.Uint16(data[0:])
	return 2 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 1. NodeInfo

func (p *NodeInfo) NEOEncodedLen() int {
	return 26 + len(p.Address.Host)
}

func (p *NodeInfo) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
	{
		l := uint32(len(p.Address.Host))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Address.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Address.Port)
	binary.BigEndian.PutUint32(data[2:], uint32(int32(p.UUID)))
	binary.BigEndian.PutUint32(data[6:], uint32(int32(p.NodeState)))
	float64_NEOEncode(data[10:], p.IdTimestamp)
}

func (p *NodeInfo) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 4 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	{
		if len(data) < 8 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.Address.Host = string(data[:l])
		data = data[l:]
		nread0 += 8 + l
	}
	if len(data) < 2 {
		goto overflow
	}
	p.Address.Port = binary.BigEndian.Uint16(data[0:])
	if len(data) < 6 {
		goto overflow
	}
	p.UUID = UUID(int32(binary.BigEndian.Uint32(data[2:])))
	if len(data) < 10 {
		goto overflow
	}
	p.NodeState = NodeState(int32(binary.BigEndian.Uint32(data[6:])))
	if len(data) < 18 {
		goto overflow
	}
	p.IdTimestamp = float64_NEODecode(data[10:])
	return 18 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 2. CellInfo

func (p *CellInfo) NEOEncodedLen() int {
	return 8
}

func (p *CellInfo) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.UUID)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.CellState)))
}

func (p *CellInfo) NEODecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.UUID = UUID(int32(binary.BigEndian.Uint32(data[0:])))
	if len(data) < 8 {
		goto overflow
	}
	p.CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 3. RowInfo

func (p *RowInfo) NEOEncodedLen() int {
	return 8 + len(p.CellList)*8
}

func (p *RowInfo) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Offset)
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
			binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
			data = data[8:]
		}
	}
}

func (p *RowInfo) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 4 {
		goto overflow
	}
	p.Offset = binary.BigEndian.Uint32(data[0:])
	{
		if len(data) < 8 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		nread0 += 8
		p.CellList = make([]CellInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			if len(data) < 4 {
				goto overflow
			}
			(*a).UUID = UUID(int32(binary.BigEndian.Uint32(data[0:])))
			if len(data) < 8 {
				goto overflow
			}
			(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
			data = data[8:]
			nread0 += 8
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 4. Notify

func (p *Notify) NEOEncodedLen() int {
	return 4 + len(p.Message)
}

func (p *Notify) NEOEncode(data []byte) {
	{
		l := uint32(len(p.Message))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Message)
		data = data[l:]
	}
}

func (p *Notify) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.Message = string(data[:l])
		data = data[l:]
		nread0 += 4 + l
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 5. Error

func (p *Error) NEOEncodedLen() int {
	return 8 + len(p.Message)
}

func (p *Error) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Code)
	{
		l := uint32(len(p.Message))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Message)
		data = data[l:]
	}
}

func (p *Error) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 4 {
		goto overflow
	}
	p.Code = binary.BigEndian.Uint32(data[0:])
	{
		if len(data) < 8 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.Message = string(data[:l])
		data = data[l:]
		nread0 += 8 + l
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 6. Ping

func (p *Ping) NEOEncodedLen() int {
	return 0
}

func (p *Ping) NEOEncode(data []byte) {
}

func (p *Ping) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 7. CloseClient

func (p *CloseClient) NEOEncodedLen() int {
	return 0
}

func (p *CloseClient) NEOEncode(data []byte) {
}

func (p *CloseClient) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 8. RequestIdentification

func (p *RequestIdentification) NEOEncodedLen() int {
	return 30 + len(p.Address.Host) + len(p.Name)
}

func (p *RequestIdentification) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.ProtocolVersion)
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.NodeType)))
	binary.BigEndian.PutUint32(data[8:], uint32(int32(p.UUID)))
	{
		l := uint32(len(p.Address.Host))
		binary.BigEndian.PutUint32(data[12:], l)
		data = data[16:]
		copy(data, p.Address.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Address.Port)
	{
		l := uint32(len(p.Name))
		binary.BigEndian.PutUint32(data[2:], l)
		data = data[6:]
		copy(data, p.Name)
		data = data[l:]
	}
	float64_NEOEncode(data[0:], p.IdTimestamp)
}

func (p *RequestIdentification) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 4 {
		goto overflow
	}
	p.ProtocolVersion = binary.BigEndian.Uint32(data[0:])
	if len(data) < 8 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[4:])))
	if len(data) < 12 {
		goto overflow
	}
	p.UUID = UUID(int32(binary.BigEndian.Uint32(data[8:])))
	{
		if len(data) < 16 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[12:])
		data = data[16:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.Address.Host = string(data[:l])
		data = data[l:]
		nread0 += 16 + l
	}
	if len(data) < 2 {
		goto overflow
	}
	p.Address.Port = binary.BigEndian.Uint16(data[0:])
	{
		if len(data) < 6 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[2:])
		data = data[6:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.Name = string(data[:l])
		data = data[l:]
		nread0 += 6 + l
	}
	if len(data) < 8 {
		goto overflow
	}
	p.IdTimestamp = float64_NEODecode(data[0:])
	return 8 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 9. AcceptIdentification

func (p *AcceptIdentification) NEOEncodedLen() int {
	var size0 int
	for i := 0; i < len(p.KnownMasterList); i++ {
		a := &p.KnownMasterList[i]

		size0 += 10 + len((*a).Address.Host)
	}
	return 30 + len(p.Primary.Host) + size0
}

func (p *AcceptIdentification) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.MyUUID)))
	binary.BigEndian.PutUint32(data[8:], p.NumPartitions)
	binary.BigEndian.PutUint32(data[12:], p.NumReplicas)
	binary.BigEndian.PutUint32(data[16:], uint32(int32(p.YourUUID)))
	{
		l := uint32(len(p.Primary.Host))
		binary.BigEndian.PutUint32(data[20:], l)
		data = data[24:]
		copy(data, p.Primary.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Primary.Port)
	{
		l := uint32(len(p.KnownMasterList))
		binary.BigEndian.PutUint32(data[2:], l)
		data = data[6:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.KnownMasterList[i]
			{
				l := uint32(len((*a).Address.Host))
				binary.BigEndian.PutUint32(data[0:], l)
				data = data[4:]
				copy(data, (*a).Address.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Address.Port)
			binary.BigEndian.PutUint32(data[2:], uint32(int32((*a).UUID)))
			data = data[6:]
		}
	}
}

func (p *AcceptIdentification) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 4 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	if len(data) < 8 {
		goto overflow
	}
	p.MyUUID = UUID(int32(binary.BigEndian.Uint32(data[4:])))
	if len(data) < 12 {
		goto overflow
	}
	p.NumPartitions = binary.BigEndian.Uint32(data[8:])
	if len(data) < 16 {
		goto overflow
	}
	p.NumReplicas = binary.BigEndian.Uint32(data[12:])
	if len(data) < 20 {
		goto overflow
	}
	p.YourUUID = UUID(int32(binary.BigEndian.Uint32(data[16:])))
	{
		if len(data) < 24 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[20:])
		data = data[24:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.Primary.Host = string(data[:l])
		data = data[l:]
		nread0 += 24 + l
	}
	if len(data) < 2 {
		goto overflow
	}
	p.Primary.Port = binary.BigEndian.Uint16(data[0:])
	{
		if len(data) < 6 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[2:])
		data = data[6:]
		nread0 += 6
		p.KnownMasterList = make([]struct {
			Address
			UUID UUID
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.KnownMasterList[i]
			{
				if len(data) < 4 {
					goto overflow
				}
				l := binary.BigEndian.Uint32(data[0:])
				data = data[4:]
				if uint32(len(data)) < l {
					goto overflow
				}
				(*a).Address.Host = string(data[:l])
				data = data[l:]
				nread0 += 4 + l
			}
			if len(data) < 2 {
				goto overflow
			}
			(*a).Address.Port = binary.BigEndian.Uint16(data[0:])
			if len(data) < 6 {
				goto overflow
			}
			(*a).UUID = UUID(int32(binary.BigEndian.Uint32(data[2:])))
			data = data[6:]
			nread0 += 6
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 10. PrimaryMaster

func (p *PrimaryMaster) NEOEncodedLen() int {
	return 0
}

func (p *PrimaryMaster) NEOEncode(data []byte) {
}

func (p *PrimaryMaster) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 11. AnswerPrimary

func (p *AnswerPrimary) NEOEncodedLen() int {
	return 4
}

func (p *AnswerPrimary) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.PrimaryUUID)))
}

func (p *AnswerPrimary) NEODecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.PrimaryUUID = UUID(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 12. AnnouncePrimary

func (p *AnnouncePrimary) NEOEncodedLen() int {
	return 0
}

func (p *AnnouncePrimary) NEOEncode(data []byte) {
}

func (p *AnnouncePrimary) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 13. ReelectPrimary

func (p *ReelectPrimary) NEOEncodedLen() int {
	return 0
}

func (p *ReelectPrimary) NEOEncode(data []byte) {
}

func (p *ReelectPrimary) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 14. Recovery

func (p *Recovery) NEOEncodedLen() int {
	return 0
}

func (p *Recovery) NEOEncode(data []byte) {
}

func (p *Recovery) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 15. AnswerRecovery

func (p *AnswerRecovery) NEOEncodedLen() int {
	return 24
}

func (p *AnswerRecovery) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.BackupTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.TruncateTID))
}

func (p *AnswerRecovery) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.BackupTID = Tid(binary.BigEndian.Uint64(data[8:]))
	if len(data) < 24 {
		goto overflow
	}
	p.TruncateTID = Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 16. LastIDs

func (p *LastIDs) NEOEncodedLen() int {
	return 0
}

func (p *LastIDs) NEOEncode(data []byte) {
}

func (p *LastIDs) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 17. AnswerLastIDs

func (p *AnswerLastIDs) NEOEncodedLen() int {
	return 16
}

func (p *AnswerLastIDs) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.LastOID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LastTID))
}

func (p *AnswerLastIDs) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.LastOID = Oid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.LastTID = Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 18. PartitionTable

func (p *PartitionTable) NEOEncodedLen() int {
	return 0
}

func (p *PartitionTable) NEOEncode(data []byte) {
}

func (p *PartitionTable) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 19. AnswerPartitionTable

func (p *AnswerPartitionTable) NEOEncodedLen() int {
	var size0 int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]

		size0 += 8 + len((*a).CellList)*8
	}
	return 12 + size0
}

func (p *AnswerPartitionTable) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerPartitionTable) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 8 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		if len(data) < 12 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		nread0 += 12
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if len(data) < 4 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				if len(data) < 8 {
					goto overflow
				}
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				nread0 += 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					if len(data) < 4 {
						goto overflow
					}
					(*a).UUID = UUID(int32(binary.BigEndian.Uint32(data[0:])))
					if len(data) < 8 {
						goto overflow
					}
					(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
					nread0 += 8
				}
			}
			data = data[0:]
			nread0 += 0
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 20. NotifyPartitionTable

func (p *NotifyPartitionTable) NEOEncodedLen() int {
	var size0 int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]

		size0 += 8 + len((*a).CellList)*8
	}
	return 12 + size0
}

func (p *NotifyPartitionTable) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *NotifyPartitionTable) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 8 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		if len(data) < 12 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		nread0 += 12
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if len(data) < 4 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				if len(data) < 8 {
					goto overflow
				}
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				nread0 += 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					if len(data) < 4 {
						goto overflow
					}
					(*a).UUID = UUID(int32(binary.BigEndian.Uint32(data[0:])))
					if len(data) < 8 {
						goto overflow
					}
					(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
					nread0 += 8
				}
			}
			data = data[0:]
			nread0 += 0
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 21. PartitionChanges

func (p *PartitionChanges) NEOEncodedLen() int {
	return 12 + len(p.CellList)*12
}

func (p *PartitionChanges) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).UUID)))
			binary.BigEndian.PutUint32(data[8:], uint32(int32((*a).CellState)))
			data = data[12:]
		}
	}
}

func (p *PartitionChanges) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 8 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		if len(data) < 12 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		nread0 += 12
		p.CellList = make([]struct {
			Offset    uint32
			UUID      UUID
			CellState CellState
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			if len(data) < 4 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			if len(data) < 8 {
				goto overflow
			}
			(*a).UUID = UUID(int32(binary.BigEndian.Uint32(data[4:])))
			if len(data) < 12 {
				goto overflow
			}
			(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[8:])))
			data = data[12:]
			nread0 += 12
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 22. StartOperation

func (p *StartOperation) NEOEncodedLen() int {
	return 1
}

func (p *StartOperation) NEOEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Backup)
}

func (p *StartOperation) NEODecode(data []byte) (int, error) {
	if len(data) < 1 {
		goto overflow
	}
	p.Backup = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 23. StopOperation

func (p *StopOperation) NEOEncodedLen() int {
	return 0
}

func (p *StopOperation) NEOEncode(data []byte) {
}

func (p *StopOperation) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 24. UnfinishedTransactions

func (p *UnfinishedTransactions) NEOEncodedLen() int {
	return 0
}

func (p *UnfinishedTransactions) NEOEncode(data []byte) {
}

func (p *UnfinishedTransactions) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 25. AnswerUnfinishedTransactions

func (p *AnswerUnfinishedTransactions) NEOEncodedLen() int {
	return 12 + len(p.TidList)*8
}

func (p *AnswerUnfinishedTransactions) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.MaxTID))
	{
		l := uint32(len(p.TidList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a).UnfinishedTID))
			data = data[8:]
		}
	}
}

func (p *AnswerUnfinishedTransactions) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 8 {
		goto overflow
	}
	p.MaxTID = Tid(binary.BigEndian.Uint64(data[0:]))
	{
		if len(data) < 12 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		nread0 += 12
		p.TidList = make([]struct{ UnfinishedTID Tid }, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			if len(data) < 8 {
				goto overflow
			}
			(*a).UnfinishedTID = Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
			nread0 += 8
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 26. LockedTransactions

func (p *LockedTransactions) NEOEncodedLen() int {
	return 0
}

func (p *LockedTransactions) NEOEncode(data []byte) {
}

func (p *LockedTransactions) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 27. AnswerLockedTransactions

func (p *AnswerLockedTransactions) NEOEncodedLen() int {
	return 4 + len(p.TidDict)*16
}

func (p *AnswerLockedTransactions) NEOEncode(data []byte) {
	{
		l := uint32(len(p.TidDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]Tid, 0, l)
		for key := range p.TidDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			binary.BigEndian.PutUint64(data[8:], uint64(p.TidDict[key]))
			data = data[16:]
		}
	}
}

func (p *AnswerLockedTransactions) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		nread0 += 4
		p.TidDict = make(map[Tid]Tid, l)
		m := p.TidDict
		for i := 0; uint32(i) < l; i++ {
			if len(data) < 8 {
				goto overflow
			}
			key := Tid(binary.BigEndian.Uint64(data[0:]))
			if len(data) < 16 {
				goto overflow
			}
			m[key] = Tid(binary.BigEndian.Uint64(data[8:]))
			data = data[16:]
			nread0 += 16
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 28. FinalTID

func (p *FinalTID) NEOEncodedLen() int {
	return 8
}

func (p *FinalTID) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
}

func (p *FinalTID) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.TTID = Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 29. AnswerFinalTID

func (p *AnswerFinalTID) NEOEncodedLen() int {
	return 8
}

func (p *AnswerFinalTID) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerFinalTID) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 30. ValidateTransaction

func (p *ValidateTransaction) NEOEncodedLen() int {
	return 16
}

func (p *ValidateTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *ValidateTransaction) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.TTID = Tid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 31. BeginTransaction

func (p *BeginTransaction) NEOEncodedLen() int {
	return 8
}

func (p *BeginTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *BeginTransaction) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 32. AnswerBeginTransaction

func (p *AnswerBeginTransaction) NEOEncodedLen() int {
	return 8
}

func (p *AnswerBeginTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerBeginTransaction) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 33. FinishTransaction

func (p *FinishTransaction) NEOEncodedLen() int {
	return 16 + len(p.OIDList)*8 + len(p.CheckedList)*8
}

func (p *FinishTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.OIDList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OIDList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
	{
		l := uint32(len(p.CheckedList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CheckedList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *FinishTransaction) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	{
		if len(data) < 12 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		nread0 += 12
		p.OIDList = make([]Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OIDList[i]
			if len(data) < 8 {
				goto overflow
			}
			(*a) = Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
			nread0 += 8
		}
	}
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		nread0 += 4
		p.CheckedList = make([]Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CheckedList[i]
			if len(data) < 8 {
				goto overflow
			}
			(*a) = Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
			nread0 += 8
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 34. AnswerFinishTransaction

func (p *AnswerFinishTransaction) NEOEncodedLen() int {
	return 16
}

func (p *AnswerFinishTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *AnswerFinishTransaction) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.TTID = Tid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 35. NotifyTransactionFinished

func (p *NotifyTransactionFinished) NEOEncodedLen() int {
	return 16
}

func (p *NotifyTransactionFinished) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *NotifyTransactionFinished) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.TTID = Tid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.MaxTID = Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 36. LockInformation

func (p *LockInformation) NEOEncodedLen() int {
	return 16
}

func (p *LockInformation) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Ttid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
}

func (p *LockInformation) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Ttid = Tid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 37. AnswerLockInformation

func (p *AnswerLockInformation) NEOEncodedLen() int {
	return 8
}

func (p *AnswerLockInformation) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Ttid))
}

func (p *AnswerLockInformation) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Ttid = Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 38. InvalidateObjects

func (p *InvalidateObjects) NEOEncodedLen() int {
	return 12 + len(p.OidList)*8
}

func (p *InvalidateObjects) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *InvalidateObjects) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	{
		if len(data) < 12 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		nread0 += 12
		p.OidList = make([]Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			if len(data) < 8 {
				goto overflow
			}
			(*a) = Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
			nread0 += 8
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 39. UnlockInformation

func (p *UnlockInformation) NEOEncodedLen() int {
	return 8
}

func (p *UnlockInformation) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.TTID))
}

func (p *UnlockInformation) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.TTID = Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 40. GenerateOIDs

func (p *GenerateOIDs) NEOEncodedLen() int {
	return 4
}

func (p *GenerateOIDs) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.NumOIDs)
}

func (p *GenerateOIDs) NEODecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.NumOIDs = binary.BigEndian.Uint32(data[0:])
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 41. AnswerGenerateOIDs

func (p *AnswerGenerateOIDs) NEOEncodedLen() int {
	return 4 + len(p.OidList)*8
}

func (p *AnswerGenerateOIDs) NEOEncode(data []byte) {
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerGenerateOIDs) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		nread0 += 4
		p.OidList = make([]Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			if len(data) < 8 {
				goto overflow
			}
			(*a) = Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
			nread0 += 8
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 42. StoreObject

func (p *StoreObject) NEOEncodedLen() int {
	return 58 + len(p.Data)*1
}

func (p *StoreObject) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	(data[16:])[0] = bool2byte(p.Compression)
	(data[17:])[0] = p.Checksum[0]
	(data[18:])[0] = p.Checksum[1]
	(data[19:])[0] = p.Checksum[2]
	(data[20:])[0] = p.Checksum[3]
	(data[21:])[0] = p.Checksum[4]
	(data[22:])[0] = p.Checksum[5]
	(data[23:])[0] = p.Checksum[6]
	(data[24:])[0] = p.Checksum[7]
	(data[25:])[0] = p.Checksum[8]
	(data[26:])[0] = p.Checksum[9]
	(data[27:])[0] = p.Checksum[10]
	(data[28:])[0] = p.Checksum[11]
	(data[29:])[0] = p.Checksum[12]
	(data[30:])[0] = p.Checksum[13]
	(data[31:])[0] = p.Checksum[14]
	(data[32:])[0] = p.Checksum[15]
	(data[33:])[0] = p.Checksum[16]
	(data[34:])[0] = p.Checksum[17]
	(data[35:])[0] = p.Checksum[18]
	(data[36:])[0] = p.Checksum[19]
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[37:], l)
		data = data[41:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.Data[i]
			(data[0:])[0] = (*a)
			data = data[1:]
		}
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Tid))
	(data[16:])[0] = bool2byte(p.Unlock)
}

func (p *StoreObject) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 8 {
		goto overflow
	}
	p.Oid = Oid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.Serial = Tid(binary.BigEndian.Uint64(data[8:]))
	if len(data) < 17 {
		goto overflow
	}
	p.Compression = byte2bool((data[16:])[0])
	if len(data) < 18 {
		goto overflow
	}
	p.Checksum[0] = (data[17:])[0]
	if len(data) < 19 {
		goto overflow
	}
	p.Checksum[1] = (data[18:])[0]
	if len(data) < 20 {
		goto overflow
	}
	p.Checksum[2] = (data[19:])[0]
	if len(data) < 21 {
		goto overflow
	}
	p.Checksum[3] = (data[20:])[0]
	if len(data) < 22 {
		goto overflow
	}
	p.Checksum[4] = (data[21:])[0]
	if len(data) < 23 {
		goto overflow
	}
	p.Checksum[5] = (data[22:])[0]
	if len(data) < 24 {
		goto overflow
	}
	p.Checksum[6] = (data[23:])[0]
	if len(data) < 25 {
		goto overflow
	}
	p.Checksum[7] = (data[24:])[0]
	if len(data) < 26 {
		goto overflow
	}
	p.Checksum[8] = (data[25:])[0]
	if len(data) < 27 {
		goto overflow
	}
	p.Checksum[9] = (data[26:])[0]
	if len(data) < 28 {
		goto overflow
	}
	p.Checksum[10] = (data[27:])[0]
	if len(data) < 29 {
		goto overflow
	}
	p.Checksum[11] = (data[28:])[0]
	if len(data) < 30 {
		goto overflow
	}
	p.Checksum[12] = (data[29:])[0]
	if len(data) < 31 {
		goto overflow
	}
	p.Checksum[13] = (data[30:])[0]
	if len(data) < 32 {
		goto overflow
	}
	p.Checksum[14] = (data[31:])[0]
	if len(data) < 33 {
		goto overflow
	}
	p.Checksum[15] = (data[32:])[0]
	if len(data) < 34 {
		goto overflow
	}
	p.Checksum[16] = (data[33:])[0]
	if len(data) < 35 {
		goto overflow
	}
	p.Checksum[17] = (data[34:])[0]
	if len(data) < 36 {
		goto overflow
	}
	p.Checksum[18] = (data[35:])[0]
	if len(data) < 37 {
		goto overflow
	}
	p.Checksum[19] = (data[36:])[0]
	{
		if len(data) < 41 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[37:])
		data = data[41:]
		nread0 += 41
		p.Data = make([]byte, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.Data[i]
			if len(data) < 1 {
				goto overflow
			}
			(*a) = (data[0:])[0]
			data = data[1:]
			nread0 += 1
		}
	}
	if len(data) < 8 {
		goto overflow
	}
	p.DataSerial = Tid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[8:]))
	if len(data) < 17 {
		goto overflow
	}
	p.Unlock = byte2bool((data[16:])[0])
	return 17 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 43. AnswerStoreObject

func (p *AnswerStoreObject) NEOEncodedLen() int {
	return 17
}

func (p *AnswerStoreObject) NEOEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Conflicting)
	binary.BigEndian.PutUint64(data[1:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[9:], uint64(p.Serial))
}

func (p *AnswerStoreObject) NEODecode(data []byte) (int, error) {
	if len(data) < 1 {
		goto overflow
	}
	p.Conflicting = byte2bool((data[0:])[0])
	if len(data) < 9 {
		goto overflow
	}
	p.Oid = Oid(binary.BigEndian.Uint64(data[1:]))
	if len(data) < 17 {
		goto overflow
	}
	p.Serial = Tid(binary.BigEndian.Uint64(data[9:]))
	return 17, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 44. AbortTransaction

func (p *AbortTransaction) NEOEncodedLen() int {
	return 8
}

func (p *AbortTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AbortTransaction) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 45. StoreTransaction

func (p *StoreTransaction) NEOEncodedLen() int {
	return 24 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *StoreTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *StoreTransaction) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	{
		if len(data) < 12 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.User = string(data[:l])
		data = data[l:]
		nread0 += 12 + l
	}
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.Description = string(data[:l])
		data = data[l:]
		nread0 += 4 + l
	}
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.Extension = string(data[:l])
		data = data[l:]
		nread0 += 4 + l
	}
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		nread0 += 4
		p.OidList = make([]Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			if len(data) < 8 {
				goto overflow
			}
			(*a) = Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
			nread0 += 8
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 46. VoteTransaction

func (p *VoteTransaction) NEOEncodedLen() int {
	return 8
}

func (p *VoteTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *VoteTransaction) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 47. GetObject

func (p *GetObject) NEOEncodedLen() int {
	return 24
}

func (p *GetObject) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[16:], uint64(p.Tid))
}

func (p *GetObject) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Oid = Oid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.Serial = Tid(binary.BigEndian.Uint64(data[8:]))
	if len(data) < 24 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 48. AnswerGetObject

func (p *AnswerGetObject) NEOEncodedLen() int {
	return 57 + len(p.Data)*1
}

func (p *AnswerGetObject) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.SerialStart))
	binary.BigEndian.PutUint64(data[16:], uint64(p.SerialEnd))
	(data[24:])[0] = bool2byte(p.Compression)
	(data[25:])[0] = p.Checksum[0]
	(data[26:])[0] = p.Checksum[1]
	(data[27:])[0] = p.Checksum[2]
	(data[28:])[0] = p.Checksum[3]
	(data[29:])[0] = p.Checksum[4]
	(data[30:])[0] = p.Checksum[5]
	(data[31:])[0] = p.Checksum[6]
	(data[32:])[0] = p.Checksum[7]
	(data[33:])[0] = p.Checksum[8]
	(data[34:])[0] = p.Checksum[9]
	(data[35:])[0] = p.Checksum[10]
	(data[36:])[0] = p.Checksum[11]
	(data[37:])[0] = p.Checksum[12]
	(data[38:])[0] = p.Checksum[13]
	(data[39:])[0] = p.Checksum[14]
	(data[40:])[0] = p.Checksum[15]
	(data[41:])[0] = p.Checksum[16]
	(data[42:])[0] = p.Checksum[17]
	(data[43:])[0] = p.Checksum[18]
	(data[44:])[0] = p.Checksum[19]
	{
		l := uint32(len(p.Data))
		binary.BigEndian.PutUint32(data[45:], l)
		data = data[49:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.Data[i]
			(data[0:])[0] = (*a)
			data = data[1:]
		}
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.DataSerial))
}

func (p *AnswerGetObject) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 8 {
		goto overflow
	}
	p.Oid = Oid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.SerialStart = Tid(binary.BigEndian.Uint64(data[8:]))
	if len(data) < 24 {
		goto overflow
	}
	p.SerialEnd = Tid(binary.BigEndian.Uint64(data[16:]))
	if len(data) < 25 {
		goto overflow
	}
	p.Compression = byte2bool((data[24:])[0])
	if len(data) < 26 {
		goto overflow
	}
	p.Checksum[0] = (data[25:])[0]
	if len(data) < 27 {
		goto overflow
	}
	p.Checksum[1] = (data[26:])[0]
	if len(data) < 28 {
		goto overflow
	}
	p.Checksum[2] = (data[27:])[0]
	if len(data) < 29 {
		goto overflow
	}
	p.Checksum[3] = (data[28:])[0]
	if len(data) < 30 {
		goto overflow
	}
	p.Checksum[4] = (data[29:])[0]
	if len(data) < 31 {
		goto overflow
	}
	p.Checksum[5] = (data[30:])[0]
	if len(data) < 32 {
		goto overflow
	}
	p.Checksum[6] = (data[31:])[0]
	if len(data) < 33 {
		goto overflow
	}
	p.Checksum[7] = (data[32:])[0]
	if len(data) < 34 {
		goto overflow
	}
	p.Checksum[8] = (data[33:])[0]
	if len(data) < 35 {
		goto overflow
	}
	p.Checksum[9] = (data[34:])[0]
	if len(data) < 36 {
		goto overflow
	}
	p.Checksum[10] = (data[35:])[0]
	if len(data) < 37 {
		goto overflow
	}
	p.Checksum[11] = (data[36:])[0]
	if len(data) < 38 {
		goto overflow
	}
	p.Checksum[12] = (data[37:])[0]
	if len(data) < 39 {
		goto overflow
	}
	p.Checksum[13] = (data[38:])[0]
	if len(data) < 40 {
		goto overflow
	}
	p.Checksum[14] = (data[39:])[0]
	if len(data) < 41 {
		goto overflow
	}
	p.Checksum[15] = (data[40:])[0]
	if len(data) < 42 {
		goto overflow
	}
	p.Checksum[16] = (data[41:])[0]
	if len(data) < 43 {
		goto overflow
	}
	p.Checksum[17] = (data[42:])[0]
	if len(data) < 44 {
		goto overflow
	}
	p.Checksum[18] = (data[43:])[0]
	if len(data) < 45 {
		goto overflow
	}
	p.Checksum[19] = (data[44:])[0]
	{
		if len(data) < 49 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[45:])
		data = data[49:]
		nread0 += 49
		p.Data = make([]byte, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.Data[i]
			if len(data) < 1 {
				goto overflow
			}
			(*a) = (data[0:])[0]
			data = data[1:]
			nread0 += 1
		}
	}
	if len(data) < 8 {
		goto overflow
	}
	p.DataSerial = Tid(binary.BigEndian.Uint64(data[0:]))
	return 8 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 49. TIDList

func (p *TIDList) NEOEncodedLen() int {
	return 20
}

func (p *TIDList) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], p.First)
	binary.BigEndian.PutUint64(data[8:], p.Last)
	binary.BigEndian.PutUint32(data[16:], p.Partition)
}

func (p *TIDList) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.First = binary.BigEndian.Uint64(data[0:])
	if len(data) < 16 {
		goto overflow
	}
	p.Last = binary.BigEndian.Uint64(data[8:])
	if len(data) < 20 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[16:])
	return 20, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 50. AnswerTIDList

func (p *AnswerTIDList) NEOEncodedLen() int {
	return 4 + len(p.TIDList)*8
}

func (p *AnswerTIDList) NEOEncode(data []byte) {
	{
		l := uint32(len(p.TIDList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TIDList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTIDList) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		nread0 += 4
		p.TIDList = make([]Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TIDList[i]
			if len(data) < 8 {
				goto overflow
			}
			(*a) = Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
			nread0 += 8
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 51. TIDListFrom

func (p *TIDListFrom) NEOEncodedLen() int {
	return 24
}

func (p *TIDListFrom) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
	binary.BigEndian.PutUint32(data[16:], p.Length)
	binary.BigEndian.PutUint32(data[20:], p.Partition)
}

func (p *TIDListFrom) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.MinTID = Tid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.MaxTID = Tid(binary.BigEndian.Uint64(data[8:]))
	if len(data) < 20 {
		goto overflow
	}
	p.Length = binary.BigEndian.Uint32(data[16:])
	if len(data) < 24 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[20:])
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 52. AnswerTIDListFrom

func (p *AnswerTIDListFrom) NEOEncodedLen() int {
	return 4 + len(p.TidList)*8
}

func (p *AnswerTIDListFrom) NEOEncode(data []byte) {
	{
		l := uint32(len(p.TidList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTIDListFrom) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		nread0 += 4
		p.TidList = make([]Tid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.TidList[i]
			if len(data) < 8 {
				goto overflow
			}
			(*a) = Tid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
			nread0 += 8
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 53. TransactionInformation

func (p *TransactionInformation) NEOEncodedLen() int {
	return 8
}

func (p *TransactionInformation) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *TransactionInformation) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 54. AnswerTransactionInformation

func (p *AnswerTransactionInformation) NEOEncodedLen() int {
	return 25 + len(p.User) + len(p.Description) + len(p.Extension) + len(p.OidList)*8
}

func (p *AnswerTransactionInformation) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	{
		l := uint32(len(p.User))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		copy(data, p.User)
		data = data[l:]
	}
	{
		l := uint32(len(p.Description))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Description)
		data = data[l:]
	}
	{
		l := uint32(len(p.Extension))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Extension)
		data = data[l:]
	}
	(data[0:])[0] = bool2byte(p.Packed)
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[1:], l)
		data = data[5:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *AnswerTransactionInformation) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	{
		if len(data) < 12 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.User = string(data[:l])
		data = data[l:]
		nread0 += 12 + l
	}
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.Description = string(data[:l])
		data = data[l:]
		nread0 += 4 + l
	}
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.Extension = string(data[:l])
		data = data[l:]
		nread0 += 4 + l
	}
	if len(data) < 1 {
		goto overflow
	}
	p.Packed = byte2bool((data[0:])[0])
	{
		if len(data) < 5 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[1:])
		data = data[5:]
		nread0 += 5
		p.OidList = make([]Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			if len(data) < 8 {
				goto overflow
			}
			(*a) = Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
			nread0 += 8
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 55. ObjectHistory

func (p *ObjectHistory) NEOEncodedLen() int {
	return 24
}

func (p *ObjectHistory) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[8:], p.First)
	binary.BigEndian.PutUint64(data[16:], p.Last)
}

func (p *ObjectHistory) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Oid = Oid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.First = binary.BigEndian.Uint64(data[8:])
	if len(data) < 24 {
		goto overflow
	}
	p.Last = binary.BigEndian.Uint64(data[16:])
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 56. AnswerObjectHistory

func (p *AnswerObjectHistory) NEOEncodedLen() int {
	return 12 + len(p.HistoryList)*12
}

func (p *AnswerObjectHistory) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	{
		l := uint32(len(p.HistoryList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.HistoryList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a).Serial))
			binary.BigEndian.PutUint32(data[8:], (*a).Size)
			data = data[12:]
		}
	}
}

func (p *AnswerObjectHistory) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 8 {
		goto overflow
	}
	p.Oid = Oid(binary.BigEndian.Uint64(data[0:]))
	{
		if len(data) < 12 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		nread0 += 12
		p.HistoryList = make([]struct {
			Serial Tid
			Size   uint32
		}, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.HistoryList[i]
			if len(data) < 8 {
				goto overflow
			}
			(*a).Serial = Tid(binary.BigEndian.Uint64(data[0:]))
			if len(data) < 12 {
				goto overflow
			}
			(*a).Size = binary.BigEndian.Uint32(data[8:])
			data = data[12:]
			nread0 += 12
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 57. PartitionList

func (p *PartitionList) NEOEncodedLen() int {
	return 12
}

func (p *PartitionList) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.MinOffset)
	binary.BigEndian.PutUint32(data[4:], p.MaxOffset)
	binary.BigEndian.PutUint32(data[8:], uint32(int32(p.UUID)))
}

func (p *PartitionList) NEODecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.MinOffset = binary.BigEndian.Uint32(data[0:])
	if len(data) < 8 {
		goto overflow
	}
	p.MaxOffset = binary.BigEndian.Uint32(data[4:])
	if len(data) < 12 {
		goto overflow
	}
	p.UUID = UUID(int32(binary.BigEndian.Uint32(data[8:])))
	return 12, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 58. AnswerPartitionList

func (p *AnswerPartitionList) NEOEncodedLen() int {
	var size0 int
	for i := 0; i < len(p.RowList); i++ {
		a := &p.RowList[i]

		size0 += 8 + len((*a).CellList)*8
	}
	return 12 + size0
}

func (p *AnswerPartitionList) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.PTid))
	{
		l := uint32(len(p.RowList))
		binary.BigEndian.PutUint32(data[8:], l)
		data = data[12:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			binary.BigEndian.PutUint32(data[0:], (*a).Offset)
			{
				l := uint32(len((*a).CellList))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).UUID)))
					binary.BigEndian.PutUint32(data[4:], uint32(int32((*a).CellState)))
					data = data[8:]
				}
			}
			data = data[0:]
		}
	}
}

func (p *AnswerPartitionList) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 8 {
		goto overflow
	}
	p.PTid = PTid(binary.BigEndian.Uint64(data[0:]))
	{
		if len(data) < 12 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[8:])
		data = data[12:]
		nread0 += 12
		p.RowList = make([]RowInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.RowList[i]
			if len(data) < 4 {
				goto overflow
			}
			(*a).Offset = binary.BigEndian.Uint32(data[0:])
			{
				if len(data) < 8 {
					goto overflow
				}
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				nread0 += 8
				(*a).CellList = make([]CellInfo, l)
				for i := 0; uint32(i) < l; i++ {
					a := &(*a).CellList[i]
					if len(data) < 4 {
						goto overflow
					}
					(*a).UUID = UUID(int32(binary.BigEndian.Uint32(data[0:])))
					if len(data) < 8 {
						goto overflow
					}
					(*a).CellState = CellState(int32(binary.BigEndian.Uint32(data[4:])))
					data = data[8:]
					nread0 += 8
				}
			}
			data = data[0:]
			nread0 += 0
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 59. X_NodeList

func (p *X_NodeList) NEOEncodedLen() int {
	return 4
}

func (p *X_NodeList) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.NodeType)))
}

func (p *X_NodeList) NEODecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 60. AnswerNodeList

func (p *AnswerNodeList) NEOEncodedLen() int {
	var size0 int
	for i := 0; i < len(p.NodeList); i++ {
		a := &p.NodeList[i]

		size0 += 26 + len((*a).Address.Host)
	}
	return 4 + size0
}

func (p *AnswerNodeList) NEOEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeType)))
			{
				l := uint32(len((*a).Address.Host))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				copy(data, (*a).Address.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Address.Port)
			binary.BigEndian.PutUint32(data[2:], uint32(int32((*a).UUID)))
			binary.BigEndian.PutUint32(data[6:], uint32(int32((*a).NodeState)))
			float64_NEOEncode(data[10:], (*a).IdTimestamp)
			data = data[18:]
		}
	}
}

func (p *AnswerNodeList) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		nread0 += 4
		p.NodeList = make([]NodeInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			if len(data) < 4 {
				goto overflow
			}
			(*a).NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
			{
				if len(data) < 8 {
					goto overflow
				}
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < l {
					goto overflow
				}
				(*a).Address.Host = string(data[:l])
				data = data[l:]
				nread0 += 8 + l
			}
			if len(data) < 2 {
				goto overflow
			}
			(*a).Address.Port = binary.BigEndian.Uint16(data[0:])
			if len(data) < 6 {
				goto overflow
			}
			(*a).UUID = UUID(int32(binary.BigEndian.Uint32(data[2:])))
			if len(data) < 10 {
				goto overflow
			}
			(*a).NodeState = NodeState(int32(binary.BigEndian.Uint32(data[6:])))
			if len(data) < 18 {
				goto overflow
			}
			(*a).IdTimestamp = float64_NEODecode(data[10:])
			data = data[18:]
			nread0 += 18
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 61. SetNodeState

func (p *SetNodeState) NEOEncodedLen() int {
	return 8
}

func (p *SetNodeState) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.UUID)))
	binary.BigEndian.PutUint32(data[4:], uint32(int32(p.NodeState)))
}

func (p *SetNodeState) NEODecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.UUID = UUID(int32(binary.BigEndian.Uint32(data[0:])))
	if len(data) < 8 {
		goto overflow
	}
	p.NodeState = NodeState(int32(binary.BigEndian.Uint32(data[4:])))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 62. AddPendingNodes

func (p *AddPendingNodes) NEOEncodedLen() int {
	return 4 + len(p.UUIDList)*4
}

func (p *AddPendingNodes) NEOEncode(data []byte) {
	{
		l := uint32(len(p.UUIDList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.UUIDList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *AddPendingNodes) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		nread0 += 4
		p.UUIDList = make([]UUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.UUIDList[i]
			if len(data) < 4 {
				goto overflow
			}
			(*a) = UUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
			nread0 += 4
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 63. TweakPartitionTable

func (p *TweakPartitionTable) NEOEncodedLen() int {
	return 4 + len(p.UUIDList)*4
}

func (p *TweakPartitionTable) NEOEncode(data []byte) {
	{
		l := uint32(len(p.UUIDList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.UUIDList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *TweakPartitionTable) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		nread0 += 4
		p.UUIDList = make([]UUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.UUIDList[i]
			if len(data) < 4 {
				goto overflow
			}
			(*a) = UUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
			nread0 += 4
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 64. NotifyNodeInformation

func (p *NotifyNodeInformation) NEOEncodedLen() int {
	var size0 int
	for i := 0; i < len(p.NodeList); i++ {
		a := &p.NodeList[i]

		size0 += 26 + len((*a).Address.Host)
	}
	return 4 + size0
}

func (p *NotifyNodeInformation) NEOEncode(data []byte) {
	{
		l := uint32(len(p.NodeList))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a).NodeType)))
			{
				l := uint32(len((*a).Address.Host))
				binary.BigEndian.PutUint32(data[4:], l)
				data = data[8:]
				copy(data, (*a).Address.Host)
				data = data[l:]
			}
			binary.BigEndian.PutUint16(data[0:], (*a).Address.Port)
			binary.BigEndian.PutUint32(data[2:], uint32(int32((*a).UUID)))
			binary.BigEndian.PutUint32(data[6:], uint32(int32((*a).NodeState)))
			float64_NEOEncode(data[10:], (*a).IdTimestamp)
			data = data[18:]
		}
	}
}

func (p *NotifyNodeInformation) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		nread0 += 4
		p.NodeList = make([]NodeInfo, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.NodeList[i]
			if len(data) < 4 {
				goto overflow
			}
			(*a).NodeType = NodeType(int32(binary.BigEndian.Uint32(data[0:])))
			{
				if len(data) < 8 {
					goto overflow
				}
				l := binary.BigEndian.Uint32(data[4:])
				data = data[8:]
				if uint32(len(data)) < l {
					goto overflow
				}
				(*a).Address.Host = string(data[:l])
				data = data[l:]
				nread0 += 8 + l
			}
			if len(data) < 2 {
				goto overflow
			}
			(*a).Address.Port = binary.BigEndian.Uint16(data[0:])
			if len(data) < 6 {
				goto overflow
			}
			(*a).UUID = UUID(int32(binary.BigEndian.Uint32(data[2:])))
			if len(data) < 10 {
				goto overflow
			}
			(*a).NodeState = NodeState(int32(binary.BigEndian.Uint32(data[6:])))
			if len(data) < 18 {
				goto overflow
			}
			(*a).IdTimestamp = float64_NEODecode(data[10:])
			data = data[18:]
			nread0 += 18
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 65. NodeInformation

func (p *NodeInformation) NEOEncodedLen() int {
	return 0
}

func (p *NodeInformation) NEOEncode(data []byte) {
}

func (p *NodeInformation) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 66. SetClusterState

func (p *SetClusterState) NEOEncodedLen() int {
	return 4
}

func (p *SetClusterState) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *SetClusterState) NEODecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 67. ClusterInformation

func (p *ClusterInformation) NEOEncodedLen() int {
	return 4
}

func (p *ClusterInformation) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *ClusterInformation) NEODecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 68. X_ClusterState

func (p *X_ClusterState) NEOEncodedLen() int {
	return 4
}

func (p *X_ClusterState) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], uint32(int32(p.State)))
}

func (p *X_ClusterState) NEODecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.State = ClusterState(int32(binary.BigEndian.Uint32(data[0:])))
	return 4, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 69. ObjectUndoSerial

func (p *ObjectUndoSerial) NEOEncodedLen() int {
	return 28 + len(p.OidList)*8
}

func (p *ObjectUndoSerial) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.LTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.UndoneTID))
	{
		l := uint32(len(p.OidList))
		binary.BigEndian.PutUint32(data[24:], l)
		data = data[28:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			binary.BigEndian.PutUint64(data[0:], uint64((*a)))
			data = data[8:]
		}
	}
}

func (p *ObjectUndoSerial) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.LTID = Tid(binary.BigEndian.Uint64(data[8:]))
	if len(data) < 24 {
		goto overflow
	}
	p.UndoneTID = Tid(binary.BigEndian.Uint64(data[16:]))
	{
		if len(data) < 28 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[24:])
		data = data[28:]
		nread0 += 28
		p.OidList = make([]Oid, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.OidList[i]
			if len(data) < 8 {
				goto overflow
			}
			(*a) = Oid(binary.BigEndian.Uint64(data[0:]))
			data = data[8:]
			nread0 += 8
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 70. AnswerObjectUndoSerial

func (p *AnswerObjectUndoSerial) NEOEncodedLen() int {
	return 4 + len(p.ObjectTIDDict)*25
}

func (p *AnswerObjectUndoSerial) NEOEncode(data []byte) {
	{
		l := uint32(len(p.ObjectTIDDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]Oid, 0, l)
		for key := range p.ObjectTIDDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint64(data[0:], uint64(key))
			binary.BigEndian.PutUint64(data[8:], uint64(p.ObjectTIDDict[key].CurrentSerial))
			binary.BigEndian.PutUint64(data[16:], uint64(p.ObjectTIDDict[key].UndoSerial))
			(data[24:])[0] = bool2byte(p.ObjectTIDDict[key].IsCurrent)
			data = data[25:]
		}
	}
}

func (p *AnswerObjectUndoSerial) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		nread0 += 4
		p.ObjectTIDDict = make(map[Oid]struct {
			CurrentSerial Tid
			UndoSerial    Tid
			IsCurrent     bool
		}, l)
		m := p.ObjectTIDDict
		for i := 0; uint32(i) < l; i++ {
			if len(data) < 8 {
				goto overflow
			}
			key := Oid(binary.BigEndian.Uint64(data[0:]))
			var v struct {
				CurrentSerial Tid
				UndoSerial    Tid
				IsCurrent     bool
			}
			if len(data) < 16 {
				goto overflow
			}
			v.CurrentSerial = Tid(binary.BigEndian.Uint64(data[8:]))
			if len(data) < 24 {
				goto overflow
			}
			v.UndoSerial = Tid(binary.BigEndian.Uint64(data[16:]))
			if len(data) < 25 {
				goto overflow
			}
			v.IsCurrent = byte2bool((data[24:])[0])
			m[key] = v
			data = data[25:]
			nread0 += 25
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 71. HasLock

func (p *HasLock) NEOEncodedLen() int {
	return 16
}

func (p *HasLock) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Oid))
}

func (p *HasLock) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.Oid = Oid(binary.BigEndian.Uint64(data[8:]))
	return 16, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 72. AnswerHasLock

func (p *AnswerHasLock) NEOEncodedLen() int {
	return 12
}

func (p *AnswerHasLock) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Oid))
	binary.BigEndian.PutUint32(data[8:], uint32(int32(p.LockState)))
}

func (p *AnswerHasLock) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Oid = Oid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 12 {
		goto overflow
	}
	p.LockState = LockState(int32(binary.BigEndian.Uint32(data[8:])))
	return 12, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 73. CheckCurrentSerial

func (p *CheckCurrentSerial) NEOEncodedLen() int {
	return 24
}

func (p *CheckCurrentSerial) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
	binary.BigEndian.PutUint64(data[8:], uint64(p.Serial))
	binary.BigEndian.PutUint64(data[16:], uint64(p.Oid))
}

func (p *CheckCurrentSerial) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.Serial = Tid(binary.BigEndian.Uint64(data[8:]))
	if len(data) < 24 {
		goto overflow
	}
	p.Oid = Oid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 74. AnswerCheckCurrentSerial

func (p *AnswerCheckCurrentSerial) NEOEncodedLen() int {
	return 17
}

func (p *AnswerCheckCurrentSerial) NEOEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Conflicting)
	binary.BigEndian.PutUint64(data[1:], uint64(p.Oid))
	binary.BigEndian.PutUint64(data[9:], uint64(p.Serial))
}

func (p *AnswerCheckCurrentSerial) NEODecode(data []byte) (int, error) {
	if len(data) < 1 {
		goto overflow
	}
	p.Conflicting = byte2bool((data[0:])[0])
	if len(data) < 9 {
		goto overflow
	}
	p.Oid = Oid(binary.BigEndian.Uint64(data[1:]))
	if len(data) < 17 {
		goto overflow
	}
	p.Serial = Tid(binary.BigEndian.Uint64(data[9:]))
	return 17, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 75. Pack

func (p *Pack) NEOEncodedLen() int {
	return 8
}

func (p *Pack) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *Pack) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 76. AnswerPack

func (p *AnswerPack) NEOEncodedLen() int {
	return 1
}

func (p *AnswerPack) NEOEncode(data []byte) {
	(data[0:])[0] = bool2byte(p.Status)
}

func (p *AnswerPack) NEODecode(data []byte) (int, error) {
	if len(data) < 1 {
		goto overflow
	}
	p.Status = byte2bool((data[0:])[0])
	return 1, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 77. CheckReplicas

func (p *CheckReplicas) NEOEncodedLen() int {
	return 20 + len(p.PartitionDict)*8
}

func (p *CheckReplicas) NEOEncode(data []byte) {
	{
		l := uint32(len(p.PartitionDict))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		keyv := make([]uint32, 0, l)
		for key := range p.PartitionDict {
			keyv = append(keyv, key)
		}
		sort.Slice(keyv, func(i, j int) bool { return keyv[i] < keyv[j] })
		for _, key := range keyv {
			binary.BigEndian.PutUint32(data[0:], key)
			binary.BigEndian.PutUint32(data[4:], uint32(int32(p.PartitionDict[key])))
			data = data[8:]
		}
	}
	binary.BigEndian.PutUint64(data[0:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[8:], uint64(p.MaxTID))
}

func (p *CheckReplicas) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		nread0 += 4
		p.PartitionDict = make(map[uint32]UUID, l)
		m := p.PartitionDict
		for i := 0; uint32(i) < l; i++ {
			if len(data) < 4 {
				goto overflow
			}
			key := binary.BigEndian.Uint32(data[0:])
			if len(data) < 8 {
				goto overflow
			}
			m[key] = UUID(int32(binary.BigEndian.Uint32(data[4:])))
			data = data[8:]
			nread0 += 8
		}
	}
	if len(data) < 8 {
		goto overflow
	}
	p.MinTID = Tid(binary.BigEndian.Uint64(data[0:]))
	if len(data) < 16 {
		goto overflow
	}
	p.MaxTID = Tid(binary.BigEndian.Uint64(data[8:]))
	return 16 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 78. CheckPartition

func (p *CheckPartition) NEOEncodedLen() int {
	return 30 + len(p.Source.UpstreamName) + len(p.Source.Address.Host)
}

func (p *CheckPartition) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	{
		l := uint32(len(p.Source.UpstreamName))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		copy(data, p.Source.UpstreamName)
		data = data[l:]
	}
	{
		l := uint32(len(p.Source.Address.Host))
		binary.BigEndian.PutUint32(data[0:], l)
		data = data[4:]
		copy(data, p.Source.Address.Host)
		data = data[l:]
	}
	binary.BigEndian.PutUint16(data[0:], p.Source.Address.Port)
	binary.BigEndian.PutUint64(data[2:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[10:], uint64(p.MaxTID))
}

func (p *CheckPartition) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 4 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	{
		if len(data) < 8 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.Source.UpstreamName = string(data[:l])
		data = data[l:]
		nread0 += 8 + l
	}
	{
		if len(data) < 4 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[0:])
		data = data[4:]
		if uint32(len(data)) < l {
			goto overflow
		}
		p.Source.Address.Host = string(data[:l])
		data = data[l:]
		nread0 += 4 + l
	}
	if len(data) < 2 {
		goto overflow
	}
	p.Source.Address.Port = binary.BigEndian.Uint16(data[0:])
	if len(data) < 10 {
		goto overflow
	}
	p.MinTID = Tid(binary.BigEndian.Uint64(data[2:]))
	if len(data) < 18 {
		goto overflow
	}
	p.MaxTID = Tid(binary.BigEndian.Uint64(data[10:]))
	return 18 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 79. CheckTIDRange

func (p *CheckTIDRange) NEOEncodedLen() int {
	return 24
}

func (p *CheckTIDRange) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTID))
}

func (p *CheckTIDRange) NEODecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	if len(data) < 8 {
		goto overflow
	}
	p.Length = binary.BigEndian.Uint32(data[4:])
	if len(data) < 16 {
		goto overflow
	}
	p.MinTID = Tid(binary.BigEndian.Uint64(data[8:]))
	if len(data) < 24 {
		goto overflow
	}
	p.MaxTID = Tid(binary.BigEndian.Uint64(data[16:]))
	return 24, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 80. AnswerCheckTIDRange

func (p *AnswerCheckTIDRange) NEOEncodedLen() int {
	return 32
}

func (p *AnswerCheckTIDRange) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Count)
	(data[4:])[0] = p.Checksum[0]
	(data[5:])[0] = p.Checksum[1]
	(data[6:])[0] = p.Checksum[2]
	(data[7:])[0] = p.Checksum[3]
	(data[8:])[0] = p.Checksum[4]
	(data[9:])[0] = p.Checksum[5]
	(data[10:])[0] = p.Checksum[6]
	(data[11:])[0] = p.Checksum[7]
	(data[12:])[0] = p.Checksum[8]
	(data[13:])[0] = p.Checksum[9]
	(data[14:])[0] = p.Checksum[10]
	(data[15:])[0] = p.Checksum[11]
	(data[16:])[0] = p.Checksum[12]
	(data[17:])[0] = p.Checksum[13]
	(data[18:])[0] = p.Checksum[14]
	(data[19:])[0] = p.Checksum[15]
	(data[20:])[0] = p.Checksum[16]
	(data[21:])[0] = p.Checksum[17]
	(data[22:])[0] = p.Checksum[18]
	(data[23:])[0] = p.Checksum[19]
	binary.BigEndian.PutUint64(data[24:], uint64(p.MaxTID))
}

func (p *AnswerCheckTIDRange) NEODecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.Count = binary.BigEndian.Uint32(data[0:])
	if len(data) < 5 {
		goto overflow
	}
	p.Checksum[0] = (data[4:])[0]
	if len(data) < 6 {
		goto overflow
	}
	p.Checksum[1] = (data[5:])[0]
	if len(data) < 7 {
		goto overflow
	}
	p.Checksum[2] = (data[6:])[0]
	if len(data) < 8 {
		goto overflow
	}
	p.Checksum[3] = (data[7:])[0]
	if len(data) < 9 {
		goto overflow
	}
	p.Checksum[4] = (data[8:])[0]
	if len(data) < 10 {
		goto overflow
	}
	p.Checksum[5] = (data[9:])[0]
	if len(data) < 11 {
		goto overflow
	}
	p.Checksum[6] = (data[10:])[0]
	if len(data) < 12 {
		goto overflow
	}
	p.Checksum[7] = (data[11:])[0]
	if len(data) < 13 {
		goto overflow
	}
	p.Checksum[8] = (data[12:])[0]
	if len(data) < 14 {
		goto overflow
	}
	p.Checksum[9] = (data[13:])[0]
	if len(data) < 15 {
		goto overflow
	}
	p.Checksum[10] = (data[14:])[0]
	if len(data) < 16 {
		goto overflow
	}
	p.Checksum[11] = (data[15:])[0]
	if len(data) < 17 {
		goto overflow
	}
	p.Checksum[12] = (data[16:])[0]
	if len(data) < 18 {
		goto overflow
	}
	p.Checksum[13] = (data[17:])[0]
	if len(data) < 19 {
		goto overflow
	}
	p.Checksum[14] = (data[18:])[0]
	if len(data) < 20 {
		goto overflow
	}
	p.Checksum[15] = (data[19:])[0]
	if len(data) < 21 {
		goto overflow
	}
	p.Checksum[16] = (data[20:])[0]
	if len(data) < 22 {
		goto overflow
	}
	p.Checksum[17] = (data[21:])[0]
	if len(data) < 23 {
		goto overflow
	}
	p.Checksum[18] = (data[22:])[0]
	if len(data) < 24 {
		goto overflow
	}
	p.Checksum[19] = (data[23:])[0]
	if len(data) < 32 {
		goto overflow
	}
	p.MaxTID = Tid(binary.BigEndian.Uint64(data[24:]))
	return 32, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 81. CheckSerialRange

func (p *CheckSerialRange) NEOEncodedLen() int {
	return 32
}

func (p *CheckSerialRange) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	binary.BigEndian.PutUint32(data[4:], p.Length)
	binary.BigEndian.PutUint64(data[8:], uint64(p.MinTID))
	binary.BigEndian.PutUint64(data[16:], uint64(p.MaxTID))
	binary.BigEndian.PutUint64(data[24:], uint64(p.MinOID))
}

func (p *CheckSerialRange) NEODecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	if len(data) < 8 {
		goto overflow
	}
	p.Length = binary.BigEndian.Uint32(data[4:])
	if len(data) < 16 {
		goto overflow
	}
	p.MinTID = Tid(binary.BigEndian.Uint64(data[8:]))
	if len(data) < 24 {
		goto overflow
	}
	p.MaxTID = Tid(binary.BigEndian.Uint64(data[16:]))
	if len(data) < 32 {
		goto overflow
	}
	p.MinOID = Oid(binary.BigEndian.Uint64(data[24:]))
	return 32, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 82. AnswerCheckSerialRange

func (p *AnswerCheckSerialRange) NEOEncodedLen() int {
	return 60
}

func (p *AnswerCheckSerialRange) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Count)
	(data[4:])[0] = p.TidChecksum[0]
	(data[5:])[0] = p.TidChecksum[1]
	(data[6:])[0] = p.TidChecksum[2]
	(data[7:])[0] = p.TidChecksum[3]
	(data[8:])[0] = p.TidChecksum[4]
	(data[9:])[0] = p.TidChecksum[5]
	(data[10:])[0] = p.TidChecksum[6]
	(data[11:])[0] = p.TidChecksum[7]
	(data[12:])[0] = p.TidChecksum[8]
	(data[13:])[0] = p.TidChecksum[9]
	(data[14:])[0] = p.TidChecksum[10]
	(data[15:])[0] = p.TidChecksum[11]
	(data[16:])[0] = p.TidChecksum[12]
	(data[17:])[0] = p.TidChecksum[13]
	(data[18:])[0] = p.TidChecksum[14]
	(data[19:])[0] = p.TidChecksum[15]
	(data[20:])[0] = p.TidChecksum[16]
	(data[21:])[0] = p.TidChecksum[17]
	(data[22:])[0] = p.TidChecksum[18]
	(data[23:])[0] = p.TidChecksum[19]
	binary.BigEndian.PutUint64(data[24:], uint64(p.MaxTID))
	(data[32:])[0] = p.OidChecksum[0]
	(data[33:])[0] = p.OidChecksum[1]
	(data[34:])[0] = p.OidChecksum[2]
	(data[35:])[0] = p.OidChecksum[3]
	(data[36:])[0] = p.OidChecksum[4]
	(data[37:])[0] = p.OidChecksum[5]
	(data[38:])[0] = p.OidChecksum[6]
	(data[39:])[0] = p.OidChecksum[7]
	(data[40:])[0] = p.OidChecksum[8]
	(data[41:])[0] = p.OidChecksum[9]
	(data[42:])[0] = p.OidChecksum[10]
	(data[43:])[0] = p.OidChecksum[11]
	(data[44:])[0] = p.OidChecksum[12]
	(data[45:])[0] = p.OidChecksum[13]
	(data[46:])[0] = p.OidChecksum[14]
	(data[47:])[0] = p.OidChecksum[15]
	(data[48:])[0] = p.OidChecksum[16]
	(data[49:])[0] = p.OidChecksum[17]
	(data[50:])[0] = p.OidChecksum[18]
	(data[51:])[0] = p.OidChecksum[19]
	binary.BigEndian.PutUint64(data[52:], uint64(p.MaxOID))
}

func (p *AnswerCheckSerialRange) NEODecode(data []byte) (int, error) {
	if len(data) < 4 {
		goto overflow
	}
	p.Count = binary.BigEndian.Uint32(data[0:])
	if len(data) < 5 {
		goto overflow
	}
	p.TidChecksum[0] = (data[4:])[0]
	if len(data) < 6 {
		goto overflow
	}
	p.TidChecksum[1] = (data[5:])[0]
	if len(data) < 7 {
		goto overflow
	}
	p.TidChecksum[2] = (data[6:])[0]
	if len(data) < 8 {
		goto overflow
	}
	p.TidChecksum[3] = (data[7:])[0]
	if len(data) < 9 {
		goto overflow
	}
	p.TidChecksum[4] = (data[8:])[0]
	if len(data) < 10 {
		goto overflow
	}
	p.TidChecksum[5] = (data[9:])[0]
	if len(data) < 11 {
		goto overflow
	}
	p.TidChecksum[6] = (data[10:])[0]
	if len(data) < 12 {
		goto overflow
	}
	p.TidChecksum[7] = (data[11:])[0]
	if len(data) < 13 {
		goto overflow
	}
	p.TidChecksum[8] = (data[12:])[0]
	if len(data) < 14 {
		goto overflow
	}
	p.TidChecksum[9] = (data[13:])[0]
	if len(data) < 15 {
		goto overflow
	}
	p.TidChecksum[10] = (data[14:])[0]
	if len(data) < 16 {
		goto overflow
	}
	p.TidChecksum[11] = (data[15:])[0]
	if len(data) < 17 {
		goto overflow
	}
	p.TidChecksum[12] = (data[16:])[0]
	if len(data) < 18 {
		goto overflow
	}
	p.TidChecksum[13] = (data[17:])[0]
	if len(data) < 19 {
		goto overflow
	}
	p.TidChecksum[14] = (data[18:])[0]
	if len(data) < 20 {
		goto overflow
	}
	p.TidChecksum[15] = (data[19:])[0]
	if len(data) < 21 {
		goto overflow
	}
	p.TidChecksum[16] = (data[20:])[0]
	if len(data) < 22 {
		goto overflow
	}
	p.TidChecksum[17] = (data[21:])[0]
	if len(data) < 23 {
		goto overflow
	}
	p.TidChecksum[18] = (data[22:])[0]
	if len(data) < 24 {
		goto overflow
	}
	p.TidChecksum[19] = (data[23:])[0]
	if len(data) < 32 {
		goto overflow
	}
	p.MaxTID = Tid(binary.BigEndian.Uint64(data[24:]))
	if len(data) < 33 {
		goto overflow
	}
	p.OidChecksum[0] = (data[32:])[0]
	if len(data) < 34 {
		goto overflow
	}
	p.OidChecksum[1] = (data[33:])[0]
	if len(data) < 35 {
		goto overflow
	}
	p.OidChecksum[2] = (data[34:])[0]
	if len(data) < 36 {
		goto overflow
	}
	p.OidChecksum[3] = (data[35:])[0]
	if len(data) < 37 {
		goto overflow
	}
	p.OidChecksum[4] = (data[36:])[0]
	if len(data) < 38 {
		goto overflow
	}
	p.OidChecksum[5] = (data[37:])[0]
	if len(data) < 39 {
		goto overflow
	}
	p.OidChecksum[6] = (data[38:])[0]
	if len(data) < 40 {
		goto overflow
	}
	p.OidChecksum[7] = (data[39:])[0]
	if len(data) < 41 {
		goto overflow
	}
	p.OidChecksum[8] = (data[40:])[0]
	if len(data) < 42 {
		goto overflow
	}
	p.OidChecksum[9] = (data[41:])[0]
	if len(data) < 43 {
		goto overflow
	}
	p.OidChecksum[10] = (data[42:])[0]
	if len(data) < 44 {
		goto overflow
	}
	p.OidChecksum[11] = (data[43:])[0]
	if len(data) < 45 {
		goto overflow
	}
	p.OidChecksum[12] = (data[44:])[0]
	if len(data) < 46 {
		goto overflow
	}
	p.OidChecksum[13] = (data[45:])[0]
	if len(data) < 47 {
		goto overflow
	}
	p.OidChecksum[14] = (data[46:])[0]
	if len(data) < 48 {
		goto overflow
	}
	p.OidChecksum[15] = (data[47:])[0]
	if len(data) < 49 {
		goto overflow
	}
	p.OidChecksum[16] = (data[48:])[0]
	if len(data) < 50 {
		goto overflow
	}
	p.OidChecksum[17] = (data[49:])[0]
	if len(data) < 51 {
		goto overflow
	}
	p.OidChecksum[18] = (data[50:])[0]
	if len(data) < 52 {
		goto overflow
	}
	p.OidChecksum[19] = (data[51:])[0]
	if len(data) < 60 {
		goto overflow
	}
	p.MaxOID = Oid(binary.BigEndian.Uint64(data[52:]))
	return 60, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 83. PartitionCorrupted

func (p *PartitionCorrupted) NEOEncodedLen() int {
	return 8 + len(p.CellList)*4
}

func (p *PartitionCorrupted) NEOEncode(data []byte) {
	binary.BigEndian.PutUint32(data[0:], p.Partition)
	{
		l := uint32(len(p.CellList))
		binary.BigEndian.PutUint32(data[4:], l)
		data = data[8:]
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			binary.BigEndian.PutUint32(data[0:], uint32(int32((*a))))
			data = data[4:]
		}
	}
}

func (p *PartitionCorrupted) NEODecode(data []byte) (int, error) {
	var nread0 uint32
	if len(data) < 4 {
		goto overflow
	}
	p.Partition = binary.BigEndian.Uint32(data[0:])
	{
		if len(data) < 8 {
			goto overflow
		}
		l := binary.BigEndian.Uint32(data[4:])
		data = data[8:]
		nread0 += 8
		p.CellList = make([]UUID, l)
		for i := 0; uint32(i) < l; i++ {
			a := &p.CellList[i]
			if len(data) < 4 {
				goto overflow
			}
			(*a) = UUID(int32(binary.BigEndian.Uint32(data[0:])))
			data = data[4:]
			nread0 += 4
		}
	}
	return 0 + int(nread0), nil

overflow:
	return 0, ErrDecodeOverflow
}

// 84. LastTransaction

func (p *LastTransaction) NEOEncodedLen() int {
	return 0
}

func (p *LastTransaction) NEOEncode(data []byte) {
}

func (p *LastTransaction) NEODecode(data []byte) (int, error) {
	return 0, nil
}

// 85. AnswerLastTransaction

func (p *AnswerLastTransaction) NEOEncodedLen() int {
	return 8
}

func (p *AnswerLastTransaction) NEOEncode(data []byte) {
	binary.BigEndian.PutUint64(data[0:], uint64(p.Tid))
}

func (p *AnswerLastTransaction) NEODecode(data []byte) (int, error) {
	if len(data) < 8 {
		goto overflow
	}
	p.Tid = Tid(binary.BigEndian.Uint64(data[0:]))
	return 8, nil

overflow:
	return 0, ErrDecodeOverflow
}

// 86. NotifyReady

func (p *NotifyReady) NEOEncodedLen() int {
	return 0
}

func (p *NotifyReady) NEOEncode(data []byte) {
}

func (p *NotifyReady) NEODecode(data []byte) (int, error) {
	return 0, nil
}
