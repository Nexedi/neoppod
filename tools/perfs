#! /usr/bin/env python

import os
import sys
import optparse
import platform
import datetime
from time import time

from neo.tests.functional import NEOCluster
from neo.client.Storage import Storage
from ZODB.FileStorage import FileStorage
from neo.profiling import PROFILING_ENABLED, profiler_decorator, \
    profiler_report

def runImport(neo, datafs):

    @profiler_decorator
    def _copyTransactionsFrom(self, other):
        """ taken from ZODB.BaseStorage that build stat during import """
        def inc(d):
            # count number of tick per second
            t = int(time())
            d.setdefault(t, 0)
            d[t] += 1
        def updateLastSerial(oid, result):
            if result:
                if isinstance(result, str):
                    assert oid is not None
                    preindex[oid] = result
                else:
                    for oid, serial in result:
                        assert isinstance(serial, str), serial
                        preindex[oid] = serial
        txn = {}
        obj = {}
        preindex = {}
        fiter = other.iterator()
        for transaction in fiter:
            inc(txn)
            self.tpc_begin(transaction, transaction.tid, transaction.status)
            for r in transaction:
                inc(obj)
                pre = preindex.get(r.oid, None)
                s = self.store(r.oid, pre, r.data, r.version, transaction)
                updateLastSerial(r.oid, s)
            updateLastSerial(None, self.tpc_vote(transaction))
            self.tpc_finish(transaction)
        fiter.close()
        return {
            'Transactions': txn.values(),
            'Objects': obj.values(),
        }

    # open storages clients
    neo_storage = neo.getZODBStorage()
    dfs_storage = FileStorage(file_name=datafs)
    dfs_size = os.path.getsize(datafs)

    # monkey patch import method and run the import
    start = time()
    Storage.copyTransactionsFrom = _copyTransactionsFrom
    stats = neo_storage.copyTransactionsFrom(dfs_storage)
    elapsed = time() - start

    return (dfs_size, elapsed, stats)

def buildReport(config, dfs_size, elapsed, stats):
    """ build a report for the given import data """

    pat = '%19s | %8s | %5s | %5s | %5s \n'
    sep = '%19s+%8s+%5s+%5s+%5s\n'
    sep %= ('-' * 20, '-' * 10) + ('-' * 7, ) * 3

    dfs_size /= 1024
    size = dfs_size / 1024
    speed = dfs_size / elapsed

    # system
    report = ' ' * 20 + ' NEO PERF REPORT\n\n'
    report += "\tDate        : %s\n" % datetime.date.today().isoformat()
    report += "\tNode        : %s\n" % platform.node()
    report += "\tProcessor   : %s (%s)\n" % (platform.processor(),
            platform.architecture()[0])
    report += "\tSystem      : %s (%s)\n" % (platform.system(),
            platform.release())
    report += '\n'
    # configuration
    report += "\tMasters     : %s\n" % (config['masters'], )
    report += "\tStorages    : %s\n" % (config['storages'], )
    report += "\tReplicas    : %s\n" % (config['replicas'], )
    report += "\tPartitions  : %s\n" % (config['partitions'], )
    report += '\n'
    # results
    report += '\n%19s: %6.1f MB' % ('Input size', size)
    report += '\n%19s: %6d sec' % ('Import duration', elapsed)
    report += '\n%19s: %6.1f KB/s\n' % ('Average speed', speed)
    report += '\n\n'

    # stats on objects and transactions
    report += pat % ('', ' num ', 'min/s', 'avg/s', 'max/s')
    for k, v in stats.items():
        report += sep
        s = sum(v)
        report += pat % (k, s,  min(v), s / len(v), max(v))
    report += sep

    # build summary
    summary = 'Neo : %6.1f KB/s (%6.1f MB)' % (speed, size)

    return (summary, report)

def sendReport(sender, recipients, server, summary, report):
    """ Send a mail with the report summary """

    import smtplib
    from email.MIMEMultipart import MIMEMultipart
    from email.MIMEText import MIMEText

    # build the email
    msg = MIMEMultipart()
    msg['Subject'] = summary
    msg['From']    = sender
    msg['To']      = ', '.join(recipients)
    msg.epilogue = ''
    msg.attach(MIMEText(report))

    # Send via smtp server
    s = smtplib.SMTP()
    s.connect(*server)
    mail = msg.as_string()
    for recipient in recipients:
        try:
            s.sendmail(sender, recipient, mail)
        except smtplib.SMTPRecipientsRefused:
            print "Mail for %s fails" % recipient
    s.close()

if __name__ == "__main__":

    # handle command line options
    parser = optparse.OptionParser()
    parser.add_option('-d', '--datafs')
    parser.add_option('-m', '--master-count')
    parser.add_option('-s', '--storage-count')
    parser.add_option('-p', '--partition-count')
    parser.add_option('-r', '--replica-count')
    parser.add_option('', '--recipient', action='append')
    parser.add_option('', '--sender')
    parser.add_option('', '--server')
    (options, args) = parser.parse_args()

    # check arguments
    if not options.datafs or not os.path.exists(options.datafs):
        sys.exit('Missing or wrong data.fs argument')
    if bool(options.sender) ^ bool(options.recipient):
        sys.exit('Need a sender and recipients to mail report')

    # load options or defaults
    config = dict(
        masters = int(options.master_count or 1),
        storages = int(options.storage_count or 1),
        partitions = int(options.partition_count or 10),
        replicas = int(options.replica_count or 0),
    )

    datafs = options.datafs
    mail_server = options.server or '127.0.0.1:25'
    mail_server = mail_server.split(':')
    sender = options.sender
    recipient = options.recipient

    # start neo
    neo = NEOCluster(
        db_list=['test_import_%d' % i for i in xrange(config['storages'])],
        clear_databases=True,
        partitions=config['partitions'],
        replicas=config['replicas'],
        master_node_count=config['masters'],
        verbose=False,
    )

    # import datafs
    neo.start()
    summary, report = buildReport(config, *runImport(neo, datafs))
    neo.stop()

    if PROFILING_ENABLED:
        print profiler_report()

    # display and/or send the report
    print summary
    print report
    if options.sender:
        sendReport(sender, recipient, mail_server, summary, report)


