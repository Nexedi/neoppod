#include <pthread.h>
#include <stdio.h>
#include <sys/types.h>
#include <netdb.h>
#include <signal.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <uuid/uuid.h>
#include <time.h>
#include <syslog.h>
#include <getopt.h>

#include "neo_mysql.h"
#include "neo_socket.h"
#include "neo_struct.h"
#include "master_request.h"
#include "master_return.h"
#include "timestamp.h"

#define MASTER_ID_FILE "master_id.txt" /* file that store the master id */
#define MASTER_DATA_FILE "master_data.txt" /* file that store the last tid and oid generated by master */
#define DEFAULT_REPLICATION_NB 2

enum mutex
{
  OID_GENERATION,
  LTID,
  STORAGES_IDX,
  REPLICATION,
  DB
};

static int master_ready = 0; /* boolean indicating if enought storage are ready to handle clients */
static int create_db = 0; /* flag to know if we must start with a new database */
static int ascii[ID_LEN]; /* last oid generated */
static int soc = -1;
static uuid_t master_id;
static char ID[UUID_LEN+1];	/* uuid is unparse into a 36 byte string */
static u_int64_t ltid;		/* store last transaction id */
static unsigned char last_generated_tid[ID_LEN];	/* last generated tid, use to check if tid increases */
static u_int16_t replication_nb = DEFAULT_REPLICATION_NB;	/* number of replication for a transaction on storages nodes */
static u_int16_t last_storage_replication;	/* id of the last storage node used for replication */
static struct storageInfo DBinfo;	/* store informations about storage system */
static struct database *db;
static struct stringList *storage_index;
char database_dir[BUF_SIZE];  /* path to the mysql db dir */

/* definition and function for mutex */
static pthread_mutex_t mutex_storages_index = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t mutex_ltid = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t mutex_replication = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t mutex_db = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t mutex_oid = PTHREAD_MUTEX_INITIALIZER;

static int
init_mutex ()
{
  pthread_mutex_init (&mutex_storages_index, NULL);
  pthread_mutex_init (&mutex_ltid, NULL);
  pthread_mutex_init (&mutex_replication, NULL);
  pthread_mutex_init (&mutex_db, NULL);
  pthread_mutex_init (&mutex_oid, NULL);
  return 1;
}

static int
lock (int mutex)
{
  if (mutex == STORAGES_IDX)
    pthread_mutex_lock (&mutex_storages_index);
  else if (mutex == LTID)
    pthread_mutex_lock (&mutex_ltid);
  else if (mutex == REPLICATION)
    pthread_mutex_lock (&mutex_replication);
  else if (mutex == DB)
    pthread_mutex_lock (&mutex_db);
  else if (mutex == OID_GENERATION)
    pthread_mutex_lock (&mutex_oid);
  else
    {
      perror ("mutex lock");
      return 0;
    }
  return 1;
}

static int
unlock (int mutex)
{
  if (mutex == STORAGES_IDX)
    pthread_mutex_unlock (&mutex_storages_index);
  else if (mutex == LTID)
    pthread_mutex_unlock (&mutex_ltid);
  else if (mutex == REPLICATION)
    pthread_mutex_unlock (&mutex_replication);
  else if (mutex == DB)
    pthread_mutex_unlock (&mutex_db);
  else if (mutex == OID_GENERATION)
    pthread_mutex_unlock (&mutex_oid);
  else
    {
      perror ("mutex unlock");
      return 0;
    }
  return 1;
}


/* handler called when master close */
static void
cleanup_handler (int sig)
{
  char *storage_id = NULL, *client_id = NULL;
  struct nlist *lstorages = NULL, *lclients = NULL;
  u_int32_t i;
  FILE *fd;

  /* must store last oid and tid */
  fd = fopen (MASTER_DATA_FILE, "w");
  fwrite (ascii, sizeof (int), 8, fd);
  fwrite (last_generated_tid, sizeof (unsigned char), 8, fd);
  fclose (fd);

  /* send message of master close to all storages first */
  lock (DB);
  if (database_master_get_all_storages_infos (db, &lstorages) == 1)
    {
      for (i = 0; i < lstorages->last; i++)
	{
	  if (masterClose
	      (lstorages->objects[i].addr, lstorages->objects[i].port,
	       MASTER_CLOSE, ID, &storage_id))
	    {
	      database_master_close_storage (db, storage_id);
	      free (storage_id);
	    }
	}
    }

  /* send to all clients too */
  if (database_master_get_all_clients_infos (db, &lclients) == 1)
    for (i = 0; i < lclients->last; i++)
      {
	if (masterClose (lclients->objects[i].addr, lclients->objects[i].port,
			 MASTER_CLOSE, ID, &client_id))
	  free (client_id);
      }

  database_close (db);
  unlock (DB);

  if (lstorages != NULL)
    {
      free_nlist (lstorages);
      free (lstorages);
    }
  if (lclients != NULL)
    {
      free_nlist (lclients);
      free (lclients);
    }
  free (DBinfo.ext);
  if (soc >= 0)
    close (soc);
  syslog (LOG_MAKEPRI (LOG_USER, LOG_NOTICE), "Close master");
  closelog ();
  exit (0);
}


/**
 * function that generates a new oid,
 * in zope oid are 8-bytes string, each new oid
 * increase the ascii code of this string.
 * here we only use an integer array which store the ascii code,
 * the translation in string is made by the client
 */
static int
generate_oid (int pos)
{
  ascii[pos]++;
  if (ascii[pos] > 255)
    {
      ascii[pos] = 0;
      if (pos >= 0)
        generate_oid (pos - 1);
      else
        return 0;
    }
  return 1;
}

/**
 * function that return the list of all transaction and object
 * stored by this storage as known by the master. Storage node
 * check if all is Ok
 */
static int
send_storage_index (int conn, char id[UUID_LEN+1])
{
  struct transactionList *txn = NULL;
  u_int64_t nb_txn = 0;


  /* XXX must return packet to storage even when sthong failed */
  lock (DB);
  if (!database_master_get_storage_index (db, id, &txn, &nb_txn))
    {
      unlock (DB);
      return 0;
    }
  unlock (DB);
  if (!returnStorageIndex (conn, STORAGE_INDEX, txn))
    {
      if (txn != NULL)
	{
	  transactionList_Free (txn);
	  free (txn);
	}
      return 0;
    }

  if (txn != NULL)
    {
      transactionList_Free (txn);
      free (txn);
    }

  return 1;
}

/**
 * function that returns to the unreliable storage
 * transactions id that were stored by this storage and
 * the list of the others storages which stores the
 * same transaction
 */
static int
make_storage_clean (int conn, char storage_id[UUID_LEN+1])
{
  struct tlist *tid_list = NULL;
  lock (DB);
  if (!database_master_get_trans_list (db, storage_id, &tid_list))
    {
      unlock (DB);
      return 0;
    }
  unlock (DB);
  if (!returnStorageSanity (conn, SANITY_CHECK, *tid_list))
    {
      if (tid_list != NULL)
	free_tlist (tid_list);
      return 0;
    }
  if (tid_list != NULL)
    free_tlist (tid_list);
  return 1;
}

/**
 * function that creates the storage index list used
 * to give storage node for transaction
 */
static int
create_index (void)
{
  /* free memory */
  if (storage_index != NULL)
    {
      stringList_Free (storage_index);
      free (storage_index);
      storage_index = NULL;
    }
  /* create index */
  storage_index = (struct stringList *) malloc (sizeof (struct stringList));
  if (!storage_index)
    return 0;
  database_master_create_storage_index (db, &storage_index);
  return 1;
}


/* functions calleb by clients or storages */
static int
h_getObjectByOid (int conn, char *hbuf)
{
  char rflags[FLAG_LEN], *buf = NULL;
  u_int64_t oid, serial;
  u_int32_t len = 0, data_len = 0;
  int res;
  struct stringList *storages = NULL;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }
  oid = ntohll (*((u_int64_t *) (buf)));

  lock (DB);
  if ((res =
       database_master_get_object_by_oid (db, oid, &serial, &storages)) == -1)
    {				/* oid not found */
      unlock (DB);
      free (buf);
      returnErrorMessage (conn, GET_OBJECT_BY_OID, OID_NOT_FOUND,
			  "not found");
      return 1;
    }
  else if (res == 0)
    {
      unlock (DB);
      goto fail;
    }
  unlock (DB);
  if (!returnGetObjectByOid (conn, GET_OBJECT_BY_OID, serial, *storages))
    goto fail;
  if (storages != NULL)
    {
      stringList_Free (storages);
      free (storages);
    }
  free (buf);
  return 1;
fail:
  if (storages != NULL)
    {
      stringList_Free (storages);
      free (storages);
    }
  if (buf != NULL)
    free (buf);
  returnErrorMessage (conn, GET_OBJECT_BY_OID, TMP_FAILURE,
		      "Error on master node");
  return 1;
}

static int
h_getObjectBySerial (int conn, char *hbuf)
{
  u_int64_t oid, serial;
  u_int32_t len = 0, data_len = 0;
  char rflags[FLAG_LEN], *buf;
  int res;
  struct stringList *storages = NULL;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }

  oid = ntohll (*((u_int64_t *) (buf)));
  serial = ntohll (*((u_int64_t *) (buf + INT64_LEN)));

  lock (DB);
  if ((res =
       database_master_get_object_by_serial (db, oid, serial,
					     &storages)) == -1)
    {				/* serial not found */
      unlock (DB);
      free (buf);
      returnErrorMessage (conn, GET_OBJECT_BY_SERIAL, SERIAL_NOT_FOUND,
			  "not found");
      return 1;
    }
  else if (res == 0)
    {
      unlock (DB);
      goto fail;
    }
  unlock (DB);

  if (!returnGetObjectBySerial (conn, GET_OBJECT_BY_SERIAL, *storages))
    goto fail;
  if (storages != NULL)
    {
      stringList_Free (storages);
      free (storages);
    }
  free (buf);
  return 1;
fail:
  if (storages != NULL)
    {
      stringList_Free (storages);
      free (storages);
    }
  if (buf != NULL)
    free (buf);
  returnErrorMessage (conn, GET_OBJECT_BY_SERIAL, TMP_FAILURE,
		      "Error on master node");
  return 1;
}

static int
h_getSerial (int conn, char *hbuf)
{
  u_int64_t oid, serial;
  u_int32_t len = 0, data_len = 0;
  int res;
  char rflags[FLAG_LEN], *buf = NULL;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }

  oid = ntohll (*((u_int64_t *) (buf)));

  lock (DB);
  if ((res = database_master_get_serial (db, oid, &serial)) == -1)
    {
      unlock (DB);
      free (buf);
      returnErrorMessage (conn, GET_SERIAL, OID_NOT_FOUND, "not found");
      return 1;
    }
  else if (res == 0)
    {
      unlock (DB);
      goto fail;
    }
  unlock (DB);
  if (!returnGetSerial (conn, GET_SERIAL, serial))
    goto fail;
  free (buf);
  return 1;
fail:
  if (buf != NULL)
    free (buf);
  returnErrorMessage (conn, GET_SERIAL, TMP_FAILURE, "Error on master node");
  return 1;
}

static int
h_getLastTransaction (int conn, char *hbuf)
{
  char rflags[FLAG_LEN], *buf = NULL;
  u_int32_t len = 0, data_len = 0;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }

  lock (LTID);
  if (!returnGetLastTransaction (conn, GET_LAST_TRANS, ltid))
    goto fail;
  unlock (LTID);
  free (buf);
  return 1;
fail:
  unlock (LTID);
  if (buf != NULL)
    free (buf);
  returnErrorMessage (conn, GET_LAST_TRANS, TMP_FAILURE,
		      "Error on master node");
  return 1;
}

static int
h_getOid (int conn, char *hbuf)
{
  struct oidList list;
  u_int16_t oid_nb, i;
  u_int32_t len = 0, data_len = 0;
  char rflags[FLAG_LEN], *buf = NULL;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }

  oid_nb = ntohs (*((u_int16_t *) (buf)));

  if (oid_nb > 20)		/* limit number of oid send */
    oid_nb = 20;

  oidList_New (&list, oid_nb);
  lock (OID_GENERATION);
  for (i = 0; i < oid_nb; i++)
    {
      if (generate_oid (7))
	oidList_Append (&list, ascii);
      else
	returnErrorMessage (conn, GET_OID, TMP_FAILURE, "No more oid left");
    }
  unlock (OID_GENERATION);

  if (!returnGetOidInt (conn, GET_OID, list))
    goto fail;
  oidList_Free (&list);
  free (buf);
  return 1;
fail:
  if (buf != NULL)
    free (buf);
  returnErrorMessage (conn, GET_OID, TMP_FAILURE, "Error on master node");
  return 1;
}

static int
h_getTransSN (int conn, char *hbuf)
{
  char rflags[FLAG_LEN], *buf = NULL;
  int16_t first, last;
  u_int32_t len = 0, data_len = 0;
  struct tlist *tl = NULL;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }

  first = ntohs (*((int16_t *) (buf)));
  last = ntohs (*((int16_t *) (buf + INT16_LEN)));
  /* return list of storage for each trans between first and last */
  lock (DB);
  if (!database_master_get_trans_storages (db, ltid, first, last, &tl))
    {
      unlock (DB);
      goto fail;
    }
  unlock (DB);
  if (!returnGetTransSN (conn, GET_TRANS_SN, *tl))
    goto fail;
  if (tl != NULL)
    {
      free_tlist (tl);
      free (tl);
    }
  free (buf);
  return 1;
fail:
  if (tl != NULL)
    {
      free_tlist (tl);
      free (tl);
    }
  if (buf != NULL)
    free (buf);
  returnErrorMessage (conn, GET_TRANS_SN, TMP_FAILURE,
		      "Error on master node");
  return 1;
}

static int
h_getObjectHist (int conn, char *hbuf)
{
  u_int64_t oid;
  u_int32_t len = 0, data_len = 0, length;
  char rflags[FLAG_LEN], *buf = NULL;
  struct tlist *hist = NULL;
  clock_t c1, c2;
  float t;
  static float time = 0;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }

  oid = ntohll (*((u_int64_t *) (buf)));
  length = ntohs (*((u_int16_t *) (buf + INT64_LEN)));

  lock (DB);
  if (!database_master_get_object_hist (db, oid, length, &hist))
    {
      unlock (DB);
      goto fail;
    }

  unlock (DB);
  c1 = clock();
  if (!returnGetObjectHist (conn, GET_OBJECT_HIST, *hist))
    goto fail;
  c2 = clock();
  t =  (float)(c2 - c1) / CLOCKS_PER_SEC;
  time += t;
  if (t > 0)
    printf ("return time : %f, time %f\n", t, time);

  if (hist != NULL)
    {
      free_tlist (hist);
      free (hist);
    }
  free (buf);
  return 1;
fail:
  if (buf != NULL)
    free (buf);
  if (hist != NULL)
    {
      free_tlist (hist);
      free (hist);
    }
  returnErrorMessage (conn, GET_OBJECT_HIST, TMP_FAILURE,
		      "Error on master node");
  return 1;
}

static int
h_undoTrans (int conn, char *hbuf)
{
  u_int64_t tid;
  u_int32_t len = 0, data_len = 0;
  int res;
  char rflags[FLAG_LEN], *buf = NULL;
  struct stringList *storages = NULL;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }
  tid = ntohll (*((u_int64_t *) (buf)));
  lock (DB);
  if ((res = database_master_undo_trans (db, tid, &storages)) == 0)
    {
      unlock (DB);
      goto fail;
    }
  else if (res == -1)		/* unknown tid */
    {
      unlock (DB);
      free (buf);
      returnErrorMessage (conn, UNDO_TRANS, TRANS_NOT_FOUND, "tid not found");
      return 1;
    }

  unlock (DB);
  if (!returnUndoTrans (conn, UNDO_TRANS, *storages))
    goto fail;
  if (storages != NULL)
    {
      stringList_Free (storages);
      free (storages);
    }
  free (buf);
  return 1;
fail:
  if (storages != NULL)
    {
      stringList_Free (storages);
      free (storages);
    }
  if (buf != NULL)
    free (buf);
  returnErrorMessage (conn, UNDO_TRANS, TMP_FAILURE, "Error on master node");
  return 1;
}

static int
h_beginTrans (int conn, char *hbuf)
{
  u_int64_t tid;
  u_int32_t len = 0, data_len = 0, i;
  char rflags[FLAG_LEN], *buf = NULL, *id = NULL;
  unsigned char s[ID_LEN];
  struct stringList storages;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }

  tid = ntohll (*((u_int64_t *) (buf)));

  /* generate tid if tid is null... */
 tid:
  if (!generate_tid (s, last_generated_tid))
    goto tid;

  /* use rotation to generate the random storages list */
  stringList_New (&storages, replication_nb, UUID_LEN);

  lock (REPLICATION);
  lock (STORAGES_IDX);

  /* XXX must check len of storage index to avoid work without storage ready */

  for (i = 0; i < replication_nb; i++)
    {
      stringList_GetItem (storage_index, &id, last_storage_replication);
      /* add storage id to list */
      stringList_Append (&storages, id);
      free (id);
      /* next storage */
      last_storage_replication++;
      if (last_storage_replication >= storage_index->last)
	last_storage_replication = 0;
    }
  unlock (STORAGES_IDX);
  unlock (REPLICATION);

  if (!returnBeginTrans (conn, BEGIN_TRANS, s, storages))
    goto fail;
  /* save new tid */
  for (i = 0; i < ID_LEN; i++)
    last_generated_tid[i] = s[i];

  stringList_Free (&storages);
  free (buf);
  return 1;
fail:
  stringList_Free (&storages);
  if (buf != NULL)
    free (buf);
  returnErrorMessage (conn, BEGIN_TRANS, TMP_FAILURE, "Error on master node");
  return 1;
}

static int
h_endTrans (int conn, char *hbuf)
{
  u_int64_t tid, oid, serial;
  u_int32_t len = 0, data_len = 0, i, j, oid_nb, storage_nb;
  char rflags[FLAG_LEN], storage_id[UUID_LEN + 1], *buf = NULL;
  struct stringList storage;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }
  /* get tid */
  tid = ntohll (*((u_int64_t *) (buf)));
  len = INT64_LEN;
  /* get list of storage */
  storage_nb = ntohl (*((u_int32_t *) (buf + len)));
  len += INT32_LEN;
  if (storage_nb > replication_nb)	/* strange */
    return 1;

  stringList_New (&storage, storage_nb, UUID_LEN);
  memset (storage_id, 0, UUID_LEN + 1);
  for (i = 0; i < storage_nb; i++)
    {
      memcpy (storage_id, buf + len, UUID_LEN);
      len += UUID_LEN;
      stringList_Append (&storage, storage_id);
    }

  /* store trans */
  lock (DB);
  if (!database_master_begin_trans (db, tid, ltid, storage))
    {
      unlock (DB);
      stringList_Free (&storage);
      goto fail;
    }
  unlock (DB);
  stringList_Free (&storage);

  oid_nb = ntohl (*((u_int32_t *) (buf + len)));
  /* get oids for the transaction and store them */
  len += INT32_LEN;
  for (i = 0; i < oid_nb; i++)
    {
      oid = ntohll (*((u_int64_t *) (buf + len)));
      len += INT64_LEN;
      serial = ntohll (*((u_int64_t *) (buf + len)));
      len += INT64_LEN;
      /* add metadata for object into database */
      lock (DB);
      if (!(database_master_put_object (db, tid, oid, serial)))
	{			/* transaction not valid */
	  len -= INT64_LEN * 2 * (i + 1);	/* go back to the beginning of the oid list */
	  for (j = 0; j < i; j++)	/* delete previous object we register */
	    {
	      oid = ntohll (*((u_int64_t *) (buf + len)));
	      len += INT64_LEN;
	      database_master_delete_object (db, oid, tid);
	    }
	  unlock (DB);
	  returnErrorMessage (conn, END_TRANS, TRANS_NOT_VALID,
			      "invalid version of object ");
	  return 1;
	}

      unlock (DB);
    }
  lock (DB);

  /* change status for transaction */
  if (!database_master_end_trans (db, tid))
    {
      unlock (DB);
      goto fail;
    }
  unlock (DB);
  /* update last tid */
  lock (LTID);
  ltid = tid;

  unlock (LTID);

  if (!returnEndTrans (conn, END_TRANS))
    goto fail;
  free (buf);
  return 1;
fail:
  if (buf != NULL)
    free (buf);

  returnErrorMessage (conn, END_TRANS, TMP_FAILURE, "Error on master node");
  return 1;
}

static int
h_getAllSN (int conn, char *hbuf)
{
  u_int32_t len = 0, data_len = 0;
  int res;
  char rflags[FLAG_LEN], *buf = NULL;
  struct nlist *lnodes = NULL;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }

  lock (DB);
  res = database_master_get_all_storages_infos (db, &lnodes);
  if (res == 0)
    {
      unlock (DB);
      goto fail;
    }
  else if (res == -1)
    {
      returnErrorMessage (conn, GET_ALL_SN, TMP_FAILURE, "No storage ready");
      unlock (DB);
      return 1;
    }
  unlock (DB);
  if (!returnGetAllSN (conn, GET_ALL_SN, *lnodes))
    goto fail;
  free (buf);
  if (lnodes != NULL)
    {
      free_nlist (lnodes);
      free (lnodes);
    }
  return 1;
fail:
  if (buf != NULL)
    free (buf);
  if (lnodes != NULL)
    {
      free_nlist (lnodes);
      free (lnodes);
    }
  returnErrorMessage (conn, GET_ALL_SN, TMP_FAILURE, "Error on master node");
  return 1;
}

static int
h_getAllCN (int conn, char *hbuf)
{
  u_int32_t len = 0, data_len = 0;
  char rflags[FLAG_LEN], *buf = NULL;
  struct nlist *lnodes = NULL;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }
  lock (DB);
  if (!database_master_get_all_clients_infos (db, &lnodes))
    {
      unlock (DB);
      goto fail;
    }
  unlock (DB);

  if (!returnGetAllCN (conn, GET_ALL_CN, *lnodes))
    goto fail;
  free (buf);
  if (lnodes != NULL)
    {
      free_nlist (lnodes);
      free (lnodes);
    }
  return 1;
fail:
  if (buf != NULL)
    free (buf);
  if (lnodes != NULL)
    {
      free_nlist (lnodes);
      free (lnodes);
    }
  returnErrorMessage (conn, GET_ALL_CN, TMP_FAILURE, "Error on master node");
  return 1;
}

static int
h_getSNInfo (int conn, char *hbuf)	/* XXX not used */
{
  u_int32_t len = 0, data_len = 0;
  char rflags[FLAG_LEN], *ip = NULL, *buf = NULL, id[UUID_LEN + 1];
  u_int16_t port;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }

  memset (id, 0, UUID_LEN + 1);
  memcpy (id, buf, UUID_LEN);

  lock (DB);
  if (!database_master_get_storage_infos (db, id, &ip, &port))
    {
      unlock (DB);
      goto fail;
    }
  unlock (DB);
/*   if (!returnGetSNInfo (conn, 17, ip, port)) */
/*     goto fail; */
  free (buf);
  return 1;
fail:
  if (buf != NULL)
    free (buf);
  returnErrorMessage (conn, GET_SN_INFO, TMP_FAILURE, "Error on master node");
  return 1;
}

static int
h_failure (int conn, char *hbuf)
{
  u_int32_t len = 0, data_len = 0, i;
  char rflags[FLAG_LEN], id[UUID_LEN + 1], *buf;
  struct nlist *lclients;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    return 0;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	{
	  free (buf);
	  return 1;		/* XXX what to do ? */
	}
    }
  memset (id, 0, UUID_LEN + 1);
  memcpy (id, buf, UUID_LEN);
  free (buf);
  /**
   * either test to connect to storage,
   * either trust client and mark storage as unreliable
   */
  syslog (LOG_MAKEPRI (LOG_USER, LOG_WARNING),
	  "storage %s is reported as unreliable", id);
  database_master_unreliable_storage (db, id);

  /* send del storage to all clients */
  lock (DB);
  if (database_master_get_all_clients_infos (db, &lclients) == 1)
    for (i = 0; i < lclients->last; i++)
      delStorage (lclients->objects[i].addr, lclients->objects[i].port,
		  DEL_SN, id);
  unlock (DB);
  return 1;
}

static int
h_clientClose (int conn, char *hbuf) /* done */
{
  u_int16_t i;
  u_int32_t len = 0, data_len = 0;
  char rflags[FLAG_LEN], id[UUID_LEN + 1], *buf = NULL;
  struct nlist *lclients = NULL;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }

  memset (id, 0, UUID_LEN + 1);
  memcpy (id, buf, UUID_LEN);
  lock (DB);
  if (!database_master_delete_client (db, id))
    {
      unlock (DB);
      goto fail;
    }

  /* send message of del client to all other client */
  if (database_master_get_all_clients_infos (db, &lclients) == 1)
    {
      unlock (DB);
      for (i = 0; i < lclients->last; i++)
	if (strncmp (lclients->objects[i].id, id, UUID_LEN) != 0)
	  delClient (lclients->objects[i].addr, lclients->objects[i].port,
		     DEL_CN, id);
    }
  else
    unlock (DB);
  /* XXX must change to test if error */
  if (lclients != NULL)
    {
      free_nlist (lclients);
      free (lclients);
    }
  free (buf);
  return 1;
fail:
  if (lclients != NULL)
    {
      free_nlist (lclients);
      free (lclients);
    }
  if (buf != NULL)
    free (buf);
  returnErrorMessage (conn, CLIENT_CLOSE, TMP_FAILURE,
		      "Error on master node");
  return 1;
}

static int
h_storageClose (int conn, char *hbuf)
{
  u_int16_t i;
  u_int32_t len = 0, data_len = 0;
  char rflags[FLAG_LEN], id[UUID_LEN+1], *buf = NULL;
  struct nlist *lclients = NULL;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }

  memset (id, 0, UUID_LEN + 1);
  memcpy (id, buf, UUID_LEN);

  lock (DB);
  if (!database_master_close_storage (db, id))
    {				/* XXX must change and retry to close storage... */
      unlock (DB);
      goto fail;
    }

  /* remove storage from index */
  lock (STORAGES_IDX);
  create_index ();
  unlock (STORAGES_IDX);

  /* send message of del storage to all clients */
  if (database_master_get_all_clients_infos (db, &lclients) == 1)
    for (i = 0; i < lclients->last; i++)
      delStorage (lclients->objects[i].addr, lclients->objects[i].port,
                  DEL_SN, id);

  unlock (DB);
  if (lclients != NULL)
    {
      free_nlist (lclients);
      free (lclients);
    }
  free (buf);

  return 1;
fail:
  if (lclients != NULL)
    {
      free_nlist (lclients);
      free (lclients);
    }
  if (buf != NULL)
    free (buf);
  returnErrorMessage (conn, STORAGE_CLOSE, TMP_FAILURE,
		      "Error on master node");
  return 1;
}

static int
h_storageStart (int conn, char *hbuf)
{
  u_int16_t port, status = 0;
  u_int32_t len = 0, data_len = 0;
  char rflags[FLAG_LEN], id[UUID_LEN+1], ip[IP_LEN];
  char *buf = NULL, *sock_ip = NULL;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }
  /* id */
  memset (id, 0, UUID_LEN + 1);
  memcpy (id, buf, UUID_LEN);
  /* ip */
  memset (ip, 0, IP_LEN + 1);
  memcpy (ip, buf + UUID_LEN, IP_LEN);
  /* port */
  port = ntohs (*((u_int16_t *) (buf + UUID_LEN + IP_LEN)));
  if (port == 0)		/* trying to add strange storage */
    return 1;

  /* XXX make better test */
  if (!getIp (conn, &sock_ip))
    perror("storage starting");

  /* update or store information about the storage node */
  lock (DB);
  if (!database_master_storage_starting (db, id, sock_ip, port, &status))
    {
      unlock (DB);
      goto fail;
    }
  unlock (DB);

  if (status == 2)		/*storage unreliable */
    {
      if (!returnStorageStart (conn, STORAGE_START, ID, status))
	goto fail;
      /* then send data to storage in order to get back its sanity */
      make_storage_clean (conn, id);
    }
  else if (status == 1)
    {
      if (!returnStorageStart (conn, STORAGE_START, ID, status))
	goto fail;
      /* send index to make the storage check */
      send_storage_index (conn, id);
    }
  else if (!returnStorageStart (conn, STORAGE_START, ID, status))
    goto fail;

  free (buf);
  return 1;
fail:
  if (buf != NULL)
    free (buf);
  if (sock_ip != NULL)
    free (sock_ip);
  returnErrorMessage (conn, STORAGE_START, TMP_FAILURE,
		      "Error on master node");
  return 1;
}

static int
h_storageReady (int conn, char *hbuf)
{
  char rflags[FLAG_LEN];
  u_int32_t len = 0, data_len = 0, j;
  u_int16_t port;
  char *ip = NULL, *buf = NULL, storage_id[UUID_LEN + 1];
  struct nlist *lclients = NULL;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    if (!fill_buffer (conn, buf, &len, data_len - len))
      goto fail;

  /* storage id */
  memset (storage_id, 0, UUID_LEN + 1);
  memcpy (storage_id, buf, UUID_LEN);

  /* change status to ok */
  lock (DB);
  if (!database_master_storage_ready (db, storage_id))
    {
      unlock (DB);
      goto fail;
    }

  /* add storage into index */
  lock (STORAGES_IDX);
  create_index ();
  unlock (STORAGES_IDX);

  master_ready = 1;
 /* check if master is ready */
/*   if (!master_ready) */
/*     { */
/*       if (!database_master_all_objects_accessible(db)) */
/*         /\* master not ready *\/ */
/*         master_ready = 0; */
/*       else */
/*         master_ready = 1; */
/*     } */

  /* Get infos for the storage */
  if (!database_master_get_storage_infos (db, storage_id, &ip, &port))
    {
      unlock (DB);
      goto fail;
    }

  /* send message to all clients to add storage */
  if (database_master_get_all_clients_infos (db, &lclients) == 1)
    {
      for (j = 0; j < lclients->last; j++)
	addStorage (lclients->objects[j].addr, lclients->objects[j].port,
		    ADD_SN, storage_id, ip, port);
    }
  unlock (DB);

  if (lclients != NULL)
    {
      free_nlist (lclients);
      free (lclients);
    }

  free (buf);
  if (ip != NULL)
    free (ip);
  return 1;
fail:
  if (lclients != NULL)
    {
      free_nlist (lclients);
      free (lclients);
    }
  if (buf != NULL)
    free (buf);
  if (ip != NULL)
    free (ip);
  returnErrorMessage (conn, STORAGE_READY, TMP_FAILURE,
		      "Error on master node");
  return 1;
}

static int
h_clientStart (int conn, char *hbuf)
{
  u_int16_t port;
  u_int32_t len = 0, data_len = 0, i;
  char rflags[FLAG_LEN];
  char ip[IP_LEN + 1], id[UUID_LEN + 1], *buf = NULL;
  struct nlist *lclients = NULL;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }

  /* must check if master is ready otherwise dont take message into account */
  if (!master_ready)
    {
      returnErrorMessage (conn, CLIENT_START, NOT_READY,
                          "Not all objects accessible");
      return 1;
    }

  /* id */
  memset (id, 0, UUID_LEN + 1);
  memcpy (id, buf, UUID_LEN);
  /* ip */
  memset (ip, 0, IP_LEN + 1);
  memcpy (ip, buf + UUID_LEN, IP_LEN);
  /* port */
  port = ntohs (*((u_int16_t *) (buf + UUID_LEN + IP_LEN)));

  if (port == 0)
    return 1;

  /* add client into database */
  lock (DB);
  if (!database_master_start_client (db, id, ip, port, conn))
    {
      unlock (DB);
      goto fail;
    }

  /* send message to add client to all other clients */
  if (!database_master_get_all_clients_infos (db, &lclients))
    {
      unlock (DB);
      goto fail;
    }
  unlock (DB);
  for (i = 0; i < lclients->last; i++)
    if (strncmp (lclients->objects[i].id, id, ID_LEN) != 0)
      addClient (lclients->objects[i].addr, lclients->objects[i].port, ADD_CN,
		 id, ip, port);

  /* send database info to client */
  if (!returnClientStart (conn, CLIENT_START, DBinfo))
    goto fail;


  if (lclients != NULL)
    {
      free_nlist (lclients);
      free (lclients);
    }
  free (buf);
  return 1;
fail:
  if (lclients != NULL)
    {
      free_nlist (lclients);
      free (lclients);
    }
  if (buf != NULL)
    free (buf);
  returnErrorMessage (conn, CLIENT_START, TMP_FAILURE,
		      "Error on master node");
  return 1;
}

static int
h_getStorageForTrans (int conn, char *hbuf)
{
  char rflags[FLAG_LEN];
  u_int64_t tid;
  u_int32_t len = 0, data_len = 0;
  char *buf = NULL, storage_id[UUID_LEN + 1];
  struct stringList *storages = NULL;

  /* header */
  memcpy (rflags, hbuf + INT16_LEN, FLAG_LEN);
  data_len = ntohl (*((u_int32_t *) (hbuf + INT16_LEN + FLAG_LEN)));
  buf = (char *) malloc (data_len);
  if (!buf)
    goto fail;

  while (len < data_len)
    {
      if (!fill_buffer (conn, buf, &len, data_len - len))
	goto fail;
    }
  memset (storage_id, 0, UUID_LEN + 1);
  memcpy (storage_id, buf, UUID_LEN);
  tid = ntohll (*((u_int64_t *) (buf + UUID_LEN)));
  lock (DB);
  if (!database_master_get_storages_for_trans
      (db, tid, storage_id, &storages))
    {
      unlock (DB);
      goto fail;
    }
  unlock (DB);
  if (!returnGetStorageForTrans (conn, GET_STORAGE_FOR_TRANS, *storages))
    goto fail;
  free (buf);
  return 1;
fail:
  if (buf != NULL)
    free (buf);
  returnErrorMessage (conn, GET_STORAGE_FOR_TRANS, TMP_FAILURE,
		      "Error on master node");
  return 1;
}


/* function that handle each new connection and call the appropriate function */
static void *
client_handler (void *data)
{
  int conn;
  char buf[HEADER_LEN];
  u_int32_t buf_len = 0;
  u_int16_t method;

  database_thread_init ();
  conn = *((int *) data);

  while (1)
    {
      buf_len = 0;

      if (!fill_buffer (conn, buf, &buf_len, 8))
	goto fail;

      method = ntohs (*((u_int16_t *) (buf)));
      syslog (LOG_MAKEPRI (LOG_USER, LOG_DEBUG), "client %d call method %d",
	      conn, method);
      switch (method)
	{
	case GET_OBJECT_BY_OID:
	  if (!h_getObjectByOid (conn, buf))
	    goto fail;
	  break;
	case GET_OBJECT_BY_SERIAL:
	  if (!h_getObjectBySerial (conn, buf))
	    goto fail;
	  break;
	case GET_SERIAL:
	  if (!h_getSerial (conn, buf))
	    goto fail;
	  break;
	case GET_LAST_TRANS:
	  if (!h_getLastTransaction (conn, buf))
	    goto fail;
	  break;
	case GET_OID:
	  if (!h_getOid (conn, buf))
	    goto fail;
	  break;
	case GET_TRANS_SN:
	  if (!h_getTransSN (conn, buf))
	    goto fail;
	  break;
	case GET_OBJECT_HIST:
	  if (!h_getObjectHist (conn, buf))
	    goto fail;
	  break;
	case UNDO_TRANS:
	  if (!h_undoTrans (conn, buf))
	    goto fail;
	  break;
	case BEGIN_TRANS:
	  if (!h_beginTrans (conn, buf))
	    goto fail;
	  break;
	case END_TRANS:
	  if (!h_endTrans (conn, buf))
	    goto fail;
	  break;
	case GET_ALL_SN:
	  if (!h_getAllSN (conn, buf))
	    goto fail;
	  break;
	case GET_ALL_CN:
	  if (!h_getAllCN (conn, buf))
	    goto fail;
	  break;
	case GET_SN_INFO:
	  if (!h_getSNInfo (conn, buf))
	    goto fail;
	  break;
	case FAILURE:
	  if (!h_failure (conn, buf))
	    goto fail;
	  break;
	case CLIENT_CLOSE:
	  h_clientClose (conn, buf);
	  goto end;
	  break;
	case STORAGE_CLOSE:
	  h_storageClose (conn, buf);
	  goto end;
	  break;
	case STORAGE_START:
	  if (!h_storageStart (conn, buf))
      goto end;
	  break;
	case STORAGE_READY:
	  h_storageReady (conn, buf);
	  goto end;
	  break;
	case GET_STORAGE_FOR_TRANS:
	  if (!h_getStorageForTrans (conn, buf))
      goto fail;
	  break;
	case CLIENT_START:
	  if (!h_clientStart (conn, buf))
	    goto fail;
	  break;
	}
    }

 fail:
  lock(DB);
  database_master_remove_client (db, conn);
  unlock(DB);
 end:
  syslog (LOG_MAKEPRI (LOG_USER, LOG_INFO), "End of connection %d", conn);
  database_thread_end ();
  close (conn);
  free (data);
  return NULL;
}


/*
 * thread which is a udp server, used for the automatic discovery
 * of master node by storages and client
 */
static void *
udp_server(void *data)
{
  int soc, rcode;
  int bd = 1;
  u_int16_t meth;
  u_int32_t data_len;
  ssize_t received, send;
  struct sockaddr_in addr;
  char rcv_buf[HEADER_LEN], send_buf[RHEADER_LEN];

  /* create server */
  soc = socket (PF_INET, SOCK_DGRAM, IPPROTO_UDP);
  setsockopt (soc, SOL_SOCKET, SO_BROADCAST, (int *) &bd, sizeof (bd));
  addr.sin_family = AF_INET;
  addr.sin_port = htons (10825);
  addr.sin_addr.s_addr = htonl (INADDR_ANY);
  bind(soc,(struct sockaddr *)&addr,sizeof addr);

  /* prebuild a response packet */
  meth = htons (SEARCH_MASTER);
  data_len = htonl(0);
  memcpy (send_buf, &meth, INT16_LEN);
  memcpy (send_buf + INT16_LEN, flags, FLAG_LEN);
  memcpy (send_buf + INT16_LEN + FLAG_LEN, &data_len, INT32_LEN);

  while (1)
    {
      struct sockaddr_in client_addr;
      int size = sizeof (client_addr);
      /* wait for a packet */
      memset (rcv_buf, 0, HEADER_LEN);
      received = recvfrom (soc, rcv_buf, HEADER_LEN, 0, (struct sockaddr *) &client_addr, &size);
      /* check packet */
      if ((ntohs (*((u_int16_t *) (rcv_buf)))) != SEARCH_MASTER)
        {
          syslog (LOG_MAKEPRI (LOG_USER, LOG_WARNING), "return method error");
          rcode = htons (METHOD_ERROR);
          memcpy (send_buf + INT16_LEN + FLAG_LEN + INT32_LEN, &rcode, INT16_LEN);
          send = sendto (soc, (char *)send_buf, RHEADER_LEN, 0, (struct sockaddr *) &client_addr, size);
          continue;
        }
      /* send response */
      rcode = 0;
      memcpy (send_buf + INT16_LEN + FLAG_LEN + INT32_LEN, &rcode, INT16_LEN);
      send = sendto (soc, (char *)send_buf, RHEADER_LEN, 0, (struct sockaddr *) &client_addr, size);
    }
  close(soc);
}




/* function that generate a uuid and store it on disk */
static int
generate_id ()
{
  FILE *fid;
  memset (ID, 0, UUID_LEN + 1);
  /* check if a uuid ever exists */
  if ((fid = fopen (MASTER_ID_FILE, "r")) != NULL)
    {
      fread (ID, UUID_LEN, 1, fid);
      uuid_parse (ID, master_id);
      fclose (fid);
      return 1;
    }

  /* otherwise generate uuid */
  uuid_generate (master_id);
  uuid_unparse (master_id, ID);
  /* store it on disk */
  fid = fopen (MASTER_ID_FILE, "w");
  fwrite (ID, UUID_LEN, 1, fid);
  fclose (fid);
  return 1;
}



int
parse_arg (int argc, char **argv)
{
  int c, option_index = 0;

  while (1)
    {
      static struct option long_options[] = {
	{"log-level", required_argument, 0, 'l'},
	{"create-database", no_argument, 0, 'c'},
	{"replications", required_argument, 0, 'r'},
	{"database", required_argument, 0, 'd'},
	{0, 0, 0, 0}
      };
      option_index = 0;

      c = getopt_long (argc, argv, "cl:d:r:", long_options, &option_index);
      /* Detect the end of the options. */
      if (c == -1)
	break;

      switch (c)
	{
	case 'c':
	  create_db = 1;
	  break;
	case 'l':
	  switch (atoi (optarg))
	    {
	    case 3:
	      setlogmask (LOG_UPTO (LOG_DEBUG));
	      break;
	    case 2:
	      setlogmask (LOG_UPTO (LOG_INFO));
	      break;
	    case 1:
	      setlogmask (LOG_UPTO (LOG_NOTICE));
	      break;
	    }
	  break;
	case 'r':
	  replication_nb = atoi (optarg);
	  break;
  case 'd':
    strncpy (database_dir, optarg, BUF_SIZE-1);
    break;
	case '?':
	  /* getopt_long already printed an error message. */
	  break;
	default:
	  abort ();
	}
    }
  /* Print any remaining command line arguments (not options). */
  if (optind < argc)
    {
      printf ("non-option ARGV-elements: ");
      while (optind < argc)
	printf ("%s ", argv[optind++]);
      putchar ('\n');
      return 0;
    }
  return 1;
}


int
main (int argc, char **argv)
{
  struct sockaddr_in addr;
  pthread_attr_t attr;
  pthread_t udp_th;
  int r, reuse = 1, i;
  FILE *fd;

  signal (SIGINT, cleanup_handler);
  signal (SIGTERM, cleanup_handler);
  signal (SIGSEGV, cleanup_handler);

  /* default init */
  setlogmask (LOG_UPTO (LOG_ERR));
  strncpy (database_dir, "./db", BUF_SIZE-1);

  if (!parse_arg (argc, argv))
    return -1;

  /* open syslog */
  openlog ("neomaster", 0, 0);

  if (!generate_id ())
    goto fail;

  syslog (LOG_MAKEPRI (LOG_USER, LOG_NOTICE), "id : %s", ID);

  /* open database */
  if ((db = database_master_open (create_db)) == 0)
    goto fail;

  syslog (LOG_MAKEPRI (LOG_USER, LOG_NOTICE),
	  "connection to database opened");

  /* init info */
  DBinfo.name = (char *) malloc (sizeof ("Neo") + 1);
  memset (DBinfo.name, 0, sizeof ("Neo") + 1);
  strcpy (DBinfo.name, "Neo");
  DBinfo.supportVersion = 0;
  DBinfo.supportUndo = 1;
  DBinfo.supportTransUndo = 1;
  DBinfo.readOnly = 0;
  DBinfo.ext = (char *) malloc (sizeof (" ") + 1);
  memset (DBinfo.ext, 0, sizeof (" ") + 1);
  strcpy (DBinfo.ext, " ");

  /* init for oid and tid generation */
  if (!create_db)
    {
      fd = fopen (MASTER_DATA_FILE, "r");
      fread (ascii, sizeof (int), 8, fd);
      fread (last_generated_tid, sizeof (unsigned char), 8, fd);
      fclose (fd);
    }
  else
    {
      for (i = 0; i < ID_LEN; i++)
        {
          ascii[i] = 0;
          last_generated_tid[i] = 0;
        }
    }
  ltid = 0;

  /* init storages index */
  storage_index = NULL;
  last_storage_replication = 0;

  /* set thread */
  init_mutex ();
  if (pthread_attr_init (&attr) != 0)
    {
      syslog (LOG_MAKEPRI (LOG_USER, LOG_ERR), "pthread_attr_init %s",
	      strerror (errno));
      goto fail;
    }

  if (pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED) != 0)
    {
      syslog (LOG_MAKEPRI (LOG_USER, LOG_ERR),
	      "pthread_attr_setdetachedstate %s", strerror (errno));
      goto fail;
    }


  /* create udp server */
  if (pthread_create (&udp_th, &attr, udp_server, NULL) != 0)
    {
      syslog (LOG_MAKEPRI (LOG_USER, LOG_ERR), "pthread_create forudp server %s",
              strerror (errno));
      goto fail;
    }


  /* create socket to listen */
  soc = socket (PF_INET, SOCK_STREAM, 0);
  if (soc < 0)
    {
      syslog (LOG_MAKEPRI (LOG_USER, LOG_ERR), "socket %s", strerror (errno));
      goto fail;
    }

  r =
    setsockopt (soc, SOL_SOCKET, SO_REUSEADDR, (int *) &reuse,
		sizeof (reuse));
  if (r == -1)
    {
      syslog (LOG_MAKEPRI (LOG_USER, LOG_ERR), "setsockopt %s",
	      strerror (errno));
    }

  addr.sin_family = AF_INET;
  addr.sin_port = htons (MASTER_PORT);
  addr.sin_addr.s_addr = htonl (INADDR_ANY);
  if (bind (soc, (struct sockaddr *) &addr, sizeof (addr)) != 0)
    {
      syslog (LOG_MAKEPRI (LOG_USER, LOG_ERR), "bind %s", strerror (errno));
      goto fail;
    }

  if (listen (soc, 5) != 0)
    {
      syslog (LOG_MAKEPRI (LOG_USER, LOG_ERR), "listen %s", strerror (errno));
      goto fail;
    }

  syslog (LOG_MAKEPRI (LOG_USER, LOG_NOTICE), "listening on port %d",
	  MASTER_PORT);

  while (1)
    {
      int *connp;
     pthread_t th;

      /* XXX not optimal */
      connp = (int *) malloc (sizeof (int));
      if (!connp)
	{
	  perror ("malloc");
	  goto fail;
	}

      *connp = accept (soc, 0, 0);
      if (*connp < 0)
	{
	  syslog (LOG_MAKEPRI (LOG_USER, LOG_ERR), "accept %s",
		  strerror (errno));
	  free (connp);
	  goto fail;
	}

      syslog (LOG_MAKEPRI (LOG_USER, LOG_INFO),
	      "New client connected with %d", *connp);

      if (pthread_create (&th, &attr, client_handler, connp) != 0)
	{
	  syslog (LOG_MAKEPRI (LOG_USER, LOG_ERR), "pthread_create %s",
		  strerror (errno));
	  free (connp);
	  goto fail;
	}
    }

fail:
  free (DBinfo.ext);
  if (soc >= 0)
    close (soc);
  database_close (db);
  syslog (LOG_MAKEPRI (LOG_USER, LOG_NOTICE), "Close master");
  closelog ();
  return 1;
}
